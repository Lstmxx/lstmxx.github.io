{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/leetcode/算法实现/LRU.ts","path":"leetcode/算法实现/LRU.ts","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1695293636379},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1695293636379},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1695293636379},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1695293636379},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1695293636380},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1695293636379},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1695293636380},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1695293636381},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1695293636382},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1695293636382},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1695293636382},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1695293636382},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1695293636382},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1695293636382},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1695293636383},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1695293636383},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1695293636382},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1695293636383},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1695293636383},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1695293636380},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1695293636381},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1695293636381},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1695293636381},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1695293636381},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1695293636381},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1695293636381},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1695293636383},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1695293636384},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1695293636382},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1695293636384},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1695293636385},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1695293636384},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1695293636384},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1695293636385},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1695293636385},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1695293636385},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1695293636383},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1695293636385},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1695293636385},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1695293636384},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1695293636384},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1695293636384},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1695293636384},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1695293636387},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1695293636388},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1695293636389},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1695293636389},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1695293636390},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1695293636387},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1695293636386},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1695293636388},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1695293636386},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1695293636386},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1695293636386},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1695293636386},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1695293636386},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1695293636387},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1695293636390},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1695293636389},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1695293636390},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1695293636390},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1695293636391},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1695293636391},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1695293636391},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1695293636391},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1695293636391},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1695293636389},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1695293636391},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1695293636392},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1695293636392},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1695293636392},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1695293636393},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1695293636392},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1695293636392},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1695293636388},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1695293636393},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1695293636393},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1695293636393},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1695293636391},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1695293636391},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1695303213370},{"_id":"themes/butterfly/README.md","hash":"4e01b47448d9f3a02afc04eef644e2321253f6f4","modified":1696867750815},{"_id":"themes/butterfly/package.json","hash":"2807775d1b79a380b510530faf0735eeacd7a59f","modified":1696867750824},{"_id":"themes/butterfly/languages/default.yml","hash":"90a6dc361de67532437d819a55ec64945ca5404b","modified":1696867750815},{"_id":"themes/butterfly/_config.yml","hash":"421b77b99c85035f34183ff14cbfbc4dff1a3078","modified":1696867750815},{"_id":"themes/butterfly/README_CN.md","hash":"262fba7e30cc966b66e6b7aee99f295b15eba724","modified":1696867750815},{"_id":"themes/butterfly/plugins.yml","hash":"9b7647f0abda10287f86f66ef81eedbb417459b7","modified":1696867750824},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"5004faee365139521f161babd66649a8107e4008","modified":1696867750816},{"_id":"themes/butterfly/languages/en.yml","hash":"af5603b1a888f167dc80be6d53a19437b5cf6bef","modified":1696867750816},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"03629d1d13a7be09d4933aa5dc0dcbe45e79140c","modified":1696867750816},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1695303213371},{"_id":"themes/butterfly/layout/archive.pug","hash":"bb32c9c476372de747dfa563b83f77d7a917a77d","modified":1696867750816},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1695303213379},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1695303213379},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1695303213379},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1695303213380},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1695303213369},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1695303213370},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1695303213370},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1695303213370},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1695303213370},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1695303213371},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1695303213371},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"f03129356c788bf47071c3f007f2ef5b6b1498af","modified":1696867750816},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"db275f7fbe4438b54cd813b695f4834e10aa234f","modified":1696867750818},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1695303213380},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1695303213373},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1695303213371},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1695303213380},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1695303213380},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1695303213373},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1695303213380},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"860f967ecf3c6a6ea785b560a7aae4d0757cd18a","modified":1696867750824},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a8eef3f37428436554f58a2b6bac7c255fbdf38d","modified":1696867750824},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1695303213380},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"96f861151e3b889ef0ffe78821d489ad2625ee43","modified":1696867750825},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"022b870ee8ad7ac05d1569268b61899d2f706221","modified":1696867750824},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1695303213380},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"d5c7e61257b08a9648404f6f48ce4d471cd5fa55","modified":1696867750825},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"7caf549810f971c34196fb9deac2d992545bdff9","modified":1696867750825},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1695303213381},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"93229d44b35b9da92e647b89d6d3087085974a29","modified":1696867750825},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"e2a8a09bfe47da26eab242a36f516e6c452c799a","modified":1696867750825},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"418684993a3a3a2ac534257a2d9ecbcead6808c1","modified":1696867750825},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1695303213381},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"365db87ddfc582bf8c15cb440c48bed95106e4b1","modified":1696867750825},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"5cb273e95846874e3a58074074c501df23c5e912","modified":1696867750826},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"19773218877281ccffed921431e87148413a7c20","modified":1696867750826},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"512c68a22ae4a58d6a6b24b368a0c00c2ccb4fcb","modified":1696867750825},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"1acefc59ead75ebd8cafee36efc7da4fa426d088","modified":1696867750826},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"ffc62222f8d7b4d44c1c0726c8a08824a2201039","modified":1696867750826},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"5c2a07df5874b5377540884e4da14dd21489378f","modified":1696867750826},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4526c75e5bf84609d67e92b6af3524bcb278e852","modified":1696867750826},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1695303213386},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1695303213386},{"_id":"themes/butterfly/source/css/var.styl","hash":"152b6bd4b6285165541a71f5a1c913f8ee6a602b","modified":1696867750830},{"_id":"themes/butterfly/source/js/main.js","hash":"4b4f882a393cbf5b3dfc2b218608a09905f3e3db","modified":1696867750831},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1695303213386},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1695303213371},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1695303213371},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"ffb13539d343498b7d7093c546831a8bde90b6a2","modified":1696867750816},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1695303213371},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1695303213371},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1695303213371},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1695303213387},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"5208fe1e75d97a05fd9bdd6cc53c59d8b741b94b","modified":1696867750817},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1695303213372},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1696867750831},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1695303213372},{"_id":"themes/butterfly/source/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1696867750831},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"a5c7d362ae63474c1a4e3eb5cd09804b3684e984","modified":1696867750817},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"50d1b08367f709e5416140043933e79cd8d77559","modified":1696867750817},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1695303213372},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1695303213373},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1695303213373},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1695303213373},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"5574804fdea5edf7fd52aad2caf030614d5e7f2f","modified":1696867750818},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1695303213373},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"a096ff8eb6b2a22395be881f827ff2a686ba5596","modified":1696867750818},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"1d39670ee6225f85f5c53bf5c84f3fd6e19290e8","modified":1696867750821},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"12e57491e94fa00d953bbda9db0b6d6169e2358c","modified":1696867750822},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1695303213373},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1695303213379},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1695303213379},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"c8ff6ddd5bfe1190b7b8056b68ce41114fd79dcb","modified":1696867750826},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f19694a42dbe28eda4b39a1696e8fbcd277bc76c","modified":1696867750826},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1695303213379},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"fad650f88778b33a6358e38cf50dfafc0974d28f","modified":1696867750827},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"4dcd468e4d11a0ac75406162678feffcd89fee00","modified":1696867750826},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"66f7a8b0cebc05c575ec3cb70b08d6854029d87a","modified":1696867750823},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1695303213383},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1695303213383},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1695303213383},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1695303213383},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"134811b2d696f9ed2c0cd578f3886f1c60770c0a","modified":1696867750827},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"029eebbdcb3c682780d1de629fa06858cbe9782b","modified":1696867750827},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1695303213383},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6cf26ffb8a0343eda1cde65b6b73b0ddbe8fcfc","modified":1696867750827},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"f853075c1399be950107247b1fe79cdd086120e4","modified":1696867750827},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"f845b9b4efdee750f70c023aab27432611f83059","modified":1696867750828},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"1ca53ee8c4a2dee23acba46c67e5a9f01c5d2eb5","modified":1696867750828},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1695303213384},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1695303213383},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1695303213384},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0db591a1f4ed5adcb8668a549bbee5c9d62682cf","modified":1696867750828},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"e549d24ad81a7d93326a509ff8dcfcc58c80729e","modified":1696867750828},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1695303213384},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1695303213384},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1695303213384},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1695303213384},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1695303213384},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1695303213385},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"d4ebc41b5c855dd75f47de7345d62f85ce7cf073","modified":1696867750829},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1695303213385},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1695303213384},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1695303213385},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"5cddbb5f4eae695a26685e415d821b523e0f17bf","modified":1696867750829},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1695303213385},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1695303213385},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"2d02e52b360f6e6cae47c293ae57ed78e2554663","modified":1696867750830},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a9bf2e1153a8486acd1ea8e0e528a07059ade17b","modified":1696867750829},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1695303213385},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1695303213385},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"909bb5079b26b6ee68177919f522566503654058","modified":1696867750830},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1695303213386},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1696867750831},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1695303213375},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1696867750831},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1695303213375},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"f7299f9fef5bf94bb58c8cd3be8ee660ad2f9cd4","modified":1696867750818},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1695303213375},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1695303213375},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1695303213375},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1695303213375},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5b73920843ce858df6e3b03325d5d1f43cdab3","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"46aec6466959baec1c3d71a5dbc510fbeb00c91d","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"62f16a602e57e5f7f7c5249dd37b42d436dc032a","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3bc4c1b91568561f0491bdac65b75aa0bfd01f27","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0d378ee8a671982a46213a4bfb223b4f3409aea9","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"a9709905593d960954e2dd572f09f48a6c2b1ef7","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"2d7b0b09678adba09481e3152e0b32962677f650","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1695303213376},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f15699abb8c7a255aabad0222ae53eee387c66a3","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1995a654ba7ad62775a0a6e2922209cd1a85f2e3","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"63cea2b5c8f7b59f5919379d61a2bb2ce8ed7623","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"894bf60ff5170cf1e4f276a8cedaf8301bceb824","modified":1696867750820},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"46865e3f52096acb07d0212174b4e8751b123aea","modified":1696867750821},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"ad7f1ee2e67deee0706e0838b5724dd37fc30a34","modified":1696867750821},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"c5f7081ca29db8cc80f808dfc29e36d5fa22fd7e","modified":1696867750819},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1695303213374},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"3a5ccfc69bd8ccb4b8f3ce3502023f7914f2a022","modified":1696867750819},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"42496c6a32406604178d24685408b77a40adc993","modified":1696867750822},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6b67982bb7a3713b5bffd6a23ba2810425c504d0","modified":1696867750821},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"b928be14d1b47a9fadb1bcc5f5072a7328752d4b","modified":1696867750822},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"3335024ba91f55ccf3858571b7898f46881c455c","modified":1696867750822},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1695303213377},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"3ba49cfe186e9ca05faf9f0d0113611ec47e9b38","modified":1696867750822},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1695303213382},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1695303213378},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1695303213378},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1695303213382},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1695303213382},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"25914321762e30aacc610bc4dfb9de3e1cb556a3","modified":1696867750827},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1695303213382},{"_id":"source/categories/index.md","hash":"9d17c7e85d2c305b7d78cc336fc25fb2b86df1bd","modified":1695807278820},{"_id":"source/_posts/socketio实现服务器推送（demo实现一个聊天室）.md","hash":"c857d5a1a161c646a19afa09747568af04fc2162","modified":1695440432475},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"3ec354778f6a4ac97fb64d5629c83b293ccceb5e","modified":1695450141273},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"821e973d41f7b3b64cde91e0e836ea49c43e3c06","modified":1695450141275},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"830b1d592278b9f676df0cf9a91b1eeda2456aec","modified":1695450141275},{"_id":"themes/butterfly2/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1695450801606},{"_id":"themes/butterfly2/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1695450801606},{"_id":"themes/butterfly2/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1695450801606},{"_id":"themes/butterfly2/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1695450801606},{"_id":"themes/butterfly2/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1695450801615},{"_id":"themes/butterfly2/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1695450801615},{"_id":"themes/butterfly2/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1695450801607},{"_id":"themes/butterfly2/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1695450801607},{"_id":"themes/butterfly2/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1695450801607},{"_id":"themes/butterfly2/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1695450801607},{"_id":"themes/butterfly2/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1695450801607},{"_id":"themes/butterfly2/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1695450801607},{"_id":"themes/butterfly2/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1695450801615},{"_id":"themes/butterfly2/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1695450801615},{"_id":"themes/butterfly2/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1695450801615},{"_id":"themes/butterfly2/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1695450801615},{"_id":"themes/butterfly2/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1695450801606},{"_id":"themes/butterfly2/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1695450801606},{"_id":"themes/butterfly2/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1695450801606},{"_id":"themes/butterfly2/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1695450801606},{"_id":"themes/butterfly2/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1695450801606},{"_id":"themes/butterfly2/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1695450801609},{"_id":"themes/butterfly2/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1695450801615},{"_id":"themes/butterfly2/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1695450801609},{"_id":"themes/butterfly2/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1695450801615},{"_id":"themes/butterfly2/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1695450801615},{"_id":"themes/butterfly2/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1695450801615},{"_id":"themes/butterfly2/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1695450801615},{"_id":"themes/butterfly2/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1695450801616},{"_id":"themes/butterfly2/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1695450801615},{"_id":"themes/butterfly2/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1695450801616},{"_id":"themes/butterfly2/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1695450801616},{"_id":"themes/butterfly2/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1695450801616},{"_id":"themes/butterfly2/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1695450801616},{"_id":"themes/butterfly2/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1695450801616},{"_id":"themes/butterfly2/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1695450801616},{"_id":"themes/butterfly2/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1695450801616},{"_id":"themes/butterfly2/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1695450801617},{"_id":"themes/butterfly2/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1695450801617},{"_id":"themes/butterfly2/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1695450801617},{"_id":"themes/butterfly2/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1695450801617},{"_id":"themes/butterfly2/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1695450801621},{"_id":"themes/butterfly2/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1695450801621},{"_id":"themes/butterfly2/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1695450801621},{"_id":"themes/butterfly2/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1695450801621},{"_id":"themes/butterfly2/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1695450801621},{"_id":"themes/butterfly2/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1695450801622},{"_id":"themes/butterfly2/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1695450801622},{"_id":"themes/butterfly2/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1695450801621},{"_id":"themes/butterfly2/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1695450801607},{"_id":"themes/butterfly2/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1695450801608},{"_id":"themes/butterfly2/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1695450801609},{"_id":"themes/butterfly2/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1695450801614},{"_id":"themes/butterfly2/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1695450801614},{"_id":"themes/butterfly2/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1695450801617},{"_id":"themes/butterfly2/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1695450801615},{"_id":"themes/butterfly2/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1695450801615},{"_id":"themes/butterfly2/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1695450801617},{"_id":"themes/butterfly2/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1695450801617},{"_id":"themes/butterfly2/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1695450801618},{"_id":"themes/butterfly2/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1695450801614},{"_id":"themes/butterfly2/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1695450801618},{"_id":"themes/butterfly2/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1695450801619},{"_id":"themes/butterfly2/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1695450801620},{"_id":"themes/butterfly2/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1695450801622},{"_id":"themes/butterfly2/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1695450801622},{"_id":"themes/butterfly2/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1695450801620},{"_id":"themes/butterfly2/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1695450801610},{"_id":"themes/butterfly2/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1695450801620},{"_id":"themes/butterfly2/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1695450801620},{"_id":"themes/butterfly2/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1695450801611},{"_id":"themes/butterfly2/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1695450801612},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1695450801610},{"_id":"themes/butterfly2/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1695450801613},{"_id":"themes/butterfly2/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1695450801614},{"_id":"themes/butterfly2/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1695450801617},{"_id":"themes/butterfly2/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1695450801617},{"_id":"themes/butterfly2/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1695450801614},{"_id":"themes/butterfly2/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1695450801617},{"_id":"themes/butterfly2/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1695450801617},{"_id":"themes/butterfly2/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1695450801618},{"_id":"source/leetcode/index.md","hash":"17dde49f704a6d3f645ba4fde86989d6d890fb93","modified":1695867478188},{"_id":"source/leetcode/动态规划/1137. 第 N 个泰波那契数.md","hash":"48f2e5c1e5d0dfda1a8c26913bcf7537d46b6d32","modified":1695739763527},{"_id":"source/leetcode/动态规划/119. 杨辉三角 II.md","hash":"50a9a86094a9af77264520ec5cb94758fda8aed7","modified":1695739763529},{"_id":"source/leetcode/动态规划/118. 杨辉三角.md","hash":"b2d751499507741a27b8a77e899f80123aa77b18","modified":1695739763528},{"_id":"source/leetcode/动态规划/120. 三角形最小路径和.md","hash":"1227bd5c86dfc3cab40f2d855f291b36d3ea3f2a","modified":1695739763529},{"_id":"source/leetcode/动态规划/45. 跳跃游戏 II.md","hash":"3f8cdd4346d76a482ab8c5033901470319ac08df","modified":1695740538473},{"_id":"source/leetcode/动态规划/322. 零钱兑换.md","hash":"57f1827470f75cc0fa614826bcbff9068edc64d0","modified":1695739763530},{"_id":"source/leetcode/动态规划/509. 斐波那契数.md","hash":"50453559487b9b9491dce7a91362e84aa17e8314","modified":1695739763530},{"_id":"source/leetcode/动态规划/53. 最大子序和.md","hash":"473a90cafa25cb9aa49291051bd8f83f4ae7cfbc","modified":1695739763531},{"_id":"source/leetcode/动态规划/55. 跳跃游戏.md","hash":"c517fca64416f0a2c9819a36ba7649a109103f30","modified":1695739763531},{"_id":"source/leetcode/动态规划/62. 不同路径.md","hash":"85de1a58c30c562128c05fdf515276eae0929351","modified":1695739763531},{"_id":"source/leetcode/动态规划/63. 不同路径 II.md","hash":"efffe9ff0d2b2486046a9001ea6d3d8911f13fe2","modified":1695739763532},{"_id":"source/leetcode/动态规划/70. 爬楼梯.md","hash":"f620a39ff41cfdaaa2af6f67880a024c81ba5109","modified":1695739763532},{"_id":"source/leetcode/动态规划/64. 最小路径和.md","hash":"5bdf95333fa3ce53208889227a7e04075e2eba03","modified":1695739763532},{"_id":"source/leetcode/动态规划/746. 使用最小花费爬楼梯.md","hash":"12194d06d05184a9bbd7a1e489bfd322888bd490","modified":1695739763533},{"_id":"source/leetcode/动态规划/91. 解码方法.md","hash":"1737b85583679a6fa85279cc7bdd9869995fdb51","modified":1695739763533},{"_id":"source/leetcode/动态规划/931. 下降路径最小和.md","hash":"f405a3c4fb05c7e9c31dc6854f08c679cc0f35fa","modified":1695739763533},{"_id":"source/leetcode/动态规划/剑指 Offer II 103. 最少的硬币数目.md","hash":"fbd8f55b49815e8c6a432da0491fb335b8abe811","modified":1695739763534},{"_id":"source/leetcode/动态规划/技巧.md","hash":"d7b3511ea6f7c357b854ec09dbca67a4dea2cb00","modified":1695739763534},{"_id":"source/leetcode/二叉树/1008. 前序遍历构造二叉搜索树.md","hash":"261bccbe1fb0f994300428597dfbffe217e9a84e","modified":1695739763543},{"_id":"source/leetcode/二叉树/1022. 从根到叶的二进制数之和.md","hash":"1d4085f1eaf513e99c4d9bfeea7d426831623772","modified":1695739763545},{"_id":"source/leetcode/二叉树/101. 对称二叉树.md","hash":"1a19b610b29f0e7ef49fb43c255070c5d22afad5","modified":1695739763544},{"_id":"source/leetcode/二叉树/1026. 节点与其祖先之间的最大差值.md","hash":"da31e0952addc16af264e033a4f23f993c5abf94","modified":1695739763545},{"_id":"source/leetcode/二叉树/103. 二叉树的锯齿形层序遍历.md","hash":"b191c56e29bdcba0e8f3c7e8a721bc39908eb776","modified":1695739763546},{"_id":"source/leetcode/二叉树/102. 二叉树的层序遍历.md","hash":"7502e97d2613746dceef156d24ea5082b6e18f14","modified":1695739763544},{"_id":"source/leetcode/二叉树/100. 相同的树.md","hash":"3ad24ac76afebec959ce6a378a55093aee4b0fef","modified":1695739763543},{"_id":"source/leetcode/二叉树/105. 从前序与中序遍历序列构造二叉树.md","hash":"98208cfadf0fc9b09fa12754619b0ea4ec609829","modified":1695739763546},{"_id":"source/leetcode/二叉树/104. 二叉树的最大深度.md","hash":"b2e97af1088ca84a56da059f1295f2dd48e9623b","modified":1695739763546},{"_id":"source/leetcode/二叉树/1038. 把二叉搜索树转换为累加树.md","hash":"3b3ba17acf7ade43344c76fcb1e63d5bfa26357b","modified":1695739763546},{"_id":"source/leetcode/二叉树/106. 从中序与后序遍历序列构造二叉树.md","hash":"9651e5aa8a749fc39a9cc8c21c68a52d15a6e91e","modified":1695739763547},{"_id":"source/leetcode/二叉树/109. 有序链表转换二叉搜索树.md","hash":"ba7f07032e6e5daa30fc861f01f514add8f9ec97","modified":1695739763548},{"_id":"source/leetcode/二叉树/107. 二叉树的层序遍历 II.md","hash":"707767369c3ec9bee7f381b2e800acceb2e2ae13","modified":1695739763547},{"_id":"source/leetcode/二叉树/110. 平衡二叉树.md","hash":"4e155bd8891e0295ffc38511d23dc62293a1fd07","modified":1695739763548},{"_id":"source/leetcode/二叉树/1104. 二叉树寻路.md","hash":"1b12e7af86fe9369c35ba670414eef20418b0291","modified":1695739763548},{"_id":"source/leetcode/二叉树/1110. 删点成林.md","hash":"f0ac1303e1ec100a29527f2947e2b48501132be0","modified":1695739763549},{"_id":"source/leetcode/二叉树/111. 二叉树的最小深度.md","hash":"519763d8250c8b543554a7f04203f862078b17f4","modified":1695739763548},{"_id":"source/leetcode/二叉树/112. 路径总和.md","hash":"57359ecc909b62eee36c6e856ce34b81faeb57a2","modified":1695739763549},{"_id":"source/leetcode/二叉树/1123. 最深叶节点的最近公共祖先.md","hash":"4058babe56ad4df6bf47f7edca448001936d0433","modified":1695739763549},{"_id":"source/leetcode/二叉树/114. 二叉树展开为链表.md","hash":"79d44e4d99f0242be4256c52d81191d066649def","modified":1695739763550},{"_id":"source/leetcode/二叉树/1145. 二叉树着色游戏.md","hash":"1b8870d3200543e965831b71fe5d5cf28fb17118","modified":1695739763550},{"_id":"source/leetcode/二叉树/113. 路径总和 II.md","hash":"269d719bade38f40438471abd529723676c70e8e","modified":1695739763549},{"_id":"source/leetcode/二叉树/116. 填充每个节点的下一个右侧节点指针.md","hash":"1625f14dd46a49161d74caa7adc2b0d2050b90d5","modified":1695739763550},{"_id":"source/leetcode/二叉树/1161. 最大层内元素和.md","hash":"bdf28cf459f180a1e7b6c4693b9d37acf8529183","modified":1695739763551},{"_id":"source/leetcode/二叉树/1080. 根到叶路径上的不足节点.md","hash":"b4ad6d09ae65676ad405c342ce6151c8d5388295","modified":1695739763547},{"_id":"source/leetcode/二叉树/108. 将有序数组转换为二叉搜索树.md","hash":"78c4975356589f3d0eb8bb3c7b9f1ed1c573b85a","modified":1695739763547},{"_id":"source/leetcode/二叉树/117. 填充每个节点的下一个右侧节点指针 II.md","hash":"d10bfae6c0d95494aeef2f841795e3d6397343fc","modified":1695739763551},{"_id":"source/leetcode/二叉树/124. 二叉树中的最大路径和.md","hash":"e82836a4f9e13607d116a20b9d6f5d4dbd6903ec","modified":1695739763551},{"_id":"source/leetcode/二叉树/1302. 层数最深叶子节点的和.md","hash":"1046d9d93fa5c023cce073aa566ed98a50d99397","modified":1695739763552},{"_id":"source/leetcode/二叉树/1305. 两棵二叉搜索树中的所有元素.md","hash":"5e3ef0017061eaf5cd48fed4d74da8f30c02c40a","modified":1695739763553},{"_id":"source/leetcode/二叉树/1315. 祖父节点值为偶数的节点和.md","hash":"82666eb9765cbdcf37e3dbb3542c3d0f40b5decc","modified":1695739763553},{"_id":"source/leetcode/二叉树/1325. 删除给定值的叶子节点.md","hash":"011de5431aa096023f11e4889195bd8a90c4914e","modified":1695739763553},{"_id":"source/leetcode/二叉树/1339. 分裂二叉树的最大乘积.md","hash":"4ea2f47c1678194724b155e70dc760d306cd17ac","modified":1695739763554},{"_id":"source/leetcode/二叉树/1361. 验证二叉树.md","hash":"82080f2fe71f4a78d1dd389dce01836530b7c572","modified":1695739763554},{"_id":"source/leetcode/二叉树/1261. 在受污染的二叉树中查找元素.md","hash":"8c186649472f1c13429acc89575f114820a4a1f0","modified":1695739763552},{"_id":"source/leetcode/二叉树/1367. 二叉树中的列表.md","hash":"ea31ea15035e96c0a5280492bf7712fc2c83662a","modified":1695739763554},{"_id":"source/leetcode/二叉树/1376. 通知所有员工所需的时间.md","hash":"034f23657b6c34ffa1fab87fbbe1e3935fd9c75a","modified":1695739763554},{"_id":"source/leetcode/二叉树/129. 求根节点到叶节点数字之和.md","hash":"1b9e6772c1b218c0b1224065b8d4ba1901c5b9c5","modified":1695739763552},{"_id":"source/leetcode/二叉树/1382. 将二叉搜索树变平衡.md","hash":"c69afcaa3b0b79b6223372292caa4a789a2fa4ff","modified":1695739763555},{"_id":"source/leetcode/二叉树/1379. 找出克隆二叉树中的相同节点.md","hash":"f17f4a5755ca3f14170d94f915b9e1a58fe884ac","modified":1695739763555},{"_id":"source/leetcode/二叉树/144. 二叉树的前序遍历.md","hash":"0196fd81e46592f1ef086161a928d3d254a514d1","modified":1695739763555},{"_id":"source/leetcode/二叉树/1448. 统计二叉树中好节点的数目.md","hash":"97d942fdf630ce1383d923405c63503cd3dace81","modified":1695739763555},{"_id":"source/leetcode/二叉树/145. 二叉树的后序遍历.md","hash":"f8cb160298eac6ec2be48e50418112362627f8aa","modified":1695739763555},{"_id":"source/leetcode/二叉树/173. 二叉搜索树迭代器.md","hash":"02e5bd0bfa9cd477e95ca8a34adbb732be1b3b94","modified":1695739763556},{"_id":"source/leetcode/二叉树/199. 二叉树的右视图.md","hash":"43ab8a04f667c9d7f41812fa95c77c91b027008e","modified":1695739763556},{"_id":"source/leetcode/二叉树/230. 二叉搜索树中第K小的元素.md","hash":"6073a6be79887ee99adc0a272dea64fac1c85f35","modified":1695739763557},{"_id":"source/leetcode/二叉树/226.翻转二叉树.md","hash":"8fa4210922b47bb3443f0dd0a27f0e9dac156033","modified":1695739763557},{"_id":"source/leetcode/二叉树/1457. 二叉树中的伪回文路径.md","hash":"0dfd5d44f3d1c818492fd06d7e73493d0fc5be6b","modified":1695739763556},{"_id":"source/leetcode/二叉树/236. 二叉树的最近公共祖先.md","hash":"e7fef7c94db1094c886bacc71e2ecb4e24824b6a","modified":1695739763558},{"_id":"source/leetcode/二叉树/235. 二叉搜索树的最近公共祖先.md","hash":"a43c7bd91961ab9961e3087477d1459ba90afbc8","modified":1695739763557},{"_id":"source/leetcode/二叉树/257. 二叉树的所有路径.md","hash":"c22fc6e2874df087005725d87b4f7815ca1389f4","modified":1695739763558},{"_id":"source/leetcode/二叉树/297. 二叉树的序列化与反序列化.md","hash":"bad174aaeace892d1d23b6c56390774e05aaae76","modified":1695739763558},{"_id":"source/leetcode/二叉树/337. 打家劫舍 III.md","hash":"40b794c86752b2e7d826a08860c202538b75f2ca","modified":1695739763559},{"_id":"source/leetcode/二叉树/404. 左叶子之和.md","hash":"7978fd70a36e39555df789e9157d406b0d51d1ff","modified":1695739763559},{"_id":"source/leetcode/二叉树/341. 扁平化嵌套列表迭代器.md","hash":"16a697667cdbddf0845eb23907d3a42e57148fc9","modified":1695739763559},{"_id":"source/leetcode/二叉树/429. N 叉树的层序遍历.md","hash":"f6de96829aa851ef08f2d817d75b2795ad3fe080","modified":1695739763560},{"_id":"source/leetcode/二叉树/437. 路径总和 III.md","hash":"60e99ab25a6de19ebb2dcbd84f76957f659d6110","modified":1695739763560},{"_id":"source/leetcode/二叉树/449. 序列化和反序列化二叉搜索树.md","hash":"1faa929252fb811206313cc0de01126b986b705e","modified":1695739763560},{"_id":"source/leetcode/二叉树/331. 验证二叉树的前序序列化.md","hash":"40ec00c36eff8c74bd00dc9b1ed919795cc5bf22","modified":1695739763559},{"_id":"source/leetcode/二叉树/450. 删除二叉搜索树中的节点.md","hash":"2487370091a9b2c7240a655f9c02b8f50cdfec3e","modified":1695739763560},{"_id":"source/leetcode/二叉树/508. 出现次数最多的子树元素和.md","hash":"4c0ddbde59753cc82304d1adb4df026697e9d099","modified":1695739763561},{"_id":"source/leetcode/二叉树/515. 在每个树行中找最大值.md","hash":"5832704de2f83c34acc5c3d14505e9e1d3b72906","modified":1695739763561},{"_id":"source/leetcode/二叉树/513. 找树左下角的值.md","hash":"5ab7d317994c419163663692dd41d8e4698630bc","modified":1695739763561},{"_id":"source/leetcode/二叉树/501. 二叉搜索树中的众数.md","hash":"ca4e9d2c11b5d8cb13e6cee0a22e59d55a4ac4da","modified":1695739763561},{"_id":"source/leetcode/二叉树/530. 二叉搜索树的最小绝对差.md","hash":"9c0f2da3ae7795193ffb8e3c1b756abae0e91708","modified":1695739763562},{"_id":"source/leetcode/二叉树/538. 把二叉搜索树转换为累加树.md","hash":"a1e73158229a5a1dafecf9122f997af5ccb9e840","modified":1695739763562},{"_id":"source/leetcode/二叉树/543. 二叉树的直径.md","hash":"a7d39a2d509fa1a7ff86c0f417a358a930f4519b","modified":1695739763562},{"_id":"source/leetcode/二叉树/563. 二叉树的坡度.md","hash":"afa05583f0fce78602e2e240cbfaaa661e515ac4","modified":1695739763563},{"_id":"source/leetcode/二叉树/559. N 叉树的最大深度.md","hash":"266d8dce5ea8109786300157de8f8c6cb79eb129","modified":1695739763562},{"_id":"source/leetcode/二叉树/572. 另一个树的子树.md","hash":"4d954d506cf141d87b540426acbb9239fa2dc88a","modified":1695739763563},{"_id":"source/leetcode/二叉树/590. N 叉树的后序遍历.md","hash":"6386ed3654edab4c666c21a8e207244746b750d2","modified":1695739763563},{"_id":"source/leetcode/二叉树/606. 根据二叉树创建字符串.md","hash":"141e1dbdadc6c704b80c89bf18d2b6962f1568c5","modified":1695739763563},{"_id":"source/leetcode/二叉树/589. N 叉树的前序遍历.md","hash":"22b5e74db457d207b98a0cfb8359264731ee1d08","modified":1695739763563},{"_id":"source/leetcode/二叉树/617. 合并二叉树.md","hash":"b1b3a9e22d27328252aa26d54650aeb5b1dd7572","modified":1695739763564},{"_id":"source/leetcode/二叉树/623. 在二叉树中增加一行.md","hash":"b1fb5c31a0c62bc48eb9d1d0b5466230510eecee","modified":1695739763564},{"_id":"source/leetcode/二叉树/652. 寻找重复的子树.md","hash":"9eb2561ab87a38c1b5467f11240ab33556161011","modified":1695739763565},{"_id":"source/leetcode/二叉树/637. 二叉树的层平均值.md","hash":"eb742da3dc79a5a3d1ca4e9f934321f203f09c7b","modified":1695739763565},{"_id":"source/leetcode/二叉树/654.最大二叉树.md","hash":"a2f864a043dc714c49371e3694e29c39a0b3694c","modified":1695739763566},{"_id":"source/leetcode/二叉树/653. 两数之和 IV - 输入 BST.md","hash":"d14f8a4879a9998ab2715bb11e0632dc0efeb3c9","modified":1695739763565},{"_id":"source/leetcode/二叉树/655. 输出二叉树.md","hash":"7128f50335a0a131deee01f1fa9d901e8535fa09","modified":1695739763566},{"_id":"source/leetcode/二叉树/662. 二叉树最大宽度.md","hash":"151ee18c8942364326e00365523de259b7f3ba36","modified":1695739763566},{"_id":"source/leetcode/二叉树/669. 修剪二叉搜索树.md","hash":"f2f3a28769dc6a30c5b01b2af21ad1cdcc1e07c8","modified":1695739763566},{"_id":"source/leetcode/二叉树/671. 二叉树中第二小的节点.md","hash":"da4fa1c6664816589e06de465d2641381988cdb6","modified":1695739763567},{"_id":"source/leetcode/二叉树/685. 冗余连接 II.md","hash":"7d3712aae4e4ed8e6a0d240426f5b181c815ce3a","modified":1695739763567},{"_id":"source/leetcode/二叉树/684. 冗余连接.md","hash":"57950f1108382576136535b03c66cc06d2124ed9","modified":1695739763567},{"_id":"source/leetcode/二叉树/700. 二叉搜索树中的搜索.md","hash":"a70d95df3af38f98e5073dfd6e82e46fa01f2b9c","modified":1695739763567},{"_id":"source/leetcode/二叉树/687. 最长同值路径.md","hash":"eadaaf587f21eda69ce9adada4a6bee48057e9cf","modified":1695739763567},{"_id":"source/leetcode/二叉树/701. 二叉搜索树中的插入操作.md","hash":"027d57ac949331efb4ec9205706fbff7179827ab","modified":1695739763568},{"_id":"source/leetcode/二叉树/703. 数据流中的第 K 大元素.md","hash":"a1beecf4547148023b1b7e698dd317ae042a32b8","modified":1695739763568},{"_id":"source/leetcode/二叉树/814. 二叉树剪枝.md","hash":"fd6b63cdb53432d3a8ebc844de2904510abbf56e","modified":1695739763568},{"_id":"source/leetcode/二叉树/863. 二叉树中所有距离为 K 的结点.md","hash":"c6ff145c2fec3c43ba3c44b44fed831d795bfe47","modified":1695739763568},{"_id":"source/leetcode/二叉树/865. 具有所有最深节点的最小子树.md","hash":"f37a3a379e01b7d1650708872449f9d84f752446","modified":1695739763569},{"_id":"source/leetcode/二叉树/872. 叶子相似的树.md","hash":"b705d463cb1ad9bc949a287d5a60927e06170a0b","modified":1695739763569},{"_id":"source/leetcode/二叉树/889. 根据前序和后序遍历构造二叉树.md","hash":"5183379e9f94975552de248fd10a2ba9eed0cbb7","modified":1695739763569},{"_id":"source/leetcode/二叉树/894. 所有可能的满二叉树.md","hash":"6ca778b53c0d7fb269a13fa34db1c29e1275e69d","modified":1695739763569},{"_id":"source/leetcode/二叉树/919. 完全二叉树插入器.md","hash":"0068c1c1b767773149c76210912585df123b2715","modified":1695739763570},{"_id":"source/leetcode/二叉树/897. 递增顺序搜索树.md","hash":"9170049faf396205a0356c9c74115d7670a4f9cd","modified":1695739763569},{"_id":"source/leetcode/二叉树/94. 二叉树的中序遍历.md","hash":"8dd06b7e71c8635abe14a82e684fcea08227e354","modified":1695739763570},{"_id":"source/leetcode/二叉树/938. 二叉搜索树的范围和.md","hash":"b15849de736669f420ca8d6b59d87ba4659664f2","modified":1695739763570},{"_id":"source/leetcode/二叉树/95. 不同的二叉搜索树 II.md","hash":"ab025c27093391b0a2be884942c639c61c917b9e","modified":1695739763570},{"_id":"source/leetcode/二叉树/951. 翻转等价二叉树.md","hash":"5182dc6087e248385ecfb46ad63187d4c0529540","modified":1695739763571},{"_id":"source/leetcode/二叉树/958. 二叉树的完全性检验.md","hash":"d06415f421bb044a093671b13c031e88d4ab34c5","modified":1695739763571},{"_id":"source/leetcode/二叉树/98. 验证二叉搜索树.md","hash":"ad2809a910d640fb9ec30a7349f8d863af7def66","modified":1695739763571},{"_id":"source/leetcode/二叉树/988. 从叶结点开始的最小字符串.md","hash":"c00ddb7e1be961dbea444c2a9f07d98ea5f90b38","modified":1695739763571},{"_id":"source/leetcode/二叉树/99. 恢复二叉搜索树.md","hash":"c001e33c1e00eccb95f92a7624712cf03bb29b39","modified":1695739763572},{"_id":"source/leetcode/二叉树/993. 二叉树的堂兄弟节点.md","hash":"951cbb7fc70daf6ea47eae2623158822c7f40010","modified":1695739763572},{"_id":"source/leetcode/二叉树/二叉树的遍历方式.md","hash":"0103ad61d954a1c4b5e38ee69c7c20aa2017e4b1","modified":1695739763572},{"_id":"source/leetcode/二叉树/998. 最大二叉树 II.md","hash":"c7bcbc4a1d37f5365603759705213428f7266235","modified":1695739763572},{"_id":"source/leetcode/链表/234. 回文链表.md","hash":"35d9936173fdd16496f1363526947a151aed4dbd","modified":1695739763594},{"_id":"source/leetcode/算法实现/LRU.ts","hash":"c68c6130c43ad92b6207bf86fe4d8d843236bfaf","modified":1695739763618},{"_id":"source/leetcode/链表/25.K 个一组翻转链表.md","hash":"ab1b28cf2e8dcf960d0bc55105f21e1626a41fc3","modified":1695739763595},{"_id":"source/leetcode/链表/链表的遍历方式.md","hash":"3d2a8ca377a5998db0aa46f34eb28d8150c1969f","modified":1695739763595},{"_id":"source/leetcode/链表/92.反转列表II.md","hash":"e3d3914ba461ff165ec730cd22408064936f77e8","modified":1695739763595},{"_id":"source/leetcode/面试经典150题/ 13. 罗马数字转整数.md","hash":"f98814265ec20add572b074408846cd215a9aa03","modified":1695739763602},{"_id":"source/leetcode/面试经典150题/12. 整数转罗马数字.md","hash":"2ee49e3819b3b8d717ce66ded3a0a4d2504ab96e","modified":1695739763603},{"_id":"source/leetcode/面试经典150题/121. 买卖股票的最佳时机.md","hash":"eaa02636096809aceac2827fd120f6b88d208a0b","modified":1695739763603},{"_id":"source/leetcode/面试经典150题/122. 买卖股票的最佳时机 II.md","hash":"2429c14617750ade30043e12115efc5a04f52951","modified":1695739763604},{"_id":"source/leetcode/面试经典150题/134. 加油站.md","hash":"33acc8193772874b3c9ba70dc519d65aa892b2af","modified":1695739763604},{"_id":"source/leetcode/面试经典150题/14. 最长公共前缀.md","hash":"d0fc3b7bca151e96b7cee0fb87918188184e3478","modified":1695739763605},{"_id":"source/leetcode/面试经典150题/151. 反转字符串中的单词.md","hash":"2fa4e6dcda86f182882fbee22ed0593cc6c8850c","modified":1695739763605},{"_id":"source/leetcode/面试经典150题/26. 删除有序数组中的重复项.md","hash":"15c50f3920160555fe0ed69c3f6156125ed5a980","modified":1695739763607},{"_id":"source/leetcode/面试经典150题/169. 多数元素.md","hash":"7b0890628dd0379bd01fc862c53937d1651cbc1b","modified":1695739763606},{"_id":"source/leetcode/面试经典150题/189. 轮转数组.md","hash":"7a01b3d766577dbc7f4388d645e2dedc53fb9a37","modified":1695739763607},{"_id":"source/leetcode/面试经典150题/27. 移除元素.md","hash":"c98f1fe883131844490a906f482044d0b655e6c5","modified":1695739763608},{"_id":"source/leetcode/面试经典150题/45. 跳跃游戏 II.md","hash":"77893a5af8cb697f4c5b0c27517f0f403b3acf80","modified":1695739763609},{"_id":"source/leetcode/面试经典150题/55. 跳跃游戏.md","hash":"b588c52e055841636a4a0aff41bc485c77062600","modified":1695739763610},{"_id":"source/leetcode/面试经典150题/58. 最后一个单词的长度.md","hash":"647eaf43b94f69db330c386fc2556f976986e41a","modified":1695739763610},{"_id":"source/leetcode/面试经典150题/380. O(1) 时间插入、删除和获取随机元素.md","hash":"33a61d2fb393376e5c4f80bf67af93a116f6a520","modified":1695739763608},{"_id":"source/leetcode/面试经典150题/6. N 字形变换.md","hash":"9e501abbccadc9ccf63fbc1cf7af73041f9d942b","modified":1695739763610},{"_id":"source/leetcode/面试经典150题/80. 删除有序数组中的重复项 II.md","hash":"4717625c2684fd0b60e0af274e96e01399b939b2","modified":1695739763611},{"_id":"source/leetcode/面试经典150题/88. 合并两个有序数组.md","hash":"25ed805b5a6ebb60edabcfdc922e27971297fb5e","modified":1695739763611},{"_id":"source/_posts/leetcode/index.md","hash":"e3babc1906eff7ec8efbd811b5b3330d88a52685","modified":1695739951432},{"_id":"source/_posts/leetcode/链表/25.K 个一组翻转链表.md","hash":"ab1b28cf2e8dcf960d0bc55105f21e1626a41fc3","modified":1695739763595},{"_id":"source/_posts/leetcode/算法实现/LRU.ts","hash":"c68c6130c43ad92b6207bf86fe4d8d843236bfaf","modified":1695739763618},{"_id":"source/_posts/leetcode/链表/链表的遍历方式.md","hash":"3d2a8ca377a5998db0aa46f34eb28d8150c1969f","modified":1695739763595},{"_id":"source/_posts/leetcode/面试经典150题/ 13. 罗马数字转整数.md","hash":"f98814265ec20add572b074408846cd215a9aa03","modified":1695739763602},{"_id":"source/_posts/leetcode/面试经典150题/12. 整数转罗马数字.md","hash":"2ee49e3819b3b8d717ce66ded3a0a4d2504ab96e","modified":1695739763603},{"_id":"source/_posts/leetcode/链表/92.反转列表II.md","hash":"e3d3914ba461ff165ec730cd22408064936f77e8","modified":1695739763595},{"_id":"source/_posts/leetcode/面试经典150题/134. 加油站.md","hash":"33acc8193772874b3c9ba70dc519d65aa892b2af","modified":1695739763604},{"_id":"source/_posts/leetcode/面试经典150题/121. 买卖股票的最佳时机.md","hash":"eaa02636096809aceac2827fd120f6b88d208a0b","modified":1695739763603},{"_id":"source/_posts/leetcode/面试经典150题/151. 反转字符串中的单词.md","hash":"2fa4e6dcda86f182882fbee22ed0593cc6c8850c","modified":1695739763605},{"_id":"source/_posts/leetcode/链表/234. 回文链表.md","hash":"35d9936173fdd16496f1363526947a151aed4dbd","modified":1695739763594},{"_id":"source/_posts/leetcode/面试经典150题/169. 多数元素.md","hash":"7b0890628dd0379bd01fc862c53937d1651cbc1b","modified":1695739763606},{"_id":"source/_posts/leetcode/面试经典150题/122. 买卖股票的最佳时机 II.md","hash":"2429c14617750ade30043e12115efc5a04f52951","modified":1695739763604},{"_id":"source/_posts/leetcode/面试经典150题/189. 轮转数组.md","hash":"7a01b3d766577dbc7f4388d645e2dedc53fb9a37","modified":1695739763607},{"_id":"source/_posts/leetcode/面试经典150题/26. 删除有序数组中的重复项.md","hash":"15c50f3920160555fe0ed69c3f6156125ed5a980","modified":1695739763607},{"_id":"source/_posts/leetcode/面试经典150题/380. O(1) 时间插入、删除和获取随机元素.md","hash":"33a61d2fb393376e5c4f80bf67af93a116f6a520","modified":1695739763608},{"_id":"source/_posts/leetcode/面试经典150题/45. 跳跃游戏 II.md","hash":"77893a5af8cb697f4c5b0c27517f0f403b3acf80","modified":1695739763609},{"_id":"source/_posts/leetcode/面试经典150题/27. 移除元素.md","hash":"c98f1fe883131844490a906f482044d0b655e6c5","modified":1695739763608},{"_id":"source/_posts/leetcode/面试经典150题/14. 最长公共前缀.md","hash":"d0fc3b7bca151e96b7cee0fb87918188184e3478","modified":1695739763605},{"_id":"source/_posts/leetcode/面试经典150题/88. 合并两个有序数组.md","hash":"25ed805b5a6ebb60edabcfdc922e27971297fb5e","modified":1695739763611},{"_id":"source/_posts/leetcode/面试经典150题/6. N 字形变换.md","hash":"9e501abbccadc9ccf63fbc1cf7af73041f9d942b","modified":1695739763610},{"_id":"source/_posts/leetcode/面试经典150题/80. 删除有序数组中的重复项 II.md","hash":"4717625c2684fd0b60e0af274e96e01399b939b2","modified":1695739763611},{"_id":"source/_posts/leetcode/面试经典150题/55. 跳跃游戏.md","hash":"b588c52e055841636a4a0aff41bc485c77062600","modified":1695739763610},{"_id":"source/_posts/leetcode/面试经典150题/58. 最后一个单词的长度.md","hash":"647eaf43b94f69db330c386fc2556f976986e41a","modified":1695739763610},{"_id":"source/_posts/leetcode/动态规划/1137. 第 N 个泰波那契数.md","hash":"48f2e5c1e5d0dfda1a8c26913bcf7537d46b6d32","modified":1695739763527},{"_id":"source/_posts/leetcode/动态规划/118. 杨辉三角.md","hash":"b2d751499507741a27b8a77e899f80123aa77b18","modified":1695739763528},{"_id":"source/_posts/leetcode/动态规划/120. 三角形最小路径和.md","hash":"1227bd5c86dfc3cab40f2d855f291b36d3ea3f2a","modified":1695739763529},{"_id":"source/_posts/leetcode/动态规划/509. 斐波那契数.md","hash":"50453559487b9b9491dce7a91362e84aa17e8314","modified":1695739763530},{"_id":"source/_posts/leetcode/动态规划/53. 最大子序和.md","hash":"473a90cafa25cb9aa49291051bd8f83f4ae7cfbc","modified":1695739763531},{"_id":"source/_posts/leetcode/动态规划/119. 杨辉三角 II.md","hash":"50a9a86094a9af77264520ec5cb94758fda8aed7","modified":1695739763529},{"_id":"source/_posts/leetcode/动态规划/45. 跳跃游戏 II.md","hash":"7758d5100f94ba7a856f997981e426fc13746c4a","modified":1695739763530},{"_id":"source/_posts/leetcode/动态规划/55. 跳跃游戏.md","hash":"c517fca64416f0a2c9819a36ba7649a109103f30","modified":1695739763531},{"_id":"source/_posts/leetcode/动态规划/64. 最小路径和.md","hash":"5bdf95333fa3ce53208889227a7e04075e2eba03","modified":1695739763532},{"_id":"source/_posts/leetcode/动态规划/322. 零钱兑换.md","hash":"57f1827470f75cc0fa614826bcbff9068edc64d0","modified":1695739763530},{"_id":"source/_posts/leetcode/动态规划/70. 爬楼梯.md","hash":"f620a39ff41cfdaaa2af6f67880a024c81ba5109","modified":1695739763532},{"_id":"source/_posts/leetcode/动态规划/746. 使用最小花费爬楼梯.md","hash":"12194d06d05184a9bbd7a1e489bfd322888bd490","modified":1695739763533},{"_id":"source/_posts/leetcode/动态规划/91. 解码方法.md","hash":"1737b85583679a6fa85279cc7bdd9869995fdb51","modified":1695739763533},{"_id":"source/_posts/leetcode/动态规划/技巧.md","hash":"d7b3511ea6f7c357b854ec09dbca67a4dea2cb00","modified":1695739763534},{"_id":"source/_posts/leetcode/动态规划/62. 不同路径.md","hash":"85de1a58c30c562128c05fdf515276eae0929351","modified":1695739763531},{"_id":"source/_posts/leetcode/动态规划/63. 不同路径 II.md","hash":"efffe9ff0d2b2486046a9001ea6d3d8911f13fe2","modified":1695739763532},{"_id":"source/_posts/leetcode/动态规划/剑指 Offer II 103. 最少的硬币数目.md","hash":"fbd8f55b49815e8c6a432da0491fb335b8abe811","modified":1695739763534},{"_id":"source/_posts/leetcode/动态规划/931. 下降路径最小和.md","hash":"f405a3c4fb05c7e9c31dc6854f08c679cc0f35fa","modified":1695739763533},{"_id":"source/_posts/leetcode/二叉树/1022. 从根到叶的二进制数之和.md","hash":"1d4085f1eaf513e99c4d9bfeea7d426831623772","modified":1695739763545},{"_id":"source/_posts/leetcode/二叉树/1026. 节点与其祖先之间的最大差值.md","hash":"da31e0952addc16af264e033a4f23f993c5abf94","modified":1695739763545},{"_id":"source/_posts/leetcode/二叉树/101. 对称二叉树.md","hash":"1a19b610b29f0e7ef49fb43c255070c5d22afad5","modified":1695739763544},{"_id":"source/_posts/leetcode/二叉树/102. 二叉树的层序遍历.md","hash":"7502e97d2613746dceef156d24ea5082b6e18f14","modified":1695739763544},{"_id":"source/_posts/leetcode/二叉树/1038. 把二叉搜索树转换为累加树.md","hash":"3b3ba17acf7ade43344c76fcb1e63d5bfa26357b","modified":1695739763546},{"_id":"source/_posts/leetcode/二叉树/1008. 前序遍历构造二叉搜索树.md","hash":"261bccbe1fb0f994300428597dfbffe217e9a84e","modified":1695739763543},{"_id":"source/_posts/leetcode/二叉树/100. 相同的树.md","hash":"3ad24ac76afebec959ce6a378a55093aee4b0fef","modified":1695739763543},{"_id":"source/_posts/leetcode/二叉树/103. 二叉树的锯齿形层序遍历.md","hash":"b191c56e29bdcba0e8f3c7e8a721bc39908eb776","modified":1695739763546},{"_id":"source/_posts/leetcode/二叉树/107. 二叉树的层序遍历 II.md","hash":"707767369c3ec9bee7f381b2e800acceb2e2ae13","modified":1695739763547},{"_id":"source/_posts/leetcode/二叉树/105. 从前序与中序遍历序列构造二叉树.md","hash":"98208cfadf0fc9b09fa12754619b0ea4ec609829","modified":1695739763546},{"_id":"source/_posts/leetcode/二叉树/1080. 根到叶路径上的不足节点.md","hash":"b4ad6d09ae65676ad405c342ce6151c8d5388295","modified":1695739763547},{"_id":"source/_posts/leetcode/二叉树/106. 从中序与后序遍历序列构造二叉树.md","hash":"9651e5aa8a749fc39a9cc8c21c68a52d15a6e91e","modified":1695739763547},{"_id":"source/_posts/leetcode/二叉树/109. 有序链表转换二叉搜索树.md","hash":"ba7f07032e6e5daa30fc861f01f514add8f9ec97","modified":1695739763548},{"_id":"source/_posts/leetcode/二叉树/110. 平衡二叉树.md","hash":"4e155bd8891e0295ffc38511d23dc62293a1fd07","modified":1695739763548},{"_id":"source/_posts/leetcode/二叉树/104. 二叉树的最大深度.md","hash":"b2e97af1088ca84a56da059f1295f2dd48e9623b","modified":1695739763546},{"_id":"source/_posts/leetcode/二叉树/111. 二叉树的最小深度.md","hash":"519763d8250c8b543554a7f04203f862078b17f4","modified":1695739763548},{"_id":"source/_posts/leetcode/二叉树/108. 将有序数组转换为二叉搜索树.md","hash":"78c4975356589f3d0eb8bb3c7b9f1ed1c573b85a","modified":1695739763547},{"_id":"source/_posts/leetcode/二叉树/1104. 二叉树寻路.md","hash":"1b12e7af86fe9369c35ba670414eef20418b0291","modified":1695739763548},{"_id":"source/_posts/leetcode/二叉树/112. 路径总和.md","hash":"57359ecc909b62eee36c6e856ce34b81faeb57a2","modified":1695739763549},{"_id":"source/_posts/leetcode/二叉树/114. 二叉树展开为链表.md","hash":"79d44e4d99f0242be4256c52d81191d066649def","modified":1695739763550},{"_id":"source/_posts/leetcode/二叉树/1123. 最深叶节点的最近公共祖先.md","hash":"4058babe56ad4df6bf47f7edca448001936d0433","modified":1695739763549},{"_id":"source/_posts/leetcode/二叉树/1145. 二叉树着色游戏.md","hash":"1b8870d3200543e965831b71fe5d5cf28fb17118","modified":1695739763550},{"_id":"source/_posts/leetcode/二叉树/113. 路径总和 II.md","hash":"269d719bade38f40438471abd529723676c70e8e","modified":1695739763549},{"_id":"source/_posts/leetcode/二叉树/116. 填充每个节点的下一个右侧节点指针.md","hash":"1625f14dd46a49161d74caa7adc2b0d2050b90d5","modified":1695739763550},{"_id":"source/_posts/leetcode/二叉树/1110. 删点成林.md","hash":"f0ac1303e1ec100a29527f2947e2b48501132be0","modified":1695739763549},{"_id":"source/_posts/leetcode/二叉树/1161. 最大层内元素和.md","hash":"bdf28cf459f180a1e7b6c4693b9d37acf8529183","modified":1695739763551},{"_id":"source/_posts/leetcode/二叉树/117. 填充每个节点的下一个右侧节点指针 II.md","hash":"d10bfae6c0d95494aeef2f841795e3d6397343fc","modified":1695739763551},{"_id":"source/_posts/leetcode/二叉树/1261. 在受污染的二叉树中查找元素.md","hash":"8c186649472f1c13429acc89575f114820a4a1f0","modified":1695739763552},{"_id":"source/_posts/leetcode/二叉树/124. 二叉树中的最大路径和.md","hash":"e82836a4f9e13607d116a20b9d6f5d4dbd6903ec","modified":1695739763551},{"_id":"source/_posts/leetcode/二叉树/1302. 层数最深叶子节点的和.md","hash":"1046d9d93fa5c023cce073aa566ed98a50d99397","modified":1695739763552},{"_id":"source/_posts/leetcode/二叉树/1305. 两棵二叉搜索树中的所有元素.md","hash":"5e3ef0017061eaf5cd48fed4d74da8f30c02c40a","modified":1695739763553},{"_id":"source/_posts/leetcode/二叉树/1315. 祖父节点值为偶数的节点和.md","hash":"82666eb9765cbdcf37e3dbb3542c3d0f40b5decc","modified":1695739763553},{"_id":"source/_posts/leetcode/二叉树/1339. 分裂二叉树的最大乘积.md","hash":"4ea2f47c1678194724b155e70dc760d306cd17ac","modified":1695739763554},{"_id":"source/_posts/leetcode/二叉树/1325. 删除给定值的叶子节点.md","hash":"011de5431aa096023f11e4889195bd8a90c4914e","modified":1695739763553},{"_id":"source/_posts/leetcode/二叉树/1361. 验证二叉树.md","hash":"82080f2fe71f4a78d1dd389dce01836530b7c572","modified":1695739763554},{"_id":"source/_posts/leetcode/二叉树/129. 求根节点到叶节点数字之和.md","hash":"1b9e6772c1b218c0b1224065b8d4ba1901c5b9c5","modified":1695739763552},{"_id":"source/_posts/leetcode/二叉树/1367. 二叉树中的列表.md","hash":"ea31ea15035e96c0a5280492bf7712fc2c83662a","modified":1695739763554},{"_id":"source/_posts/leetcode/二叉树/1376. 通知所有员工所需的时间.md","hash":"034f23657b6c34ffa1fab87fbbe1e3935fd9c75a","modified":1695739763554},{"_id":"source/_posts/leetcode/二叉树/1382. 将二叉搜索树变平衡.md","hash":"c69afcaa3b0b79b6223372292caa4a789a2fa4ff","modified":1695739763555},{"_id":"source/_posts/leetcode/二叉树/1457. 二叉树中的伪回文路径.md","hash":"0dfd5d44f3d1c818492fd06d7e73493d0fc5be6b","modified":1695739763556},{"_id":"source/_posts/leetcode/二叉树/1379. 找出克隆二叉树中的相同节点.md","hash":"f17f4a5755ca3f14170d94f915b9e1a58fe884ac","modified":1695739763555},{"_id":"source/_posts/leetcode/二叉树/144. 二叉树的前序遍历.md","hash":"0196fd81e46592f1ef086161a928d3d254a514d1","modified":1695739763555},{"_id":"source/_posts/leetcode/二叉树/173. 二叉搜索树迭代器.md","hash":"02e5bd0bfa9cd477e95ca8a34adbb732be1b3b94","modified":1695739763556},{"_id":"source/_posts/leetcode/二叉树/145. 二叉树的后序遍历.md","hash":"f8cb160298eac6ec2be48e50418112362627f8aa","modified":1695739763555},{"_id":"source/_posts/leetcode/二叉树/199. 二叉树的右视图.md","hash":"43ab8a04f667c9d7f41812fa95c77c91b027008e","modified":1695739763556},{"_id":"source/_posts/leetcode/二叉树/230. 二叉搜索树中第K小的元素.md","hash":"6073a6be79887ee99adc0a272dea64fac1c85f35","modified":1695739763557},{"_id":"source/_posts/leetcode/二叉树/236. 二叉树的最近公共祖先.md","hash":"e7fef7c94db1094c886bacc71e2ecb4e24824b6a","modified":1695739763558},{"_id":"source/_posts/leetcode/二叉树/226.翻转二叉树.md","hash":"8fa4210922b47bb3443f0dd0a27f0e9dac156033","modified":1695739763557},{"_id":"source/_posts/leetcode/二叉树/1448. 统计二叉树中好节点的数目.md","hash":"97d942fdf630ce1383d923405c63503cd3dace81","modified":1695739763555},{"_id":"source/_posts/leetcode/二叉树/235. 二叉搜索树的最近公共祖先.md","hash":"a43c7bd91961ab9961e3087477d1459ba90afbc8","modified":1695739763557},{"_id":"source/_posts/leetcode/二叉树/257. 二叉树的所有路径.md","hash":"c22fc6e2874df087005725d87b4f7815ca1389f4","modified":1695739763558},{"_id":"source/_posts/leetcode/二叉树/404. 左叶子之和.md","hash":"7978fd70a36e39555df789e9157d406b0d51d1ff","modified":1695739763559},{"_id":"source/_posts/leetcode/二叉树/341. 扁平化嵌套列表迭代器.md","hash":"16a697667cdbddf0845eb23907d3a42e57148fc9","modified":1695739763559},{"_id":"source/_posts/leetcode/二叉树/297. 二叉树的序列化与反序列化.md","hash":"bad174aaeace892d1d23b6c56390774e05aaae76","modified":1695739763558},{"_id":"source/_posts/leetcode/二叉树/429. N 叉树的层序遍历.md","hash":"f6de96829aa851ef08f2d817d75b2795ad3fe080","modified":1695739763560},{"_id":"source/_posts/leetcode/二叉树/337. 打家劫舍 III.md","hash":"40b794c86752b2e7d826a08860c202538b75f2ca","modified":1695739763559},{"_id":"source/_posts/leetcode/二叉树/331. 验证二叉树的前序序列化.md","hash":"40ec00c36eff8c74bd00dc9b1ed919795cc5bf22","modified":1695739763559},{"_id":"source/_posts/leetcode/二叉树/508. 出现次数最多的子树元素和.md","hash":"4c0ddbde59753cc82304d1adb4df026697e9d099","modified":1695739763561},{"_id":"source/_posts/leetcode/二叉树/449. 序列化和反序列化二叉搜索树.md","hash":"1faa929252fb811206313cc0de01126b986b705e","modified":1695739763560},{"_id":"source/_posts/leetcode/二叉树/437. 路径总和 III.md","hash":"60e99ab25a6de19ebb2dcbd84f76957f659d6110","modified":1695739763560},{"_id":"source/_posts/leetcode/二叉树/501. 二叉搜索树中的众数.md","hash":"ca4e9d2c11b5d8cb13e6cee0a22e59d55a4ac4da","modified":1695739763561},{"_id":"source/_posts/leetcode/二叉树/450. 删除二叉搜索树中的节点.md","hash":"2487370091a9b2c7240a655f9c02b8f50cdfec3e","modified":1695739763560},{"_id":"source/_posts/leetcode/二叉树/513. 找树左下角的值.md","hash":"5ab7d317994c419163663692dd41d8e4698630bc","modified":1695739763561},{"_id":"source/_posts/leetcode/二叉树/559. N 叉树的最大深度.md","hash":"266d8dce5ea8109786300157de8f8c6cb79eb129","modified":1695739763562},{"_id":"source/_posts/leetcode/二叉树/543. 二叉树的直径.md","hash":"a7d39a2d509fa1a7ff86c0f417a358a930f4519b","modified":1695739763562},{"_id":"source/_posts/leetcode/二叉树/538. 把二叉搜索树转换为累加树.md","hash":"a1e73158229a5a1dafecf9122f997af5ccb9e840","modified":1695739763562},{"_id":"source/_posts/leetcode/二叉树/563. 二叉树的坡度.md","hash":"afa05583f0fce78602e2e240cbfaaa661e515ac4","modified":1695739763563},{"_id":"source/_posts/leetcode/二叉树/530. 二叉搜索树的最小绝对差.md","hash":"9c0f2da3ae7795193ffb8e3c1b756abae0e91708","modified":1695739763562},{"_id":"source/_posts/leetcode/二叉树/515. 在每个树行中找最大值.md","hash":"5832704de2f83c34acc5c3d14505e9e1d3b72906","modified":1695739763561},{"_id":"source/_posts/leetcode/二叉树/589. N 叉树的前序遍历.md","hash":"22b5e74db457d207b98a0cfb8359264731ee1d08","modified":1695739763563},{"_id":"source/_posts/leetcode/二叉树/572. 另一个树的子树.md","hash":"4d954d506cf141d87b540426acbb9239fa2dc88a","modified":1695739763563},{"_id":"source/_posts/leetcode/二叉树/606. 根据二叉树创建字符串.md","hash":"141e1dbdadc6c704b80c89bf18d2b6962f1568c5","modified":1695739763563},{"_id":"source/_posts/leetcode/二叉树/617. 合并二叉树.md","hash":"b1b3a9e22d27328252aa26d54650aeb5b1dd7572","modified":1695739763564},{"_id":"source/_posts/leetcode/二叉树/590. N 叉树的后序遍历.md","hash":"6386ed3654edab4c666c21a8e207244746b750d2","modified":1695739763563},{"_id":"source/_posts/leetcode/二叉树/623. 在二叉树中增加一行.md","hash":"b1fb5c31a0c62bc48eb9d1d0b5466230510eecee","modified":1695739763564},{"_id":"source/_posts/leetcode/二叉树/652. 寻找重复的子树.md","hash":"9eb2561ab87a38c1b5467f11240ab33556161011","modified":1695739763565},{"_id":"source/_posts/leetcode/二叉树/637. 二叉树的层平均值.md","hash":"eb742da3dc79a5a3d1ca4e9f934321f203f09c7b","modified":1695739763565},{"_id":"source/_posts/leetcode/二叉树/653. 两数之和 IV - 输入 BST.md","hash":"d14f8a4879a9998ab2715bb11e0632dc0efeb3c9","modified":1695739763565},{"_id":"source/_posts/leetcode/二叉树/655. 输出二叉树.md","hash":"7128f50335a0a131deee01f1fa9d901e8535fa09","modified":1695739763566},{"_id":"source/_posts/leetcode/二叉树/662. 二叉树最大宽度.md","hash":"151ee18c8942364326e00365523de259b7f3ba36","modified":1695739763566},{"_id":"source/_posts/leetcode/二叉树/669. 修剪二叉搜索树.md","hash":"f2f3a28769dc6a30c5b01b2af21ad1cdcc1e07c8","modified":1695739763566},{"_id":"source/_posts/leetcode/二叉树/654.最大二叉树.md","hash":"a2f864a043dc714c49371e3694e29c39a0b3694c","modified":1695739763566},{"_id":"source/_posts/leetcode/二叉树/684. 冗余连接.md","hash":"57950f1108382576136535b03c66cc06d2124ed9","modified":1695739763567},{"_id":"source/_posts/leetcode/二叉树/671. 二叉树中第二小的节点.md","hash":"da4fa1c6664816589e06de465d2641381988cdb6","modified":1695739763567},{"_id":"source/_posts/leetcode/二叉树/685. 冗余连接 II.md","hash":"7d3712aae4e4ed8e6a0d240426f5b181c815ce3a","modified":1695739763567},{"_id":"source/_posts/leetcode/二叉树/687. 最长同值路径.md","hash":"eadaaf587f21eda69ce9adada4a6bee48057e9cf","modified":1695739763567},{"_id":"source/_posts/leetcode/二叉树/814. 二叉树剪枝.md","hash":"fd6b63cdb53432d3a8ebc844de2904510abbf56e","modified":1695739763568},{"_id":"source/_posts/leetcode/二叉树/701. 二叉搜索树中的插入操作.md","hash":"027d57ac949331efb4ec9205706fbff7179827ab","modified":1695739763568},{"_id":"source/_posts/leetcode/二叉树/863. 二叉树中所有距离为 K 的结点.md","hash":"c6ff145c2fec3c43ba3c44b44fed831d795bfe47","modified":1695739763568},{"_id":"source/_posts/leetcode/二叉树/703. 数据流中的第 K 大元素.md","hash":"a1beecf4547148023b1b7e698dd317ae042a32b8","modified":1695739763568},{"_id":"source/_posts/leetcode/二叉树/865. 具有所有最深节点的最小子树.md","hash":"f37a3a379e01b7d1650708872449f9d84f752446","modified":1695739763569},{"_id":"source/_posts/leetcode/二叉树/872. 叶子相似的树.md","hash":"b705d463cb1ad9bc949a287d5a60927e06170a0b","modified":1695739763569},{"_id":"source/_posts/leetcode/二叉树/894. 所有可能的满二叉树.md","hash":"6ca778b53c0d7fb269a13fa34db1c29e1275e69d","modified":1695739763569},{"_id":"source/_posts/leetcode/二叉树/889. 根据前序和后序遍历构造二叉树.md","hash":"5183379e9f94975552de248fd10a2ba9eed0cbb7","modified":1695739763569},{"_id":"source/_posts/leetcode/二叉树/919. 完全二叉树插入器.md","hash":"0068c1c1b767773149c76210912585df123b2715","modified":1695739763570},{"_id":"source/_posts/leetcode/二叉树/897. 递增顺序搜索树.md","hash":"9170049faf396205a0356c9c74115d7670a4f9cd","modified":1695739763569},{"_id":"source/_posts/leetcode/二叉树/938. 二叉搜索树的范围和.md","hash":"b15849de736669f420ca8d6b59d87ba4659664f2","modified":1695739763570},{"_id":"source/_posts/leetcode/二叉树/951. 翻转等价二叉树.md","hash":"5182dc6087e248385ecfb46ad63187d4c0529540","modified":1695739763571},{"_id":"source/_posts/leetcode/二叉树/700. 二叉搜索树中的搜索.md","hash":"a70d95df3af38f98e5073dfd6e82e46fa01f2b9c","modified":1695739763567},{"_id":"source/_posts/leetcode/二叉树/94. 二叉树的中序遍历.md","hash":"8dd06b7e71c8635abe14a82e684fcea08227e354","modified":1695739763570},{"_id":"source/_posts/leetcode/二叉树/95. 不同的二叉搜索树 II.md","hash":"ab025c27093391b0a2be884942c639c61c917b9e","modified":1695739763570},{"_id":"source/_posts/leetcode/二叉树/958. 二叉树的完全性检验.md","hash":"d06415f421bb044a093671b13c031e88d4ab34c5","modified":1695739763571},{"_id":"source/_posts/leetcode/二叉树/998. 最大二叉树 II.md","hash":"c7bcbc4a1d37f5365603759705213428f7266235","modified":1695739763572},{"_id":"source/_posts/leetcode/二叉树/98. 验证二叉搜索树.md","hash":"ad2809a910d640fb9ec30a7349f8d863af7def66","modified":1695739763571},{"_id":"source/_posts/leetcode/二叉树/993. 二叉树的堂兄弟节点.md","hash":"951cbb7fc70daf6ea47eae2623158822c7f40010","modified":1695739763572},{"_id":"source/_posts/leetcode/二叉树/99. 恢复二叉搜索树.md","hash":"c001e33c1e00eccb95f92a7624712cf03bb29b39","modified":1695739763572},{"_id":"source/_posts/leetcode/二叉树/988. 从叶结点开始的最小字符串.md","hash":"c00ddb7e1be961dbea444c2a9f07d98ea5f90b38","modified":1695739763571},{"_id":"source/_posts/leetcode/二叉树/二叉树的遍历方式.md","hash":"0103ad61d954a1c4b5e38ee69c7c20aa2017e4b1","modified":1695739763572},{"_id":"source/leetcode/动态规划/index.md","hash":"3799c3a40fb2df34bd4e8a078d4c7d9bb33c228a","modified":1697037320522},{"_id":"source/leetcode/链表/index.md","hash":"cf67aefb3ac81b70eecf363fc3d0c0c473be9e6d","modified":1697037320522},{"_id":"source/leetcode/二叉树/index.md","hash":"575d87d698fc80991dbc5e8f7dea40639d505cf8","modified":1697037320522},{"_id":"source/leetcode/面试经典150题/index.md","hash":"67d241cd13be2699fc37f8fdf94047e4519eca6b","modified":1697037320522},{"_id":"source/leetcode/算法实现/index.md","hash":"790b88bf19907251b6fa80a924720126ef8f3147","modified":1697037320522},{"_id":"public/categories/index.html","hash":"41a529023d6062b7edb3b134806055dd424b1916","modified":1696867812779},{"_id":"public/leetcode/index.html","hash":"35b03525af1c13d6ca1d0f4ca39680aa84180547","modified":1696867812779},{"_id":"public/leetcode/动态规划/index.html","hash":"ceab46b541701327c1854c79dffa9d74021fac13","modified":1696867812779},{"_id":"public/leetcode/二叉树/index.html","hash":"f0dd4d7d27237e59bced9dfc796dd48389219abe","modified":1696867812779},{"_id":"public/leetcode/链表/index.html","hash":"dccd3a05540344044f9cde2e3a84b2ce2638e34c","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/index.html","hash":"3c6b0b6b6b90795c49c32ea613e62a4d8537a63e","modified":1696867812779},{"_id":"public/leetcode/算法实现/index.html","hash":"a1614c5bceb996fc757f87da2913bac40773df89","modified":1696867812779},{"_id":"public/archives/index.html","hash":"e28c9b9d73cbfea4b7381658c7665b7286470691","modified":1696867812779},{"_id":"public/archives/2020/index.html","hash":"b37a2cd61a26c317b0d12904e90e1fd92445367a","modified":1696867812779},{"_id":"public/archives/2020/06/index.html","hash":"5a85d5f8f4c7e0f610680e404bb2ef4e0befb7df","modified":1696867812779},{"_id":"public/leetcode/动态规划/120. 三角形最小路径和.html","hash":"22e4d3c308acce9e88e82d79cf551dd608d63b3e","modified":1696867812779},{"_id":"public/leetcode/动态规划/1137. 第 N 个泰波那契数.html","hash":"d17f0919b9b43610f250c8f66d46ab0425be05d2","modified":1696867812779},{"_id":"public/leetcode/动态规划/119. 杨辉三角 II.html","hash":"af86510f02aed484957a7aeb6a795b0baddccd95","modified":1696867812779},{"_id":"public/leetcode/动态规划/322. 零钱兑换.html","hash":"4dd4fcfa85b3f1e6180248d79926827d21cbb2a4","modified":1696867812779},{"_id":"public/leetcode/动态规划/53. 最大子序和.html","hash":"e1d730c9df9317df3260fd3bb3d6a58d984f8fe0","modified":1696867812779},{"_id":"public/leetcode/动态规划/45. 跳跃游戏 II.html","hash":"2925dc4a3200f18c7a71762fbee23f425caf0d7d","modified":1696867812779},{"_id":"public/leetcode/动态规划/62. 不同路径.html","hash":"9f5bab87f07a464e3af2546913fef0bbb68d5bd6","modified":1696867812779},{"_id":"public/leetcode/动态规划/509. 斐波那契数.html","hash":"23bde5af41ad344938c6335074dbdb33aaa88af2","modified":1696867812779},{"_id":"public/leetcode/动态规划/746. 使用最小花费爬楼梯.html","hash":"6e879d1f6907addc2a38cec041afcc882f9ba054","modified":1696867812779},{"_id":"public/leetcode/动态规划/70. 爬楼梯.html","hash":"807a1116fbc8893d246d54497073cdd77005da5e","modified":1696867812779},{"_id":"public/leetcode/动态规划/931. 下降路径最小和.html","hash":"f17ce5e24aa9d17352a08f6910ac3ee3ffd23795","modified":1696867812779},{"_id":"public/leetcode/动态规划/91. 解码方法.html","hash":"ec37a6e3c7ea236349794bccfcacbb526b2ab8ed","modified":1696867812779},{"_id":"public/leetcode/动态规划/118. 杨辉三角.html","hash":"2c07ff632cb69a8f046b07a7075ef229083528dc","modified":1696867812779},{"_id":"public/leetcode/动态规划/63. 不同路径 II.html","hash":"1e56d1734f3cee0850fd4e9071a60e7a934f36ce","modified":1696867812779},{"_id":"public/leetcode/动态规划/64. 最小路径和.html","hash":"231dfde7df9e849f3233a43ac92226632eadb881","modified":1696867812779},{"_id":"public/leetcode/动态规划/剑指 Offer II 103. 最少的硬币数目.html","hash":"227f3018d2431284631e9a89158373fc419c0b78","modified":1696867812779},{"_id":"public/leetcode/链表/25.K 个一组翻转链表.html","hash":"de44e81d09a1eab883284ca49e1b088853941669","modified":1696867812779},{"_id":"public/leetcode/动态规划/55. 跳跃游戏.html","hash":"c9003e2086a716b41d9433b4d029c887ed48363f","modified":1696867812779},{"_id":"public/leetcode/动态规划/技巧.html","hash":"bc0b2b368c79d8b8e2cb9e038e9050a2ac9b9190","modified":1696867812779},{"_id":"public/leetcode/链表/234. 回文链表.html","hash":"09c314440e79eaaaab76015426056de8ae7c4470","modified":1696867812779},{"_id":"public/leetcode/链表/92.反转列表II.html","hash":"48d1b405811670d72b03068ba18e21fff2f2b018","modified":1696867812779},{"_id":"public/leetcode/链表/链表的遍历方式.html","hash":"fa11d2343f8f0f6045f46eb68923161829291697","modified":1696867812779},{"_id":"public/leetcode/二叉树/100. 相同的树.html","hash":"986fff7730c38b275b5d0f1aa4b4676b8bf084d8","modified":1696867812779},{"_id":"public/leetcode/二叉树/1008. 前序遍历构造二叉搜索树.html","hash":"367ece34ce24771ba48e87259527bf440e91edaf","modified":1696867812779},{"_id":"public/leetcode/二叉树/1026. 节点与其祖先之间的最大差值.html","hash":"530105d562adb58ab7ac371668a9202f97018c5a","modified":1696867812779},{"_id":"public/leetcode/二叉树/101. 对称二叉树.html","hash":"8de3763d1783add0509d41c5997f693446fafdda","modified":1696867812779},{"_id":"public/leetcode/二叉树/102. 二叉树的层序遍历.html","hash":"aefd921e02eed183515aef6c5916d0273b8d8cfa","modified":1696867812779},{"_id":"public/leetcode/二叉树/1022. 从根到叶的二进制数之和.html","hash":"e08ec5564306aa1b4f006aadcdc60ea6a7388101","modified":1696867812779},{"_id":"public/leetcode/二叉树/1038. 把二叉搜索树转换为累加树.html","hash":"bd4e863c09700e74a071066f0077ff200a1415b8","modified":1696867812779},{"_id":"public/leetcode/二叉树/105. 从前序与中序遍历序列构造二叉树.html","hash":"be8e70bc419bf856d1f5f98b4829da4ade62a1a2","modified":1696867812779},{"_id":"public/leetcode/二叉树/103. 二叉树的锯齿形层序遍历.html","hash":"4e4682c3922afbe9b10ad1ae0a1f4d1acc3727b1","modified":1696867812779},{"_id":"public/leetcode/二叉树/104. 二叉树的最大深度.html","hash":"c8d2d2869d3f2dc2effec852977fc24c891d9fe8","modified":1696867812779},{"_id":"public/leetcode/二叉树/106. 从中序与后序遍历序列构造二叉树.html","hash":"f3729d07358bbefaf086d66c61f185a63c64bee7","modified":1696867812779},{"_id":"public/leetcode/二叉树/1080. 根到叶路径上的不足节点.html","hash":"5cb940e587a463d44b95dad733dae6790df81d59","modified":1696867812779},{"_id":"public/leetcode/二叉树/108. 将有序数组转换为二叉搜索树.html","hash":"be0c1c7f3b88d2be5883cec49a804ea2aa4f24e8","modified":1696867812779},{"_id":"public/leetcode/二叉树/107. 二叉树的层序遍历 II.html","hash":"e45f9d9a6e2d4e7d87cad9f38193f11f8948aebd","modified":1696867812779},{"_id":"public/leetcode/二叉树/110. 平衡二叉树.html","hash":"90cb0c18c71f3cfe3b0e0dd4239553390be615f4","modified":1696867812779},{"_id":"public/leetcode/二叉树/109. 有序链表转换二叉搜索树.html","hash":"5aef277ba79eff80cb234ae42662d81a2c499bab","modified":1696867812779},{"_id":"public/leetcode/二叉树/111. 二叉树的最小深度.html","hash":"31dfc9d14a29b17667083282462ceedea8bbfa6e","modified":1696867812779},{"_id":"public/leetcode/二叉树/112. 路径总和.html","hash":"c0ac6fe977411cdb2918791ebff8c6267da92fb8","modified":1696867812779},{"_id":"public/leetcode/二叉树/1104. 二叉树寻路.html","hash":"195889e04cf87feaa356f883434ac785e174b2f8","modified":1696867812779},{"_id":"public/leetcode/二叉树/1123. 最深叶节点的最近公共祖先.html","hash":"00762db99d278335498ba6e361172fef1925ddb6","modified":1696867812779},{"_id":"public/leetcode/二叉树/1110. 删点成林.html","hash":"1db4d5e0ed9d9bfcc23aaa993bbffc533ab7f935","modified":1696867812779},{"_id":"public/leetcode/二叉树/113. 路径总和 II.html","hash":"27af9002d4d78c90ce06023c645515b344bb148f","modified":1696867812779},{"_id":"public/leetcode/二叉树/114. 二叉树展开为链表.html","hash":"df35cbf016e1b958c855fb3e5f8c637d1285b7f3","modified":1696867812779},{"_id":"public/leetcode/二叉树/1145. 二叉树着色游戏.html","hash":"bb601c335fa3d7eedf856307309a06a6e7717cb5","modified":1696867812779},{"_id":"public/leetcode/二叉树/116. 填充每个节点的下一个右侧节点指针.html","hash":"129daddd9194a64c842fceb906b8c8fcc3c14762","modified":1696867812779},{"_id":"public/leetcode/二叉树/1161. 最大层内元素和.html","hash":"5456b202279ff7c583ac1522e0910105e5bdbdf0","modified":1696867812779},{"_id":"public/leetcode/二叉树/117. 填充每个节点的下一个右侧节点指针 II.html","hash":"4f1bbe6ef39e57673c5f110884636f8e4cc3a195","modified":1696867812779},{"_id":"public/leetcode/二叉树/124. 二叉树中的最大路径和.html","hash":"520d92e9d41dc15fd0946ce070adffae21afa52b","modified":1696867812779},{"_id":"public/leetcode/二叉树/129. 求根节点到叶节点数字之和.html","hash":"75af4536f4dc7b43e0a428b553bf59ddadfe26b3","modified":1696867812779},{"_id":"public/leetcode/二叉树/1261. 在受污染的二叉树中查找元素.html","hash":"5d7849d233884258220c017d0544049ecc3c01fe","modified":1696867812779},{"_id":"public/leetcode/二叉树/1305. 两棵二叉搜索树中的所有元素.html","hash":"1b0c716ca78cbd699a7ecd76e48569f6af9aa206","modified":1696867812779},{"_id":"public/leetcode/二叉树/1315. 祖父节点值为偶数的节点和.html","hash":"f80287582d5a83557dddb5aa4f427296d3bc8f1a","modified":1696867812779},{"_id":"public/leetcode/二叉树/1302. 层数最深叶子节点的和.html","hash":"37be85e525f11893c4a300f592ff8fd60c175e46","modified":1696867812779},{"_id":"public/leetcode/二叉树/1325. 删除给定值的叶子节点.html","hash":"b2110f742a740870e33173e4bb34a8448948e1d1","modified":1696867812779},{"_id":"public/leetcode/二叉树/1339. 分裂二叉树的最大乘积.html","hash":"627606d025782c412378344c1bd7e51644a31504","modified":1696867812779},{"_id":"public/leetcode/二叉树/1367. 二叉树中的列表.html","hash":"f9aa46a7bf046caff0a263f1b007bb9a8c81d252","modified":1696867812779},{"_id":"public/leetcode/二叉树/1361. 验证二叉树.html","hash":"bcd03e6883783442231aaa0bc92a48ced144d22a","modified":1696867812779},{"_id":"public/leetcode/二叉树/1376. 通知所有员工所需的时间.html","hash":"b9cd49687ab247b98c17fee2e911e0907f34e206","modified":1696867812779},{"_id":"public/leetcode/二叉树/1379. 找出克隆二叉树中的相同节点.html","hash":"2b543f1f3b3ba9dc28ca6b6c0cff785203979bfa","modified":1696867812779},{"_id":"public/leetcode/二叉树/1382. 将二叉搜索树变平衡.html","hash":"9223931ed981a39897e1ae171cfe18fa5f67ce99","modified":1696867812779},{"_id":"public/leetcode/二叉树/144. 二叉树的前序遍历.html","hash":"dbbf0dd8d18c5a9a22bba3ff0b7de1c3d75b49cb","modified":1696867812779},{"_id":"public/leetcode/二叉树/1448. 统计二叉树中好节点的数目.html","hash":"bde588706267d61c35505d2d342f9c34125d6194","modified":1696867812779},{"_id":"public/leetcode/二叉树/145. 二叉树的后序遍历.html","hash":"104e4e5b7eda721bc865a666cc6bae1be008127a","modified":1696867812779},{"_id":"public/leetcode/二叉树/173. 二叉搜索树迭代器.html","hash":"0331bc4c794b1ad8e1d51ce12e61c86beb7fef84","modified":1696867812779},{"_id":"public/leetcode/二叉树/199. 二叉树的右视图.html","hash":"e4e0a43dae462930b6df26406f124925101b317b","modified":1696867812779},{"_id":"public/leetcode/二叉树/230. 二叉搜索树中第K小的元素.html","hash":"16028567805c35d8a60eec4ec06919d4f38aef97","modified":1696867812779},{"_id":"public/leetcode/二叉树/226.翻转二叉树.html","hash":"e40060746790181a947a419d4b1debc6c3bdc0f7","modified":1696867812779},{"_id":"public/leetcode/二叉树/235. 二叉搜索树的最近公共祖先.html","hash":"70915e7e413f9f5ea8cb3d347d5b044b3812e6b7","modified":1696867812779},{"_id":"public/leetcode/二叉树/1457. 二叉树中的伪回文路径.html","hash":"d3ed1ba591d6e20994a49e33627308bc099f0740","modified":1696867812779},{"_id":"public/leetcode/二叉树/236. 二叉树的最近公共祖先.html","hash":"a419a784918adfd4ce7c7c6f8f2585cd38e64d83","modified":1696867812779},{"_id":"public/leetcode/二叉树/257. 二叉树的所有路径.html","hash":"c4ff120e7c4a2f2e2b38487bf4ba8fefbed0ed6c","modified":1696867812779},{"_id":"public/leetcode/二叉树/331. 验证二叉树的前序序列化.html","hash":"7e2f667580f8d2375e1956657fac1ad875443a62","modified":1696867812779},{"_id":"public/leetcode/二叉树/337. 打家劫舍 III.html","hash":"c7c36caec7f384f547e4ee5032485f885f31bea1","modified":1696867812779},{"_id":"public/leetcode/二叉树/297. 二叉树的序列化与反序列化.html","hash":"cc46696502e079158f4b300ab2b6eb8906d204b7","modified":1696867812779},{"_id":"public/leetcode/二叉树/429. N 叉树的层序遍历.html","hash":"70e9c01fea1c60dd9bc5b4abe6e5fc4d27ad302e","modified":1696867812779},{"_id":"public/leetcode/二叉树/404. 左叶子之和.html","hash":"1c6ffc33be4fbee1aa81b60c8fa4f46b7df0902a","modified":1696867812779},{"_id":"public/leetcode/二叉树/341. 扁平化嵌套列表迭代器.html","hash":"8ff30d2a9e25eee8f3450bf6d6693c5e61495856","modified":1696867812779},{"_id":"public/leetcode/二叉树/449. 序列化和反序列化二叉搜索树.html","hash":"868874e1994b1b3744793e4eb0404d57278a45ff","modified":1696867812779},{"_id":"public/leetcode/二叉树/437. 路径总和 III.html","hash":"0e17b1b77bcb92311deb88bf8f3c8882b0e09b17","modified":1696867812779},{"_id":"public/leetcode/二叉树/501. 二叉搜索树中的众数.html","hash":"830e8d5dd9505b2410b3035115de84e75cb1cc64","modified":1696867812779},{"_id":"public/leetcode/二叉树/508. 出现次数最多的子树元素和.html","hash":"7184411b995d9062fb0d65ba12700876a13feba0","modified":1696867812779},{"_id":"public/leetcode/二叉树/538. 把二叉搜索树转换为累加树.html","hash":"42e091d6138d7971715a520c3a7ba57bbfe107cf","modified":1696867812779},{"_id":"public/leetcode/二叉树/513. 找树左下角的值.html","hash":"4fa76bbc2a1ab011618f3338c205725911a883f9","modified":1696867812779},{"_id":"public/leetcode/二叉树/530. 二叉搜索树的最小绝对差.html","hash":"9dc06a214fa4899500d3fdbde8d7a3922124b545","modified":1696867812779},{"_id":"public/leetcode/二叉树/515. 在每个树行中找最大值.html","hash":"985a17070f630c4b1a4cc925be94a46abb39ec74","modified":1696867812779},{"_id":"public/leetcode/二叉树/559. N 叉树的最大深度.html","hash":"e18bb1f789c8693af715fae226abe110aa53146d","modified":1696867812779},{"_id":"public/leetcode/二叉树/563. 二叉树的坡度.html","hash":"6814096fd5c5b1ce6290283c4e6a4599a23e151e","modified":1696867812779},{"_id":"public/leetcode/二叉树/450. 删除二叉搜索树中的节点.html","hash":"40a106ec5026d38d9f9ee5183ea46cd74bbc49e7","modified":1696867812779},{"_id":"public/leetcode/二叉树/572. 另一个树的子树.html","hash":"878523c23e9b7bf3663735e460fb7d3b34e8bde1","modified":1696867812779},{"_id":"public/leetcode/二叉树/543. 二叉树的直径.html","hash":"a498e2ee51ead5b884d11d7e2f61542096ce74ce","modified":1696867812779},{"_id":"public/leetcode/二叉树/617. 合并二叉树.html","hash":"ac19e622409c4780c6162ce939741324f8bd54b1","modified":1696867812779},{"_id":"public/leetcode/二叉树/606. 根据二叉树创建字符串.html","hash":"f9b62b285c84c886aa198d1dcf9c11681f58327a","modified":1696867812779},{"_id":"public/leetcode/二叉树/589. N 叉树的前序遍历.html","hash":"c14fca2bd7bacc6dbef470173d5fa7ec7c58d2c7","modified":1696867812779},{"_id":"public/leetcode/二叉树/623. 在二叉树中增加一行.html","hash":"9855453e3cf02e6dcf17e65b25c29d616312a0d8","modified":1696867812779},{"_id":"public/leetcode/二叉树/652. 寻找重复的子树.html","hash":"39b4ab7215d2bd5864285f5f752292717f718042","modified":1696867812779},{"_id":"public/leetcode/二叉树/590. N 叉树的后序遍历.html","hash":"28177d4f884ad20f395c38660e6184d34ce6098f","modified":1696867812779},{"_id":"public/leetcode/二叉树/654.最大二叉树.html","hash":"6e4de299805263dc78410ae81b8a6578e6b2b85c","modified":1696867812779},{"_id":"public/leetcode/二叉树/637. 二叉树的层平均值.html","hash":"94f20cd9e523ed82ae821d884da5adf5b6dedaf4","modified":1696867812779},{"_id":"public/leetcode/二叉树/662. 二叉树最大宽度.html","hash":"1f2c1b448a8ce69175fbcd6f7a49784c69c7064b","modified":1696867812779},{"_id":"public/leetcode/二叉树/653. 两数之和 IV - 输入 BST.html","hash":"f9c30a81d8e03baeaf705339e8627ff05346a3b9","modified":1696867812779},{"_id":"public/leetcode/二叉树/655. 输出二叉树.html","hash":"7344158eae6e7579450196b8a39c074eb81242db","modified":1696867812779},{"_id":"public/leetcode/二叉树/685. 冗余连接 II.html","hash":"9bfe0bd308ffd289f336b2860fca3a48b747a7e5","modified":1696867812779},{"_id":"public/leetcode/二叉树/669. 修剪二叉搜索树.html","hash":"b9ae9a5947224aa29d79a56f61175dca9dfe3c03","modified":1696867812779},{"_id":"public/leetcode/二叉树/684. 冗余连接.html","hash":"2560d0be53c305ca25730ec21fda05a17fe6730b","modified":1696867812779},{"_id":"public/leetcode/二叉树/687. 最长同值路径.html","hash":"06c1b8910eaa65617f0873c3bdd4c4de923c48a6","modified":1696867812779},{"_id":"public/leetcode/二叉树/671. 二叉树中第二小的节点.html","hash":"4f7ed38e593cf5cb0cc3ac732a8059fd2c89151e","modified":1696867812779},{"_id":"public/leetcode/二叉树/701. 二叉搜索树中的插入操作.html","hash":"c9f990e20c2e99f4f2a996d16cf126ac334e67d8","modified":1696867812779},{"_id":"public/leetcode/二叉树/814. 二叉树剪枝.html","hash":"d4760fe8d45e8f2f3d8dd30c5b3f5d55c2c17249","modified":1696867812779},{"_id":"public/leetcode/二叉树/703. 数据流中的第 K 大元素.html","hash":"232924834c4c2152ebac4b482729e5afc510f3eb","modified":1696867812779},{"_id":"public/leetcode/二叉树/863. 二叉树中所有距离为 K 的结点.html","hash":"ab53c3c14b0f183e308c09f67263a00473234bb2","modified":1696867812779},{"_id":"public/leetcode/二叉树/889. 根据前序和后序遍历构造二叉树.html","hash":"203463a37ccc01457b17e11e45a12e613c8d036b","modified":1696867812779},{"_id":"public/leetcode/二叉树/700. 二叉搜索树中的搜索.html","hash":"a3b6b5384b34cdccd7363ec525018f1a1e154b7a","modified":1696867812779},{"_id":"public/leetcode/二叉树/872. 叶子相似的树.html","hash":"9d0b285d6de22f2c07f090c280c451ab3de39ad2","modified":1696867812779},{"_id":"public/leetcode/二叉树/865. 具有所有最深节点的最小子树.html","hash":"ca4aef3687935fe04f7bba78acb40115ba1ed864","modified":1696867812779},{"_id":"public/leetcode/二叉树/94. 二叉树的中序遍历.html","hash":"00a82a089c32f7299f88b4f293e69b81de7038b9","modified":1696867812779},{"_id":"public/leetcode/二叉树/919. 完全二叉树插入器.html","hash":"99fb017a09f7c4a8c6c7f2fb947334f5eb4081ac","modified":1696867812779},{"_id":"public/leetcode/二叉树/894. 所有可能的满二叉树.html","hash":"69403a3dd3c43259dd7d7a8fbe9f229128115e3a","modified":1696867812779},{"_id":"public/leetcode/二叉树/938. 二叉搜索树的范围和.html","hash":"78a7544ae8884f73218f055ae80683b07e31c466","modified":1696867812779},{"_id":"public/leetcode/二叉树/98. 验证二叉搜索树.html","hash":"7da9485e5cdac9f099e8dca608293322db0c2b93","modified":1696867812779},{"_id":"public/leetcode/二叉树/951. 翻转等价二叉树.html","hash":"53bb9a6cf16feb00b74f3551a4526015c6e34ced","modified":1696867812779},{"_id":"public/leetcode/二叉树/958. 二叉树的完全性检验.html","hash":"6db3fa2367802e111d0e5109a4868575b3daa906","modified":1696867812779},{"_id":"public/leetcode/二叉树/988. 从叶结点开始的最小字符串.html","hash":"b1985560272c4eb4f87845d1dfbe691516ead8ad","modified":1696867812779},{"_id":"public/leetcode/二叉树/897. 递增顺序搜索树.html","hash":"ece1d81c93d73f601a73cd398a8f4d1852da4e0c","modified":1696867812779},{"_id":"public/leetcode/二叉树/95. 不同的二叉搜索树 II.html","hash":"e5e37c129c41240b481ffbf7bd1d6c6a41250d7d","modified":1696867812779},{"_id":"public/leetcode/二叉树/993. 二叉树的堂兄弟节点.html","hash":"d4219f16a109d77a5f532d914f3cd69ddb9da7ad","modified":1696867812779},{"_id":"public/leetcode/二叉树/99. 恢复二叉搜索树.html","hash":"89c53c9ebb68464d6ad8f4203cb0b3b58a965deb","modified":1696867812779},{"_id":"public/leetcode/二叉树/二叉树的遍历方式.html","hash":"65a726412859334aeb0534c97f27b1dfb170c21c","modified":1696867812779},{"_id":"public/leetcode/二叉树/998. 最大二叉树 II.html","hash":"ecab72e20ab356fef6603bb80bb448ce66079248","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/ 13. 罗马数字转整数.html","hash":"d0aeaa4b85b34f4a8f5bdd0daf1732c20db13057","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/12. 整数转罗马数字.html","hash":"4973de513e44d85015ae7c4eb9116b8282a43454","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/121. 买卖股票的最佳时机.html","hash":"cf71d7b4a8060288c007f2e5a63c436c0f351128","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/134. 加油站.html","hash":"a6d7b86b7a7602121871466c6c9afa21d8684f19","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/14. 最长公共前缀.html","hash":"e172cbb6457883d99151a7ecc18fcb17d66e96ab","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/151. 反转字符串中的单词.html","hash":"e801b4abde34381cea6cb041a8966f915bdf6058","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/26. 删除有序数组中的重复项.html","hash":"f81f44befbbb3547ecb663800e5f34997bb37e11","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/169. 多数元素.html","hash":"fd8fe9b358dca76c0184524461458274e6754b33","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/55. 跳跃游戏.html","hash":"3ee0738b0fd040d42c468eabe731014f32e97269","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/189. 轮转数组.html","hash":"953afc66d7336428adcf165255d86aa737b248fd","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/27. 移除元素.html","hash":"7dd7eac4da37479e5dd5f589b0d5879713e0f9c3","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/45. 跳跃游戏 II.html","hash":"46a15d4e02af27aea7518d1c2e9ea01a5e8260d4","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/58. 最后一个单词的长度.html","hash":"8be104483a1d9957321d888bc6d785f2371ded72","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/88. 合并两个有序数组.html","hash":"bcc796263921b7716151c29e687a8fabab2b611f","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/380. O(1) 时间插入、删除和获取随机元素.html","hash":"5b4621fd8723046dadcf21d4d23304fbc70258f7","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/122. 买卖股票的最佳时机 II.html","hash":"f717951aa39cfcfd7640b6b91f2ef4fe8b8a60f5","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/6. N 字形变换.html","hash":"4400120d3811a0ff19b2a319d94ec68c92ac0a65","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/80. 删除有序数组中的重复项 II.html","hash":"7bcc62625e763fafeed57a8fa381fa807077355d","modified":1696867812779},{"_id":"public/2020/06/29/socketio实现服务器推送（demo实现一个聊天室）/index.html","hash":"4b353348030449e93aa9130937db8544029f3adf","modified":1696867812779},{"_id":"public/index.html","hash":"ecd112203891eb6dc5fb414444e7052dd725c315","modified":1696867812779},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1695867533120},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1695867533120},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1695867533120},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1695867533120},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1695867533120},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1695867533120},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1695867533120},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1695867533120},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1695867533120},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1695867533120},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1695867533120},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1695867533120},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1695867533120},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1695867533120},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1695867533120},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1695867533120},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1695867533120},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1695867533120},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1695867533120},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1695867533120},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1695867533120},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1695867533120},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1695867533120},{"_id":"public/css/style.css","hash":"5673af1e8e0b02135e5a5ae176fc47916ba2cd12","modified":1695867533120},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1695867533120},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1695867533120},{"_id":"public/css/index.css","hash":"c0627de1627d1d97d15a5fbd8c6312126ef28c07","modified":1695867533120},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1695867533120},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1695867533120},{"_id":"public/leetcode/算法实现/LRU.ts","hash":"c68c6130c43ad92b6207bf86fe4d8d843236bfaf","modified":1695867533120},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1695867533120},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1695867533120},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1695867533120},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1695867533120},{"_id":"source/leetcode/面试经典150题/392. 判断子序列.md","hash":"a1d4f0697025c3abffcece7fcd0ddc654b903638","modified":1696865510204},{"_id":"source/leetcode/面试经典150题/125. 验证回文串.md","hash":"a6ea83966db41275ee9226d17b059383cbce6d21","modified":1696658750675},{"_id":"public/leetcode/面试经典150题/392. 判断子序列.html","hash":"2a53570eb3eb802d1f7d8d1fe7b729996311b093","modified":1696867812779},{"_id":"public/leetcode/面试经典150题/125. 验证回文串.html","hash":"9bf297973b0fe0fd80af6d311f31706fef612948","modified":1696867812779},{"_id":"source/leetcode/index.js","hash":"51fdb48ab8d00596931731f0024936fd02182a42","modified":1697037038225},{"_id":"source/leetcode/动态规划/1137.第N个泰波那契数.md","hash":"48f2e5c1e5d0dfda1a8c26913bcf7537d46b6d32","modified":1695739763527},{"_id":"source/leetcode/动态规划/118.杨辉三角.md","hash":"b2d751499507741a27b8a77e899f80123aa77b18","modified":1695739763528},{"_id":"source/leetcode/动态规划/119.杨辉三角II.md","hash":"50a9a86094a9af77264520ec5cb94758fda8aed7","modified":1695739763529},{"_id":"source/leetcode/动态规划/120.三角形最小路径和.md","hash":"1227bd5c86dfc3cab40f2d855f291b36d3ea3f2a","modified":1695739763529},{"_id":"source/leetcode/动态规划/322.零钱兑换.md","hash":"57f1827470f75cc0fa614826bcbff9068edc64d0","modified":1695739763530},{"_id":"source/leetcode/动态规划/509.斐波那契数.md","hash":"50453559487b9b9491dce7a91362e84aa17e8314","modified":1695739763530},{"_id":"source/leetcode/动态规划/53.最大子序和.md","hash":"473a90cafa25cb9aa49291051bd8f83f4ae7cfbc","modified":1695739763531},{"_id":"source/leetcode/动态规划/55.跳跃游戏.md","hash":"c517fca64416f0a2c9819a36ba7649a109103f30","modified":1695739763531},{"_id":"source/leetcode/动态规划/62.不同路径.md","hash":"85de1a58c30c562128c05fdf515276eae0929351","modified":1695739763531},{"_id":"source/leetcode/动态规划/63.不同路径II.md","hash":"efffe9ff0d2b2486046a9001ea6d3d8911f13fe2","modified":1695739763532},{"_id":"source/leetcode/动态规划/64.最小路径和.md","hash":"5bdf95333fa3ce53208889227a7e04075e2eba03","modified":1695739763532},{"_id":"source/leetcode/动态规划/70.爬楼梯.md","hash":"f620a39ff41cfdaaa2af6f67880a024c81ba5109","modified":1695739763532},{"_id":"source/leetcode/动态规划/746.使用最小花费爬楼梯.md","hash":"12194d06d05184a9bbd7a1e489bfd322888bd490","modified":1695739763533},{"_id":"source/leetcode/动态规划/91.解码方法.md","hash":"1737b85583679a6fa85279cc7bdd9869995fdb51","modified":1695739763533},{"_id":"source/leetcode/动态规划/45.跳跃游戏II.md","hash":"3f8cdd4346d76a482ab8c5033901470319ac08df","modified":1695740538473},{"_id":"source/leetcode/动态规划/931.下降路径最小和.md","hash":"f405a3c4fb05c7e9c31dc6854f08c679cc0f35fa","modified":1695739763533},{"_id":"source/leetcode/动态规划/剑指OfferII103.最少的硬币数目.md","hash":"fbd8f55b49815e8c6a432da0491fb335b8abe811","modified":1695739763534},{"_id":"source/leetcode/二叉树/100.相同的树.md","hash":"3ad24ac76afebec959ce6a378a55093aee4b0fef","modified":1695739763543},{"_id":"source/leetcode/二叉树/101.对称二叉树.md","hash":"1a19b610b29f0e7ef49fb43c255070c5d22afad5","modified":1695739763544},{"_id":"source/leetcode/二叉树/1008.前序遍历构造二叉搜索树.md","hash":"261bccbe1fb0f994300428597dfbffe217e9a84e","modified":1695739763543},{"_id":"source/leetcode/二叉树/102.二叉树的层序遍历.md","hash":"7502e97d2613746dceef156d24ea5082b6e18f14","modified":1695739763544},{"_id":"source/leetcode/二叉树/1022.从根到叶的二进制数之和.md","hash":"1d4085f1eaf513e99c4d9bfeea7d426831623772","modified":1695739763545},{"_id":"source/leetcode/二叉树/1026.节点与其祖先之间的最大差值.md","hash":"da31e0952addc16af264e033a4f23f993c5abf94","modified":1695739763545},{"_id":"source/leetcode/二叉树/104.二叉树的最大深度.md","hash":"b2e97af1088ca84a56da059f1295f2dd48e9623b","modified":1695739763546},{"_id":"source/leetcode/二叉树/1038.把二叉搜索树转换为累加树.md","hash":"3b3ba17acf7ade43344c76fcb1e63d5bfa26357b","modified":1695739763546},{"_id":"source/leetcode/二叉树/103.二叉树的锯齿形层序遍历.md","hash":"b191c56e29bdcba0e8f3c7e8a721bc39908eb776","modified":1695739763546},{"_id":"source/leetcode/二叉树/106.从中序与后序遍历序列构造二叉树.md","hash":"9651e5aa8a749fc39a9cc8c21c68a52d15a6e91e","modified":1695739763547},{"_id":"source/leetcode/二叉树/105.从前序与中序遍历序列构造二叉树.md","hash":"98208cfadf0fc9b09fa12754619b0ea4ec609829","modified":1695739763546},{"_id":"source/leetcode/二叉树/107.二叉树的层序遍历II.md","hash":"707767369c3ec9bee7f381b2e800acceb2e2ae13","modified":1695739763547},{"_id":"source/leetcode/二叉树/108.将有序数组转换为二叉搜索树.md","hash":"78c4975356589f3d0eb8bb3c7b9f1ed1c573b85a","modified":1695739763547},{"_id":"source/leetcode/二叉树/109.有序链表转换二叉搜索树.md","hash":"ba7f07032e6e5daa30fc861f01f514add8f9ec97","modified":1695739763548},{"_id":"source/leetcode/二叉树/110.平衡二叉树.md","hash":"4e155bd8891e0295ffc38511d23dc62293a1fd07","modified":1695739763548},{"_id":"source/leetcode/二叉树/1080.根到叶路径上的不足节点.md","hash":"b4ad6d09ae65676ad405c342ce6151c8d5388295","modified":1695739763547},{"_id":"source/leetcode/二叉树/111.二叉树的最小深度.md","hash":"519763d8250c8b543554a7f04203f862078b17f4","modified":1695739763548},{"_id":"source/leetcode/二叉树/1104.二叉树寻路.md","hash":"1b12e7af86fe9369c35ba670414eef20418b0291","modified":1695739763548},{"_id":"source/leetcode/二叉树/112.路径总和.md","hash":"57359ecc909b62eee36c6e856ce34b81faeb57a2","modified":1695739763549},{"_id":"source/leetcode/二叉树/1110.删点成林.md","hash":"f0ac1303e1ec100a29527f2947e2b48501132be0","modified":1695739763549},{"_id":"source/leetcode/二叉树/1123.最深叶节点的最近公共祖先.md","hash":"4058babe56ad4df6bf47f7edca448001936d0433","modified":1695739763549},{"_id":"source/leetcode/二叉树/113.路径总和II.md","hash":"269d719bade38f40438471abd529723676c70e8e","modified":1695739763549},{"_id":"source/leetcode/二叉树/1145.二叉树着色游戏.md","hash":"1b8870d3200543e965831b71fe5d5cf28fb17118","modified":1695739763550},{"_id":"source/leetcode/二叉树/114.二叉树展开为链表.md","hash":"79d44e4d99f0242be4256c52d81191d066649def","modified":1695739763550},{"_id":"source/leetcode/二叉树/1161.最大层内元素和.md","hash":"bdf28cf459f180a1e7b6c4693b9d37acf8529183","modified":1695739763551},{"_id":"source/leetcode/二叉树/116.填充每个节点的下一个右侧节点指针.md","hash":"1625f14dd46a49161d74caa7adc2b0d2050b90d5","modified":1695739763550},{"_id":"source/leetcode/二叉树/117.填充每个节点的下一个右侧节点指针II.md","hash":"d10bfae6c0d95494aeef2f841795e3d6397343fc","modified":1695739763551},{"_id":"source/leetcode/二叉树/129.求根节点到叶节点数字之和.md","hash":"1b9e6772c1b218c0b1224065b8d4ba1901c5b9c5","modified":1695739763552},{"_id":"source/leetcode/二叉树/1302.层数最深叶子节点的和.md","hash":"1046d9d93fa5c023cce073aa566ed98a50d99397","modified":1695739763552},{"_id":"source/leetcode/二叉树/124.二叉树中的最大路径和.md","hash":"e82836a4f9e13607d116a20b9d6f5d4dbd6903ec","modified":1695739763551},{"_id":"source/leetcode/二叉树/1315.祖父节点值为偶数的节点和.md","hash":"82666eb9765cbdcf37e3dbb3542c3d0f40b5decc","modified":1695739763553},{"_id":"source/leetcode/二叉树/1305.两棵二叉搜索树中的所有元素.md","hash":"5e3ef0017061eaf5cd48fed4d74da8f30c02c40a","modified":1695739763553},{"_id":"source/leetcode/二叉树/1261.在受污染的二叉树中查找元素.md","hash":"8c186649472f1c13429acc89575f114820a4a1f0","modified":1695739763552},{"_id":"source/leetcode/二叉树/1325.删除给定值的叶子节点.md","hash":"011de5431aa096023f11e4889195bd8a90c4914e","modified":1695739763553},{"_id":"source/leetcode/二叉树/1361.验证二叉树.md","hash":"82080f2fe71f4a78d1dd389dce01836530b7c572","modified":1695739763554},{"_id":"source/leetcode/二叉树/1339.分裂二叉树的最大乘积.md","hash":"4ea2f47c1678194724b155e70dc760d306cd17ac","modified":1695739763554},{"_id":"source/leetcode/二叉树/1376.通知所有员工所需的时间.md","hash":"034f23657b6c34ffa1fab87fbbe1e3935fd9c75a","modified":1695739763554},{"_id":"source/leetcode/二叉树/1367.二叉树中的列表.md","hash":"ea31ea15035e96c0a5280492bf7712fc2c83662a","modified":1695739763554},{"_id":"source/leetcode/二叉树/1379.找出克隆二叉树中的相同节点.md","hash":"f17f4a5755ca3f14170d94f915b9e1a58fe884ac","modified":1695739763555},{"_id":"source/leetcode/二叉树/1382.将二叉搜索树变平衡.md","hash":"c69afcaa3b0b79b6223372292caa4a789a2fa4ff","modified":1695739763555},{"_id":"source/leetcode/二叉树/145.二叉树的后序遍历.md","hash":"f8cb160298eac6ec2be48e50418112362627f8aa","modified":1695739763555},{"_id":"source/leetcode/二叉树/1448.统计二叉树中好节点的数目.md","hash":"97d942fdf630ce1383d923405c63503cd3dace81","modified":1695739763555},{"_id":"source/leetcode/二叉树/144.二叉树的前序遍历.md","hash":"0196fd81e46592f1ef086161a928d3d254a514d1","modified":1695739763555},{"_id":"source/leetcode/二叉树/1457.二叉树中的伪回文路径.md","hash":"0dfd5d44f3d1c818492fd06d7e73493d0fc5be6b","modified":1695739763556},{"_id":"source/leetcode/二叉树/173.二叉搜索树迭代器.md","hash":"02e5bd0bfa9cd477e95ca8a34adbb732be1b3b94","modified":1695739763556},{"_id":"source/leetcode/二叉树/199.二叉树的右视图.md","hash":"43ab8a04f667c9d7f41812fa95c77c91b027008e","modified":1695739763556},{"_id":"source/leetcode/二叉树/230.二叉搜索树中第K小的元素.md","hash":"6073a6be79887ee99adc0a272dea64fac1c85f35","modified":1695739763557},{"_id":"source/leetcode/二叉树/236.二叉树的最近公共祖先.md","hash":"e7fef7c94db1094c886bacc71e2ecb4e24824b6a","modified":1695739763558},{"_id":"source/leetcode/二叉树/257.二叉树的所有路径.md","hash":"c22fc6e2874df087005725d87b4f7815ca1389f4","modified":1695739763558},{"_id":"source/leetcode/二叉树/235.二叉搜索树的最近公共祖先.md","hash":"a43c7bd91961ab9961e3087477d1459ba90afbc8","modified":1695739763557},{"_id":"source/leetcode/二叉树/297.二叉树的序列化与反序列化.md","hash":"bad174aaeace892d1d23b6c56390774e05aaae76","modified":1695739763558},{"_id":"source/leetcode/二叉树/341.扁平化嵌套列表迭代器.md","hash":"16a697667cdbddf0845eb23907d3a42e57148fc9","modified":1695739763559},{"_id":"source/leetcode/二叉树/337.打家劫舍III.md","hash":"40b794c86752b2e7d826a08860c202538b75f2ca","modified":1695739763559},{"_id":"source/leetcode/二叉树/331.验证二叉树的前序序列化.md","hash":"40ec00c36eff8c74bd00dc9b1ed919795cc5bf22","modified":1695739763559},{"_id":"source/leetcode/二叉树/404.左叶子之和.md","hash":"7978fd70a36e39555df789e9157d406b0d51d1ff","modified":1695739763559},{"_id":"source/leetcode/二叉树/449.序列化和反序列化二叉搜索树.md","hash":"1faa929252fb811206313cc0de01126b986b705e","modified":1695739763560},{"_id":"source/leetcode/二叉树/429.N叉树的层序遍历.md","hash":"f6de96829aa851ef08f2d817d75b2795ad3fe080","modified":1695739763560},{"_id":"source/leetcode/二叉树/437.路径总和III.md","hash":"60e99ab25a6de19ebb2dcbd84f76957f659d6110","modified":1695739763560},{"_id":"source/leetcode/二叉树/450.删除二叉搜索树中的节点.md","hash":"2487370091a9b2c7240a655f9c02b8f50cdfec3e","modified":1695739763560},{"_id":"source/leetcode/二叉树/501.二叉搜索树中的众数.md","hash":"ca4e9d2c11b5d8cb13e6cee0a22e59d55a4ac4da","modified":1695739763561},{"_id":"source/leetcode/二叉树/508.出现次数最多的子树元素和.md","hash":"4c0ddbde59753cc82304d1adb4df026697e9d099","modified":1695739763561},{"_id":"source/leetcode/二叉树/513.找树左下角的值.md","hash":"5ab7d317994c419163663692dd41d8e4698630bc","modified":1695739763561},{"_id":"source/leetcode/二叉树/515.在每个树行中找最大值.md","hash":"5832704de2f83c34acc5c3d14505e9e1d3b72906","modified":1695739763561},{"_id":"source/leetcode/二叉树/559.N叉树的最大深度.md","hash":"266d8dce5ea8109786300157de8f8c6cb79eb129","modified":1695739763562},{"_id":"source/leetcode/二叉树/530.二叉搜索树的最小绝对差.md","hash":"9c0f2da3ae7795193ffb8e3c1b756abae0e91708","modified":1695739763562},{"_id":"source/leetcode/二叉树/538.把二叉搜索树转换为累加树.md","hash":"a1e73158229a5a1dafecf9122f997af5ccb9e840","modified":1695739763562},{"_id":"source/leetcode/二叉树/543.二叉树的直径.md","hash":"a7d39a2d509fa1a7ff86c0f417a358a930f4519b","modified":1695739763562},{"_id":"source/leetcode/二叉树/589.N叉树的前序遍历.md","hash":"22b5e74db457d207b98a0cfb8359264731ee1d08","modified":1695739763563},{"_id":"source/leetcode/二叉树/563.二叉树的坡度.md","hash":"afa05583f0fce78602e2e240cbfaaa661e515ac4","modified":1695739763563},{"_id":"source/leetcode/二叉树/572.另一个树的子树.md","hash":"4d954d506cf141d87b540426acbb9239fa2dc88a","modified":1695739763563},{"_id":"source/leetcode/二叉树/590.N叉树的后序遍历.md","hash":"6386ed3654edab4c666c21a8e207244746b750d2","modified":1695739763563},{"_id":"source/leetcode/二叉树/617.合并二叉树.md","hash":"b1b3a9e22d27328252aa26d54650aeb5b1dd7572","modified":1695739763564},{"_id":"source/leetcode/二叉树/623.在二叉树中增加一行.md","hash":"b1fb5c31a0c62bc48eb9d1d0b5466230510eecee","modified":1695739763564},{"_id":"source/leetcode/二叉树/606.根据二叉树创建字符串.md","hash":"141e1dbdadc6c704b80c89bf18d2b6962f1568c5","modified":1695739763563},{"_id":"source/leetcode/二叉树/637.二叉树的层平均值.md","hash":"eb742da3dc79a5a3d1ca4e9f934321f203f09c7b","modified":1695739763565},{"_id":"source/leetcode/二叉树/653.两数之和IV-输入BST.md","hash":"d14f8a4879a9998ab2715bb11e0632dc0efeb3c9","modified":1695739763565},{"_id":"source/leetcode/二叉树/655.输出二叉树.md","hash":"7128f50335a0a131deee01f1fa9d901e8535fa09","modified":1695739763566},{"_id":"source/leetcode/二叉树/652.寻找重复的子树.md","hash":"9eb2561ab87a38c1b5467f11240ab33556161011","modified":1695739763565},{"_id":"source/leetcode/二叉树/662.二叉树最大宽度.md","hash":"151ee18c8942364326e00365523de259b7f3ba36","modified":1695739763566},{"_id":"source/leetcode/二叉树/669.修剪二叉搜索树.md","hash":"f2f3a28769dc6a30c5b01b2af21ad1cdcc1e07c8","modified":1695739763566},{"_id":"source/leetcode/二叉树/684.冗余连接.md","hash":"57950f1108382576136535b03c66cc06d2124ed9","modified":1695739763567},{"_id":"source/leetcode/二叉树/671.二叉树中第二小的节点.md","hash":"da4fa1c6664816589e06de465d2641381988cdb6","modified":1695739763567},{"_id":"source/leetcode/二叉树/685.冗余连接II.md","hash":"7d3712aae4e4ed8e6a0d240426f5b181c815ce3a","modified":1695739763567},{"_id":"source/leetcode/二叉树/687.最长同值路径.md","hash":"eadaaf587f21eda69ce9adada4a6bee48057e9cf","modified":1695739763567},{"_id":"source/leetcode/二叉树/701.二叉搜索树中的插入操作.md","hash":"027d57ac949331efb4ec9205706fbff7179827ab","modified":1695739763568},{"_id":"source/leetcode/二叉树/700.二叉搜索树中的搜索.md","hash":"a70d95df3af38f98e5073dfd6e82e46fa01f2b9c","modified":1695739763567},{"_id":"source/leetcode/二叉树/814.二叉树剪枝.md","hash":"fd6b63cdb53432d3a8ebc844de2904510abbf56e","modified":1695739763568},{"_id":"source/leetcode/二叉树/863.二叉树中所有距离为K的结点.md","hash":"c6ff145c2fec3c43ba3c44b44fed831d795bfe47","modified":1695739763568},{"_id":"source/leetcode/二叉树/703.数据流中的第K大元素.md","hash":"a1beecf4547148023b1b7e698dd317ae042a32b8","modified":1695739763568},{"_id":"source/leetcode/二叉树/865.具有所有最深节点的最小子树.md","hash":"f37a3a379e01b7d1650708872449f9d84f752446","modified":1695739763569},{"_id":"source/leetcode/二叉树/889.根据前序和后序遍历构造二叉树.md","hash":"5183379e9f94975552de248fd10a2ba9eed0cbb7","modified":1695739763569},{"_id":"source/leetcode/二叉树/872.叶子相似的树.md","hash":"b705d463cb1ad9bc949a287d5a60927e06170a0b","modified":1695739763569},{"_id":"source/leetcode/二叉树/897.递增顺序搜索树.md","hash":"9170049faf396205a0356c9c74115d7670a4f9cd","modified":1695739763569},{"_id":"source/leetcode/二叉树/894.所有可能的满二叉树.md","hash":"6ca778b53c0d7fb269a13fa34db1c29e1275e69d","modified":1695739763569},{"_id":"source/leetcode/二叉树/919.完全二叉树插入器.md","hash":"0068c1c1b767773149c76210912585df123b2715","modified":1695739763570},{"_id":"source/leetcode/二叉树/938.二叉搜索树的范围和.md","hash":"b15849de736669f420ca8d6b59d87ba4659664f2","modified":1695739763570},{"_id":"source/leetcode/二叉树/94.二叉树的中序遍历.md","hash":"8dd06b7e71c8635abe14a82e684fcea08227e354","modified":1695739763570},{"_id":"source/leetcode/二叉树/951.翻转等价二叉树.md","hash":"5182dc6087e248385ecfb46ad63187d4c0529540","modified":1695739763571},{"_id":"source/leetcode/二叉树/95.不同的二叉搜索树II.md","hash":"ab025c27093391b0a2be884942c639c61c917b9e","modified":1695739763570},{"_id":"source/leetcode/二叉树/98.验证二叉搜索树.md","hash":"ad2809a910d640fb9ec30a7349f8d863af7def66","modified":1695739763571},{"_id":"source/leetcode/二叉树/958.二叉树的完全性检验.md","hash":"d06415f421bb044a093671b13c031e88d4ab34c5","modified":1695739763571},{"_id":"source/leetcode/二叉树/993.二叉树的堂兄弟节点.md","hash":"951cbb7fc70daf6ea47eae2623158822c7f40010","modified":1695739763572},{"_id":"source/leetcode/二叉树/998.最大二叉树II.md","hash":"c7bcbc4a1d37f5365603759705213428f7266235","modified":1695739763572},{"_id":"source/leetcode/二叉树/99.恢复二叉搜索树.md","hash":"c001e33c1e00eccb95f92a7624712cf03bb29b39","modified":1695739763572},{"_id":"source/leetcode/二叉树/988.从叶结点开始的最小字符串.md","hash":"c00ddb7e1be961dbea444c2a9f07d98ea5f90b38","modified":1695739763571},{"_id":"source/leetcode/链表/25.K个一组翻转链表.md","hash":"ab1b28cf2e8dcf960d0bc55105f21e1626a41fc3","modified":1695739763595},{"_id":"source/leetcode/面试经典150题/121.买卖股票的最佳时机.md","hash":"eaa02636096809aceac2827fd120f6b88d208a0b","modified":1695739763603},{"_id":"source/leetcode/链表/234.回文链表.md","hash":"35d9936173fdd16496f1363526947a151aed4dbd","modified":1695739763594},{"_id":"source/leetcode/面试经典150题/12.整数转罗马数字.md","hash":"2ee49e3819b3b8d717ce66ded3a0a4d2504ab96e","modified":1695739763603},{"_id":"source/leetcode/面试经典150题/122.买卖股票的最佳时机II.md","hash":"2429c14617750ade30043e12115efc5a04f52951","modified":1695739763604},{"_id":"source/leetcode/面试经典150题/13.罗马数字转整数.md","hash":"f98814265ec20add572b074408846cd215a9aa03","modified":1695739763602},{"_id":"source/leetcode/面试经典150题/14.最长公共前缀.md","hash":"d0fc3b7bca151e96b7cee0fb87918188184e3478","modified":1695739763605},{"_id":"source/leetcode/面试经典150题/151.反转字符串中的单词.md","hash":"2fa4e6dcda86f182882fbee22ed0593cc6c8850c","modified":1695739763605},{"_id":"source/leetcode/面试经典150题/169.多数元素.md","hash":"7b0890628dd0379bd01fc862c53937d1651cbc1b","modified":1695739763606},{"_id":"source/leetcode/面试经典150题/189.轮转数组.md","hash":"7a01b3d766577dbc7f4388d645e2dedc53fb9a37","modified":1695739763607},{"_id":"source/leetcode/面试经典150题/125.验证回文串.md","hash":"a6ea83966db41275ee9226d17b059383cbce6d21","modified":1696658750675},{"_id":"source/leetcode/面试经典150题/134.加油站.md","hash":"33acc8193772874b3c9ba70dc519d65aa892b2af","modified":1695739763604},{"_id":"source/leetcode/面试经典150题/167.两数之和II-输入有序数组.md","hash":"97cf2de2895852e25d9bc0cd23bb42bb5199f27b","modified":1697035374573},{"_id":"source/leetcode/面试经典150题/26.删除有序数组中的重复项.md","hash":"15c50f3920160555fe0ed69c3f6156125ed5a980","modified":1695739763607},{"_id":"source/leetcode/面试经典150题/27.移除元素.md","hash":"c98f1fe883131844490a906f482044d0b655e6c5","modified":1695739763608},{"_id":"source/leetcode/面试经典150题/380.O(1)时间插入、删除和获取随机元素.md","hash":"33a61d2fb393376e5c4f80bf67af93a116f6a520","modified":1695739763608},{"_id":"source/leetcode/面试经典150题/45.跳跃游戏II.md","hash":"77893a5af8cb697f4c5b0c27517f0f403b3acf80","modified":1695739763609},{"_id":"source/leetcode/面试经典150题/55.跳跃游戏.md","hash":"b588c52e055841636a4a0aff41bc485c77062600","modified":1695739763610},{"_id":"source/leetcode/面试经典150题/6.N字形变换.md","hash":"9e501abbccadc9ccf63fbc1cf7af73041f9d942b","modified":1695739763610},{"_id":"source/leetcode/面试经典150题/88.合并两个有序数组.md","hash":"25ed805b5a6ebb60edabcfdc922e27971297fb5e","modified":1695739763611},{"_id":"source/leetcode/面试经典150题/80.删除有序数组中的重复项II.md","hash":"4717625c2684fd0b60e0af274e96e01399b939b2","modified":1695739763611},{"_id":"source/leetcode/面试经典150题/58.最后一个单词的长度.md","hash":"647eaf43b94f69db330c386fc2556f976986e41a","modified":1695739763610},{"_id":"source/leetcode/面试经典150题/392.判断子序列.md","hash":"a1d4f0697025c3abffcece7fcd0ddc654b903638","modified":1696865510204},{"_id":"source/leetcode/format.js","hash":"d387362b61b5f53736137f7b9becc50a9fea10bb","modified":1697037318474}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2023-09-27T09:34:38.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-09-27 17:34:38\n---\n","updated":"2023-09-27T09:34:38.820Z","path":"categories/index.html","_id":"clmvggc4u0000xpyh7k306yyd","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"LeetCode","date":"2023-09-27T09:34:38.000Z","layout":"page","_content":"\n1. [动态规划](/leetcode/动态规划/)\n2. [二叉树](/leetcode/二叉树/)\n3. [链表](/leetcode/链表/)\n4. [面试经典 150 题](/leetcode/面试经典150题/)\n5. [算法实现](/leetcode/算法实现/)\n","source":"leetcode/index.md","raw":"---\ntitle: LeetCode\ndate: 2023-09-27 17:34:38\nlayout: \n---\n\n1. [动态规划](/leetcode/动态规划/)\n2. [二叉树](/leetcode/二叉树/)\n3. [链表](/leetcode/链表/)\n4. [面试经典 150 题](/leetcode/面试经典150题/)\n5. [算法实现](/leetcode/算法实现/)\n","updated":"2023-09-28T02:17:58.188Z","path":"leetcode/index.html","_id":"cln0fylla000ek2w7cz09adxa","comments":1,"content":"<ol>\n<li><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/\">动态规划</a></li>\n<li><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/\">二叉树</a></li>\n<li><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/\">链表</a></li>\n<li><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/\">面试经典 150 题</a></li>\n<li><a href=\"/leetcode/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/\">算法实现</a></li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<ol>\n<li><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/\">动态规划</a></li>\n<li><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/\">二叉树</a></li>\n<li><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/\">链表</a></li>\n<li><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/\">面试经典 150 题</a></li>\n<li><a href=\"/leetcode/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/\">算法实现</a></li>\n</ol>\n"},{"_content":"# 动态规划\n\n## 解题框架\n\n明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。\n\n## 自顶向下\n\n通过递归树而从上向下延伸的解题方式，一般用递归来解题。\n\n### 框架\n\n```js\nfunction coinChange(coins: List[int], amount: int) {\n  // 备忘录\n  const dpTable = {};\n  function dp(n) {\n    // 查备忘录，避免重复计算\n    if (dpTable[n]) return dpTable[n];\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    let res = Number.POSITIVE_INFINITY;\n    const coinsLen = coins.length;\n    for (let i = 0; i < coinsLen; i++) {\n      const num = dp(n - coins[i]);\n      if (num === -1) continue;\n      res = Math.min(res, 1 + num);\n    }\n    // 记入备忘录\n    dpTable[n] = res === Number.POSITIVE_INFINITY ? -1 : res;\n    return dpTable[n];\n  }\n\n  return dp(amount);\n}\n```\n\n## 自底向上\n\n从递归树最底下往上推出来的解题方式，一般用循环迭代来解题。\n\n```ts\nfunction jump(nums: number[]): number {\n  // dp 数组\n  const dp: number[] = Array.from(Array(nums.length), () => {\n    return nums.length + 1;\n  });\n  // 一般第一个状态都是0\n  dp[0] = 0;\n  // 遍历dp数组\n  for (let i = 0; i < dp.length; i++) {\n    for (let j = 1; j <= nums[i]; j++) {\n      if (i + j >= nums.length) return dp[dp.length - 1];\n      dp[i + j] = Math.min(dp[i + j], 1 + dp[i]);\n    }\n  }\n  // 最后一个便是我们的目标状态了\n  return dp[dp.length - 1];\n}\n```\n","source":"leetcode/动态规划/技巧.md","raw":"# 动态规划\n\n## 解题框架\n\n明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。\n\n## 自顶向下\n\n通过递归树而从上向下延伸的解题方式，一般用递归来解题。\n\n### 框架\n\n```js\nfunction coinChange(coins: List[int], amount: int) {\n  // 备忘录\n  const dpTable = {};\n  function dp(n) {\n    // 查备忘录，避免重复计算\n    if (dpTable[n]) return dpTable[n];\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    let res = Number.POSITIVE_INFINITY;\n    const coinsLen = coins.length;\n    for (let i = 0; i < coinsLen; i++) {\n      const num = dp(n - coins[i]);\n      if (num === -1) continue;\n      res = Math.min(res, 1 + num);\n    }\n    // 记入备忘录\n    dpTable[n] = res === Number.POSITIVE_INFINITY ? -1 : res;\n    return dpTable[n];\n  }\n\n  return dp(amount);\n}\n```\n\n## 自底向上\n\n从递归树最底下往上推出来的解题方式，一般用循环迭代来解题。\n\n```ts\nfunction jump(nums: number[]): number {\n  // dp 数组\n  const dp: number[] = Array.from(Array(nums.length), () => {\n    return nums.length + 1;\n  });\n  // 一般第一个状态都是0\n  dp[0] = 0;\n  // 遍历dp数组\n  for (let i = 0; i < dp.length; i++) {\n    for (let j = 1; j <= nums[i]; j++) {\n      if (i + j >= nums.length) return dp[dp.length - 1];\n      dp[i + j] = Math.min(dp[i + j], 1 + dp[i]);\n    }\n  }\n  // 最后一个便是我们的目标状态了\n  return dp[dp.length - 1];\n}\n```\n","date":"2023-09-26T14:49:23.534Z","updated":"2023-09-26T14:49:23.534Z","path":"leetcode/动态规划/技巧.html","_id":"cln0fyllb000jk2w75gtu0mnp","title":"","comments":1,"layout":"page","content":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"解题框架\"><a href=\"#解题框架\" class=\"headerlink\" title=\"解题框架\"></a>解题框架</h2><p>明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。</p>\n<h2 id=\"自顶向下\"><a href=\"#自顶向下\" class=\"headerlink\" title=\"自顶向下\"></a>自顶向下</h2><p>通过递归树而从上向下延伸的解题方式，一般用递归来解题。</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">coinChange</span>(<span class=\"params\">coins: List[int], amount: int</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 备忘录</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dpTable = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dp</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查备忘录，避免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[n]) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> coinsLen = coins.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coinsLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> num = <span class=\"title function_\">dp</span>(n - coins[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num === -<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(res, <span class=\"number\">1</span> + num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 记入备忘录</span></span><br><span class=\"line\">    dpTable[n] = res === <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span> ? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dp</span>(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自底向上\"><a href=\"#自底向上\" class=\"headerlink\" title=\"自底向上\"></a>自底向上</h2><p>从递归树最底下往上推出来的解题方式，一般用循环迭代来解题。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// dp 数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dp</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(nums.<span class=\"property\">length</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.<span class=\"property\">length</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 一般第一个状态都是0</span></span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历dp数组</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i + j &gt;= nums.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">      dp[i + j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i + j], <span class=\"number\">1</span> + dp[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 最后一个便是我们的目标状态了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"解题框架\"><a href=\"#解题框架\" class=\"headerlink\" title=\"解题框架\"></a>解题框架</h2><p>明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。</p>\n<h2 id=\"自顶向下\"><a href=\"#自顶向下\" class=\"headerlink\" title=\"自顶向下\"></a>自顶向下</h2><p>通过递归树而从上向下延伸的解题方式，一般用递归来解题。</p>\n<h3 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">coinChange</span>(<span class=\"params\">coins: List[int], amount: int</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 备忘录</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dpTable = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dp</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查备忘录，避免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[n]) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> coinsLen = coins.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coinsLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> num = <span class=\"title function_\">dp</span>(n - coins[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num === -<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(res, <span class=\"number\">1</span> + num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 记入备忘录</span></span><br><span class=\"line\">    dpTable[n] = res === <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span> ? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dp</span>(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自底向上\"><a href=\"#自底向上\" class=\"headerlink\" title=\"自底向上\"></a>自底向上</h2><p>从递归树最底下往上推出来的解题方式，一般用循环迭代来解题。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// dp 数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dp</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(nums.<span class=\"property\">length</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.<span class=\"property\">length</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 一般第一个状态都是0</span></span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历dp数组</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i + j &gt;= nums.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">      dp[i + j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i + j], <span class=\"number\">1</span> + dp[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 最后一个便是我们的目标状态了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 反转链表 II\n\n给你单链表的头指针 head 和两个整数  left 和 right ，其中  left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表\n\n[链接](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\n\n```ts\nfunction reverseBetween(\n  head: ListNode | null,\n  left: number,\n  right: number\n): ListNode | null {\n  if (left === 1) {\n    return reverse(head, right)\n  }\n  head.next = reverseBetween(head.next, left - 1, right - 1)\n  return head\n}\nconst reverse = (function () {\n  let back = null\n  return function (head: ListNode, right: number): ListNode {\n    if (right === 1) {\n      back = head.next\n      return head\n    }\n    const last: ListNode = reverse(head.next, right - 1)\n    head.next.next = head\n    head.next = back\n    return last\n  }\n})()\n```\n","source":"leetcode/链表/92.反转列表II.md","raw":"# 反转链表 II\n\n给你单链表的头指针 head 和两个整数  left 和 right ，其中  left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表\n\n[链接](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\n\n```ts\nfunction reverseBetween(\n  head: ListNode | null,\n  left: number,\n  right: number\n): ListNode | null {\n  if (left === 1) {\n    return reverse(head, right)\n  }\n  head.next = reverseBetween(head.next, left - 1, right - 1)\n  return head\n}\nconst reverse = (function () {\n  let back = null\n  return function (head: ListNode, right: number): ListNode {\n    if (right === 1) {\n      back = head.next\n      return head\n    }\n    const last: ListNode = reverse(head.next, right - 1)\n    head.next.next = head\n    head.next = back\n    return last\n  }\n})()\n```\n","date":"2023-09-26T14:49:23.595Z","updated":"2023-09-26T14:49:23.595Z","path":"leetcode/链表/92.反转列表II.html","_id":"cln0fyllb000lk2w73jgpc6ci","title":"","comments":1,"layout":"page","content":"<h1 id=\"反转链表-II\"><a href=\"#反转链表-II\" class=\"headerlink\" title=\"反转链表 II\"></a>反转链表 II</h1><p>给你单链表的头指针 head 和两个整数  left 和 right ，其中  left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表</p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reverseBetween</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  head: ListNode | <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">  left: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  right: <span class=\"built_in\">number</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">ListNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">reverse</span>(head, right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  head.<span class=\"property\">next</span> = <span class=\"title function_\">reverseBetween</span>(head.<span class=\"property\">next</span>, left - <span class=\"number\">1</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> reverse = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> back = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">head: ListNode, right: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      back = head.<span class=\"property\">next</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">last</span>: <span class=\"title class_\">ListNode</span> = <span class=\"title function_\">reverse</span>(head.<span class=\"property\">next</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">    head.<span class=\"property\">next</span>.<span class=\"property\">next</span> = head</span><br><span class=\"line\">    head.<span class=\"property\">next</span> = back</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"反转链表-II\"><a href=\"#反转链表-II\" class=\"headerlink\" title=\"反转链表 II\"></a>反转链表 II</h1><p>给你单链表的头指针 head 和两个整数  left 和 right ，其中  left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表</p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reverseBetween</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  head: ListNode | <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">  left: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  right: <span class=\"built_in\">number</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">ListNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">reverse</span>(head, right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  head.<span class=\"property\">next</span> = <span class=\"title function_\">reverseBetween</span>(head.<span class=\"property\">next</span>, left - <span class=\"number\">1</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> reverse = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> back = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">head: ListNode, right: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      back = head.<span class=\"property\">next</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">last</span>: <span class=\"title class_\">ListNode</span> = <span class=\"title function_\">reverse</span>(head.<span class=\"property\">next</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">    head.<span class=\"property\">next</span>.<span class=\"property\">next</span> = head</span><br><span class=\"line\">    head.<span class=\"property\">next</span> = back</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 链表的遍历方式\n\n## 递归\n\n整个链表反转\n\n```ts\nconst reverse = function (head: ListNode): ListNode {\n  if (head.next === null) {\n    return head\n  }\n  const last: ListNode = reverse(head.next)\n  head.next.next = head\n  head.next = null\n  return last\n}\n```\n\n链表 n 个反转\n\n```ts\nconst reverse = (function () {\n  let back = null\n  return function (head: ListNode, right: number): ListNode {\n    if (right === 1) {\n      back = head.next\n      return head\n    }\n    const last: ListNode = reverse(head.next, right - 1)\n    head.next.next = head\n    head.next = back\n    return last\n  }\n})()\n```\n\n链表其实也是树的一种\n\n```ts\nfunction traverse(head: ListNode | null) {\n  // 前序遍历代码\n  traverse(head.next)\n  // 后序遍历代码\n}\n```\n\n## 迭代\n\n反转链表\n\n```ts\nconst reverse = function(head: ListNode): ListNode {\n  let pre = null\n  let cur = head\n  let next = null\n  while(cur !== null) {\n    next = cur.next\n    cur.next = pre\n    pre = cur\n    cur = next\n  }\n  return pre\n}\n```\n\n快慢指针找链表中点\n\n```ts\nfunction findMid(head: ListNode): ListNode {\n  let slow = head, fast = head\n  while(fast != null && fast.next != null) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  if (fast !== null) slow = slow.next\n  return slow\n}\n```\n","source":"leetcode/链表/链表的遍历方式.md","raw":"# 链表的遍历方式\n\n## 递归\n\n整个链表反转\n\n```ts\nconst reverse = function (head: ListNode): ListNode {\n  if (head.next === null) {\n    return head\n  }\n  const last: ListNode = reverse(head.next)\n  head.next.next = head\n  head.next = null\n  return last\n}\n```\n\n链表 n 个反转\n\n```ts\nconst reverse = (function () {\n  let back = null\n  return function (head: ListNode, right: number): ListNode {\n    if (right === 1) {\n      back = head.next\n      return head\n    }\n    const last: ListNode = reverse(head.next, right - 1)\n    head.next.next = head\n    head.next = back\n    return last\n  }\n})()\n```\n\n链表其实也是树的一种\n\n```ts\nfunction traverse(head: ListNode | null) {\n  // 前序遍历代码\n  traverse(head.next)\n  // 后序遍历代码\n}\n```\n\n## 迭代\n\n反转链表\n\n```ts\nconst reverse = function(head: ListNode): ListNode {\n  let pre = null\n  let cur = head\n  let next = null\n  while(cur !== null) {\n    next = cur.next\n    cur.next = pre\n    pre = cur\n    cur = next\n  }\n  return pre\n}\n```\n\n快慢指针找链表中点\n\n```ts\nfunction findMid(head: ListNode): ListNode {\n  let slow = head, fast = head\n  while(fast != null && fast.next != null) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  if (fast !== null) slow = slow.next\n  return slow\n}\n```\n","date":"2023-09-26T14:49:23.595Z","updated":"2023-09-26T14:49:23.595Z","path":"leetcode/链表/链表的遍历方式.html","_id":"cln0fyllb000mk2w7eeul7qwj","title":"","comments":1,"layout":"page","content":"<h1 id=\"链表的遍历方式\"><a href=\"#链表的遍历方式\" class=\"headerlink\" title=\"链表的遍历方式\"></a>链表的遍历方式</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>整个链表反转</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reverse = <span class=\"keyword\">function</span> (<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head.<span class=\"property\">next</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">last</span>: <span class=\"title class_\">ListNode</span> = <span class=\"title function_\">reverse</span>(head.<span class=\"property\">next</span>)</span><br><span class=\"line\">  head.<span class=\"property\">next</span>.<span class=\"property\">next</span> = head</span><br><span class=\"line\">  head.<span class=\"property\">next</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> last</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链表 n 个反转</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reverse = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> back = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">head: ListNode, right: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      back = head.<span class=\"property\">next</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">last</span>: <span class=\"title class_\">ListNode</span> = <span class=\"title function_\">reverse</span>(head.<span class=\"property\">next</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">    head.<span class=\"property\">next</span>.<span class=\"property\">next</span> = head</span><br><span class=\"line\">    head.<span class=\"property\">next</span> = back</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>链表其实也是树的一种</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 前序遍历代码</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(head.<span class=\"property\">next</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>反转链表</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reverse = <span class=\"keyword\">function</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> cur = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> next = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(cur !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    next = cur.<span class=\"property\">next</span></span><br><span class=\"line\">    cur.<span class=\"property\">next</span> = pre</span><br><span class=\"line\">    pre = cur</span><br><span class=\"line\">    cur = next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>快慢指针找链表中点</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMid</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = head, fast = head</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(fast != <span class=\"literal\">null</span> &amp;&amp; fast.<span class=\"property\">next</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span>.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fast !== <span class=\"literal\">null</span>) slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"链表的遍历方式\"><a href=\"#链表的遍历方式\" class=\"headerlink\" title=\"链表的遍历方式\"></a>链表的遍历方式</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>整个链表反转</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reverse = <span class=\"keyword\">function</span> (<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head.<span class=\"property\">next</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">last</span>: <span class=\"title class_\">ListNode</span> = <span class=\"title function_\">reverse</span>(head.<span class=\"property\">next</span>)</span><br><span class=\"line\">  head.<span class=\"property\">next</span>.<span class=\"property\">next</span> = head</span><br><span class=\"line\">  head.<span class=\"property\">next</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> last</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链表 n 个反转</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reverse = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> back = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">head: ListNode, right: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      back = head.<span class=\"property\">next</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">last</span>: <span class=\"title class_\">ListNode</span> = <span class=\"title function_\">reverse</span>(head.<span class=\"property\">next</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">    head.<span class=\"property\">next</span>.<span class=\"property\">next</span> = head</span><br><span class=\"line\">    head.<span class=\"property\">next</span> = back</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>链表其实也是树的一种</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 前序遍历代码</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(head.<span class=\"property\">next</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>反转链表</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reverse = <span class=\"keyword\">function</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> cur = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> next = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(cur !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    next = cur.<span class=\"property\">next</span></span><br><span class=\"line\">    cur.<span class=\"property\">next</span> = pre</span><br><span class=\"line\">    pre = cur</span><br><span class=\"line\">    cur = next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>快慢指针找链表中点</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMid</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = head, fast = head</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(fast != <span class=\"literal\">null</span> &amp;&amp; fast.<span class=\"property\">next</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span>.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fast !== <span class=\"literal\">null</span>) slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 226. 翻转二叉树\n\n翻转一棵二叉树\n\n[链接](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n```ts\nfunction invertTree(root: TreeNode | null): TreeNode | null {\n  if (root === null) return root\n  const temp = root.left\n  root.left = root.right\n  root.right = temp\n  invertTree(root.left)\n  invertTree(root.right)\n  return root\n}\n```\n","source":"leetcode/二叉树/226.翻转二叉树.md","raw":"# 226. 翻转二叉树\n\n翻转一棵二叉树\n\n[链接](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n```ts\nfunction invertTree(root: TreeNode | null): TreeNode | null {\n  if (root === null) return root\n  const temp = root.left\n  root.left = root.right\n  root.right = temp\n  invertTree(root.left)\n  invertTree(root.right)\n  return root\n}\n```\n","date":"2023-09-26T14:49:23.557Z","updated":"2023-09-26T14:49:23.557Z","path":"leetcode/二叉树/226.翻转二叉树.html","_id":"cln0fyllg001xk2w76ge8czhb","title":"","comments":1,"layout":"page","content":"<h1 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226. 翻转二叉树\"></a>226. 翻转二叉树</h1><p>翻转一棵二叉树</p>\n<p><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">invertTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  <span class=\"keyword\">const</span> temp = root.<span class=\"property\">left</span></span><br><span class=\"line\">  root.<span class=\"property\">left</span> = root.<span class=\"property\">right</span></span><br><span class=\"line\">  root.<span class=\"property\">right</span> = temp</span><br><span class=\"line\">  <span class=\"title function_\">invertTree</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">invertTree</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226. 翻转二叉树\"></a>226. 翻转二叉树</h1><p>翻转一棵二叉树</p>\n<p><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">invertTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  <span class=\"keyword\">const</span> temp = root.<span class=\"property\">left</span></span><br><span class=\"line\">  root.<span class=\"property\">left</span> = root.<span class=\"property\">right</span></span><br><span class=\"line\">  root.<span class=\"property\">right</span> = temp</span><br><span class=\"line\">  <span class=\"title function_\">invertTree</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">invertTree</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 654. 最大二叉树\n\n给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：\n\n二叉树的根是数组 nums 中的最大元素。\n左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。\n右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。\n\n[链接](https://leetcode-cn.com/problems/maximum-binary-tree/)\n\n```ts\nfunction constructMaximumBinaryTree(nums: number[]): TreeNode | null {\n  if (!nums || nums.length === 0) return null\n  let maxVal = 0\n  let maxIndex = 0\n  const len = nums.length\n  for(let i = 0; i < nums.length;i++) {\n    if (maxVal < nums[i]) {\n      maxVal = nums[i]\n      maxIndex = i\n    }\n  }\n  const root = new TreeNode(maxVal)\n  root.left = constructMaximumBinaryTree(nums.slice(0, maxIndex))\n  root.right = constructMaximumBinaryTree(nums.slice(maxIndex + 1, len))\n  return root\n}\n```\n","source":"leetcode/二叉树/654.最大二叉树.md","raw":"# 654. 最大二叉树\n\n给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：\n\n二叉树的根是数组 nums 中的最大元素。\n左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。\n右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。\n\n[链接](https://leetcode-cn.com/problems/maximum-binary-tree/)\n\n```ts\nfunction constructMaximumBinaryTree(nums: number[]): TreeNode | null {\n  if (!nums || nums.length === 0) return null\n  let maxVal = 0\n  let maxIndex = 0\n  const len = nums.length\n  for(let i = 0; i < nums.length;i++) {\n    if (maxVal < nums[i]) {\n      maxVal = nums[i]\n      maxIndex = i\n    }\n  }\n  const root = new TreeNode(maxVal)\n  root.left = constructMaximumBinaryTree(nums.slice(0, maxIndex))\n  root.right = constructMaximumBinaryTree(nums.slice(maxIndex + 1, len))\n  return root\n}\n```\n","date":"2023-09-26T14:49:23.566Z","updated":"2023-09-26T14:49:23.566Z","path":"leetcode/二叉树/654.最大二叉树.html","_id":"cln0fyllj002rk2w7fmis7810","title":"","comments":1,"layout":"page","content":"<h1 id=\"654-最大二叉树\"><a href=\"#654-最大二叉树\" class=\"headerlink\" title=\"654. 最大二叉树\"></a>654. 最大二叉树</h1><p>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>\n<p>二叉树的根是数组 nums 中的最大元素。<br>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。<br>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">constructMaximumBinaryTree</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!nums || nums.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxVal = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"property\">length</span>;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class=\"line\">      maxVal = nums[i]</span><br><span class=\"line\">      maxIndex = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(maxVal)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">constructMaximumBinaryTree</span>(nums.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, maxIndex))</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">constructMaximumBinaryTree</span>(nums.<span class=\"title function_\">slice</span>(maxIndex + <span class=\"number\">1</span>, len))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"654-最大二叉树\"><a href=\"#654-最大二叉树\" class=\"headerlink\" title=\"654. 最大二叉树\"></a>654. 最大二叉树</h1><p>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>\n<p>二叉树的根是数组 nums 中的最大元素。<br>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。<br>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">constructMaximumBinaryTree</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!nums || nums.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxVal = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"property\">length</span>;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class=\"line\">      maxVal = nums[i]</span><br><span class=\"line\">      maxIndex = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(maxVal)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">constructMaximumBinaryTree</span>(nums.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, maxIndex))</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">constructMaximumBinaryTree</span>(nums.<span class=\"title function_\">slice</span>(maxIndex + <span class=\"number\">1</span>, len))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 二叉树的遍历方式\n\n## 递归\n\n遍历整个二叉树\n\n```ts\nfunction traverse(root: TreeNode) {\n  // 前序遍历代码\n  traverse(root.left)\n  // 中序遍历代码\n  traverse(root.right)\n  // 后序遍历代码\n}\n```\n\n## 迭代\n\n### 前序\n\n```ts\nfunction preFor(root: TreeNode) {\n  const nodeList = []\n  const stack = []\n  while(root !== null || stack.length > 0) {\n    while(root !== null) {\n      stack.push(root)\n      //****** 前序遍历位置 ******/\n      // todo\n      /************************/\n      root = root.left\n    }\n    while(root === null && stack.length > 0) {\n      root = stack.pop().right\n    }\n  }\n}\n```\n\n### 中序\n\n```ts\nfunction inFor(root: TreeNode) {\n  const nodeList = []\n  const stack = []\n  while(root !== null || stack.length > 0) {\n    while(root !== null) {\n      stack.push(root)\n      root = root.left\n    }\n    root = stack.pop()\n    //****** 中序遍历位置 ******/\n    // todo\n    /************************/\n    root = root.right\n  }\n}\n```\n\n### 后序\n\n```ts\nfunction postFor(root: TreeNode) {\n  const nodeList = []\n  const stack = []\n  const pre: TreeNode = null\n  while(root !== null || stack.length > 0) {\n    while(root !== null) {\n      stack.push(root)\n      root = root.left\n    }\n    root = stack[stack.length - 1]\n    if (root.right === null || root.right === pre) {\n      pre = root\n      //****** 后序遍历位置 ******/\n      // todo\n      /************************/\n      root = null\n    } else {\n      root = root.right\n    }\n  }\n}\n```\n\n## 快速排序 框架\n\n```ts\nfunction sort(nums: number[], lo: number, hi: number) {\n  /****** 前序遍历位置 ******/\n  // 通过交换元素构建分界点 p\n  const p = partition(nums, lo, hi)\n  /************************/\n  sort(nums, lo, p - 1)\n  sort(nums, p + 1, hi)\n}\n```\n\n## 归并排序 框架\n\n```ts\nfunction sort(nums: number[], lo: number, hi: number) {\n  const mid = parseInt((lo + hi) / 2)\n  sort(nums, lo, mid)\n  sort(nums, mid + 1, hi)\n  /****** 后序遍历位置 ******/\n  // 合并两个排好序的子数组\n  merge(nums, lo, mid, hi)\n  /************************/\n}\n```\n\n## 层级遍历\n\n```ts\nfunction traverse(TreeNode root) {\n  if (root === null) return\n  const nodeQueList: TreeNode[] = []\n  nodeQueList.push(root)\n  while(nodeQueList.length > 0) {\n    const cur = nodeQueList.shift()\n    /* 层级遍历代码位置 */\n    /*****************/\n    if (cur.left !== null) {\n      nodeQueList.push(cur.left)\n    }\n    if (cur.right !== null) {\n      nodeQueList.push(cur.right)\n    }\n  }\n}\n```\n","source":"leetcode/二叉树/二叉树的遍历方式.md","raw":"# 二叉树的遍历方式\n\n## 递归\n\n遍历整个二叉树\n\n```ts\nfunction traverse(root: TreeNode) {\n  // 前序遍历代码\n  traverse(root.left)\n  // 中序遍历代码\n  traverse(root.right)\n  // 后序遍历代码\n}\n```\n\n## 迭代\n\n### 前序\n\n```ts\nfunction preFor(root: TreeNode) {\n  const nodeList = []\n  const stack = []\n  while(root !== null || stack.length > 0) {\n    while(root !== null) {\n      stack.push(root)\n      //****** 前序遍历位置 ******/\n      // todo\n      /************************/\n      root = root.left\n    }\n    while(root === null && stack.length > 0) {\n      root = stack.pop().right\n    }\n  }\n}\n```\n\n### 中序\n\n```ts\nfunction inFor(root: TreeNode) {\n  const nodeList = []\n  const stack = []\n  while(root !== null || stack.length > 0) {\n    while(root !== null) {\n      stack.push(root)\n      root = root.left\n    }\n    root = stack.pop()\n    //****** 中序遍历位置 ******/\n    // todo\n    /************************/\n    root = root.right\n  }\n}\n```\n\n### 后序\n\n```ts\nfunction postFor(root: TreeNode) {\n  const nodeList = []\n  const stack = []\n  const pre: TreeNode = null\n  while(root !== null || stack.length > 0) {\n    while(root !== null) {\n      stack.push(root)\n      root = root.left\n    }\n    root = stack[stack.length - 1]\n    if (root.right === null || root.right === pre) {\n      pre = root\n      //****** 后序遍历位置 ******/\n      // todo\n      /************************/\n      root = null\n    } else {\n      root = root.right\n    }\n  }\n}\n```\n\n## 快速排序 框架\n\n```ts\nfunction sort(nums: number[], lo: number, hi: number) {\n  /****** 前序遍历位置 ******/\n  // 通过交换元素构建分界点 p\n  const p = partition(nums, lo, hi)\n  /************************/\n  sort(nums, lo, p - 1)\n  sort(nums, p + 1, hi)\n}\n```\n\n## 归并排序 框架\n\n```ts\nfunction sort(nums: number[], lo: number, hi: number) {\n  const mid = parseInt((lo + hi) / 2)\n  sort(nums, lo, mid)\n  sort(nums, mid + 1, hi)\n  /****** 后序遍历位置 ******/\n  // 合并两个排好序的子数组\n  merge(nums, lo, mid, hi)\n  /************************/\n}\n```\n\n## 层级遍历\n\n```ts\nfunction traverse(TreeNode root) {\n  if (root === null) return\n  const nodeQueList: TreeNode[] = []\n  nodeQueList.push(root)\n  while(nodeQueList.length > 0) {\n    const cur = nodeQueList.shift()\n    /* 层级遍历代码位置 */\n    /*****************/\n    if (cur.left !== null) {\n      nodeQueList.push(cur.left)\n    }\n    if (cur.right !== null) {\n      nodeQueList.push(cur.right)\n    }\n  }\n}\n```\n","date":"2023-09-26T14:49:23.572Z","updated":"2023-09-26T14:49:23.572Z","path":"leetcode/二叉树/二叉树的遍历方式.html","_id":"cln0fyllm003lk2w79bwhdyh5","title":"","comments":1,"layout":"page","content":"<h1 id=\"二叉树的遍历方式\"><a href=\"#二叉树的遍历方式\" class=\"headerlink\" title=\"二叉树的遍历方式\"></a>二叉树的遍历方式</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>遍历整个二叉树</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 前序遍历代码</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历代码</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><h3 id=\"前序\"><a href=\"#前序\" class=\"headerlink\" title=\"前序\"></a>前序</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">preFor</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      <span class=\"comment\">//****** 前序遍历位置 ******/</span></span><br><span class=\"line\">      <span class=\"comment\">// todo</span></span><br><span class=\"line\">      <span class=\"comment\">/************************/</span></span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root === <span class=\"literal\">null</span> &amp;&amp; stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      root = stack.<span class=\"title function_\">pop</span>().<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"中序\"><a href=\"#中序\" class=\"headerlink\" title=\"中序\"></a>中序</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inFor</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = stack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    <span class=\"comment\">//****** 中序遍历位置 ******/</span></span><br><span class=\"line\">    <span class=\"comment\">// todo</span></span><br><span class=\"line\">    <span class=\"comment\">/************************/</span></span><br><span class=\"line\">    root = root.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后序\"><a href=\"#后序\" class=\"headerlink\" title=\"后序\"></a>后序</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">postFor</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">pre</span>: <span class=\"title class_\">TreeNode</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = stack[stack.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> || root.<span class=\"property\">right</span> === pre) &#123;</span><br><span class=\"line\">      pre = root</span><br><span class=\"line\">      <span class=\"comment\">//****** 后序遍历位置 ******/</span></span><br><span class=\"line\">      <span class=\"comment\">// todo</span></span><br><span class=\"line\">      <span class=\"comment\">/************************/</span></span><br><span class=\"line\">      root = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      root = root.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序-框架\"><a href=\"#快速排序-框架\" class=\"headerlink\" title=\"快速排序 框架\"></a>快速排序 框架</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sort</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], lo: <span class=\"built_in\">number</span>, hi: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/****** 前序遍历位置 ******/</span></span><br><span class=\"line\">  <span class=\"comment\">// 通过交换元素构建分界点 p</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = <span class=\"title function_\">partition</span>(nums, lo, hi)</span><br><span class=\"line\">  <span class=\"comment\">/************************/</span></span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, lo, p - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, p + <span class=\"number\">1</span>, hi)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"归并排序-框架\"><a href=\"#归并排序-框架\" class=\"headerlink\" title=\"归并排序 框架\"></a>归并排序 框架</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sort</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], lo: <span class=\"built_in\">number</span>, hi: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mid = <span class=\"built_in\">parseInt</span>((lo + hi) / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, lo, mid)</span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, mid + <span class=\"number\">1</span>, hi)</span><br><span class=\"line\">  <span class=\"comment\">/****** 后序遍历位置 ******/</span></span><br><span class=\"line\">  <span class=\"comment\">// 合并两个排好序的子数组</span></span><br><span class=\"line\">  <span class=\"title function_\">merge</span>(nums, lo, mid, hi)</span><br><span class=\"line\">  <span class=\"comment\">/************************/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"层级遍历\"><a href=\"#层级遍历\" class=\"headerlink\" title=\"层级遍历\"></a>层级遍历</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">TreeNode root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQueList</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">  nodeQueList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQueList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = nodeQueList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"comment\">/* 层级遍历代码位置 */</span></span><br><span class=\"line\">    <span class=\"comment\">/*****************/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur.<span class=\"property\">left</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">left</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur.<span class=\"property\">right</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"二叉树的遍历方式\"><a href=\"#二叉树的遍历方式\" class=\"headerlink\" title=\"二叉树的遍历方式\"></a>二叉树的遍历方式</h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>遍历整个二叉树</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 前序遍历代码</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 中序遍历代码</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 后序遍历代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><h3 id=\"前序\"><a href=\"#前序\" class=\"headerlink\" title=\"前序\"></a>前序</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">preFor</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      <span class=\"comment\">//****** 前序遍历位置 ******/</span></span><br><span class=\"line\">      <span class=\"comment\">// todo</span></span><br><span class=\"line\">      <span class=\"comment\">/************************/</span></span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root === <span class=\"literal\">null</span> &amp;&amp; stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      root = stack.<span class=\"title function_\">pop</span>().<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"中序\"><a href=\"#中序\" class=\"headerlink\" title=\"中序\"></a>中序</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inFor</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = stack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    <span class=\"comment\">//****** 中序遍历位置 ******/</span></span><br><span class=\"line\">    <span class=\"comment\">// todo</span></span><br><span class=\"line\">    <span class=\"comment\">/************************/</span></span><br><span class=\"line\">    root = root.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后序\"><a href=\"#后序\" class=\"headerlink\" title=\"后序\"></a>后序</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">postFor</span>(<span class=\"params\">root: TreeNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">pre</span>: <span class=\"title class_\">TreeNode</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = stack[stack.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> || root.<span class=\"property\">right</span> === pre) &#123;</span><br><span class=\"line\">      pre = root</span><br><span class=\"line\">      <span class=\"comment\">//****** 后序遍历位置 ******/</span></span><br><span class=\"line\">      <span class=\"comment\">// todo</span></span><br><span class=\"line\">      <span class=\"comment\">/************************/</span></span><br><span class=\"line\">      root = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      root = root.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序-框架\"><a href=\"#快速排序-框架\" class=\"headerlink\" title=\"快速排序 框架\"></a>快速排序 框架</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sort</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], lo: <span class=\"built_in\">number</span>, hi: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/****** 前序遍历位置 ******/</span></span><br><span class=\"line\">  <span class=\"comment\">// 通过交换元素构建分界点 p</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = <span class=\"title function_\">partition</span>(nums, lo, hi)</span><br><span class=\"line\">  <span class=\"comment\">/************************/</span></span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, lo, p - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, p + <span class=\"number\">1</span>, hi)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"归并排序-框架\"><a href=\"#归并排序-框架\" class=\"headerlink\" title=\"归并排序 框架\"></a>归并排序 框架</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sort</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], lo: <span class=\"built_in\">number</span>, hi: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mid = <span class=\"built_in\">parseInt</span>((lo + hi) / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, lo, mid)</span><br><span class=\"line\">  <span class=\"title function_\">sort</span>(nums, mid + <span class=\"number\">1</span>, hi)</span><br><span class=\"line\">  <span class=\"comment\">/****** 后序遍历位置 ******/</span></span><br><span class=\"line\">  <span class=\"comment\">// 合并两个排好序的子数组</span></span><br><span class=\"line\">  <span class=\"title function_\">merge</span>(nums, lo, mid, hi)</span><br><span class=\"line\">  <span class=\"comment\">/************************/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"层级遍历\"><a href=\"#层级遍历\" class=\"headerlink\" title=\"层级遍历\"></a>层级遍历</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">TreeNode root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQueList</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">  nodeQueList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQueList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = nodeQueList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"comment\">/* 层级遍历代码位置 */</span></span><br><span class=\"line\">    <span class=\"comment\">/*****************/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur.<span class=\"property\">left</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">left</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur.<span class=\"property\">right</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"动态规划","_content":"[1137.第N个泰波那契数](/leetcode/动态规划/1137.第N个泰波那契数)\n[118.杨辉三角](/leetcode/动态规划/118.杨辉三角)\n[119.杨辉三角II](/leetcode/动态规划/119.杨辉三角II)\n[120.三角形最小路径和](/leetcode/动态规划/120.三角形最小路径和)\n[322.零钱兑换](/leetcode/动态规划/322.零钱兑换)\n[45.跳跃游戏II](/leetcode/动态规划/45.跳跃游戏II)\n[509.斐波那契数](/leetcode/动态规划/509.斐波那契数)\n[53.最大子序和](/leetcode/动态规划/53.最大子序和)\n[55.跳跃游戏](/leetcode/动态规划/55.跳跃游戏)\n[62.不同路径](/leetcode/动态规划/62.不同路径)\n[63.不同路径II](/leetcode/动态规划/63.不同路径II)\n[64.最小路径和](/leetcode/动态规划/64.最小路径和)\n[70.爬楼梯](/leetcode/动态规划/70.爬楼梯)\n[746.使用最小花费爬楼梯](/leetcode/动态规划/746.使用最小花费爬楼梯)\n[91.解码方法](/leetcode/动态规划/91.解码方法)\n[931.下降路径最小和](/leetcode/动态规划/931.下降路径最小和)\n[剑指OfferII103.最少的硬币数目](/leetcode/动态规划/剑指OfferII103.最少的硬币数目)\n[技巧](/leetcode/动态规划/技巧)\n","source":"leetcode/动态规划/index.md","raw":"---\ntitle: 动态规划\n---\n[1137.第N个泰波那契数](/leetcode/动态规划/1137.第N个泰波那契数)\n[118.杨辉三角](/leetcode/动态规划/118.杨辉三角)\n[119.杨辉三角II](/leetcode/动态规划/119.杨辉三角II)\n[120.三角形最小路径和](/leetcode/动态规划/120.三角形最小路径和)\n[322.零钱兑换](/leetcode/动态规划/322.零钱兑换)\n[45.跳跃游戏II](/leetcode/动态规划/45.跳跃游戏II)\n[509.斐波那契数](/leetcode/动态规划/509.斐波那契数)\n[53.最大子序和](/leetcode/动态规划/53.最大子序和)\n[55.跳跃游戏](/leetcode/动态规划/55.跳跃游戏)\n[62.不同路径](/leetcode/动态规划/62.不同路径)\n[63.不同路径II](/leetcode/动态规划/63.不同路径II)\n[64.最小路径和](/leetcode/动态规划/64.最小路径和)\n[70.爬楼梯](/leetcode/动态规划/70.爬楼梯)\n[746.使用最小花费爬楼梯](/leetcode/动态规划/746.使用最小花费爬楼梯)\n[91.解码方法](/leetcode/动态规划/91.解码方法)\n[931.下降路径最小和](/leetcode/动态规划/931.下降路径最小和)\n[剑指OfferII103.最少的硬币数目](/leetcode/动态规划/剑指OfferII103.最少的硬币数目)\n[技巧](/leetcode/动态规划/技巧)\n","date":"2023-10-11T15:15:20.522Z","updated":"2023-10-11T15:15:20.522Z","path":"leetcode/动态规划/index.html","_id":"cln0g9pby0000niw7fll06ld4","comments":1,"layout":"page","content":"<p><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0\">1137.第N个泰波那契数</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92\">118.杨辉三角</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II\">119.杨辉三角II</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C\">120.三角形最小路径和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2\">322.零钱兑换</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII\">45.跳跃游戏II</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0\">509.斐波那契数</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C\">53.最大子序和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F\">55.跳跃游戏</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84\">62.不同路径</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II\">63.不同路径II</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C\">64.最小路径和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/70.%E7%88%AC%E6%A5%BC%E6%A2%AF\">70.爬楼梯</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF\">746.使用最小花费爬楼梯</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95\">91.解码方法</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C\">931.下降路径最小和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%89%91%E6%8C%87OfferII103.%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE\">剑指OfferII103.最少的硬币数目</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8A%80%E5%B7%A7\">技巧</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1137.%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0\">1137.第N个泰波那契数</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/118.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92\">118.杨辉三角</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/119.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II\">119.杨辉三角II</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C\">120.三角形最小路径和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2\">322.零钱兑换</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII\">45.跳跃游戏II</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0\">509.斐波那契数</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C\">53.最大子序和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F\">55.跳跃游戏</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84\">62.不同路径</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II\">63.不同路径II</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C\">64.最小路径和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/70.%E7%88%AC%E6%A5%BC%E6%A2%AF\">70.爬楼梯</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF\">746.使用最小花费爬楼梯</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95\">91.解码方法</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C\">931.下降路径最小和</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%89%91%E6%8C%87OfferII103.%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE\">剑指OfferII103.最少的硬币数目</a><br><a href=\"/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8A%80%E5%B7%A7\">技巧</a></p>\n"},{"title":"二叉树","_content":"[100.相同的树](/leetcode/二叉树/100.相同的树)\n[1008.前序遍历构造二叉搜索树](/leetcode/二叉树/1008.前序遍历构造二叉搜索树)\n[101.对称二叉树](/leetcode/二叉树/101.对称二叉树)\n[102.二叉树的层序遍历](/leetcode/二叉树/102.二叉树的层序遍历)\n[1022.从根到叶的二进制数之和](/leetcode/二叉树/1022.从根到叶的二进制数之和)\n[1026.节点与其祖先之间的最大差值](/leetcode/二叉树/1026.节点与其祖先之间的最大差值)\n[103.二叉树的锯齿形层序遍历](/leetcode/二叉树/103.二叉树的锯齿形层序遍历)\n[1038.把二叉搜索树转换为累加树](/leetcode/二叉树/1038.把二叉搜索树转换为累加树)\n[104.二叉树的最大深度](/leetcode/二叉树/104.二叉树的最大深度)\n[105.从前序与中序遍历序列构造二叉树](/leetcode/二叉树/105.从前序与中序遍历序列构造二叉树)\n[106.从中序与后序遍历序列构造二叉树](/leetcode/二叉树/106.从中序与后序遍历序列构造二叉树)\n[107.二叉树的层序遍历II](/leetcode/二叉树/107.二叉树的层序遍历II)\n[108.将有序数组转换为二叉搜索树](/leetcode/二叉树/108.将有序数组转换为二叉搜索树)\n[1080.根到叶路径上的不足节点](/leetcode/二叉树/1080.根到叶路径上的不足节点)\n[109.有序链表转换二叉搜索树](/leetcode/二叉树/109.有序链表转换二叉搜索树)\n[110.平衡二叉树](/leetcode/二叉树/110.平衡二叉树)\n[1104.二叉树寻路](/leetcode/二叉树/1104.二叉树寻路)\n[111.二叉树的最小深度](/leetcode/二叉树/111.二叉树的最小深度)\n[1110.删点成林](/leetcode/二叉树/1110.删点成林)\n[112.路径总和](/leetcode/二叉树/112.路径总和)\n[1123.最深叶节点的最近公共祖先](/leetcode/二叉树/1123.最深叶节点的最近公共祖先)\n[113.路径总和II](/leetcode/二叉树/113.路径总和II)\n[114.二叉树展开为链表](/leetcode/二叉树/114.二叉树展开为链表)\n[1145.二叉树着色游戏](/leetcode/二叉树/1145.二叉树着色游戏)\n[116.填充每个节点的下一个右侧节点指针](/leetcode/二叉树/116.填充每个节点的下一个右侧节点指针)\n[1161.最大层内元素和](/leetcode/二叉树/1161.最大层内元素和)\n[117.填充每个节点的下一个右侧节点指针II](/leetcode/二叉树/117.填充每个节点的下一个右侧节点指针II)\n[124.二叉树中的最大路径和](/leetcode/二叉树/124.二叉树中的最大路径和)\n[1261.在受污染的二叉树中查找元素](/leetcode/二叉树/1261.在受污染的二叉树中查找元素)\n[129.求根节点到叶节点数字之和](/leetcode/二叉树/129.求根节点到叶节点数字之和)\n[1302.层数最深叶子节点的和](/leetcode/二叉树/1302.层数最深叶子节点的和)\n[1305.两棵二叉搜索树中的所有元素](/leetcode/二叉树/1305.两棵二叉搜索树中的所有元素)\n[1315.祖父节点值为偶数的节点和](/leetcode/二叉树/1315.祖父节点值为偶数的节点和)\n[1325.删除给定值的叶子节点](/leetcode/二叉树/1325.删除给定值的叶子节点)\n[1339.分裂二叉树的最大乘积](/leetcode/二叉树/1339.分裂二叉树的最大乘积)\n[1361.验证二叉树](/leetcode/二叉树/1361.验证二叉树)\n[1367.二叉树中的列表](/leetcode/二叉树/1367.二叉树中的列表)\n[1376.通知所有员工所需的时间](/leetcode/二叉树/1376.通知所有员工所需的时间)\n[1379.找出克隆二叉树中的相同节点](/leetcode/二叉树/1379.找出克隆二叉树中的相同节点)\n[1382.将二叉搜索树变平衡](/leetcode/二叉树/1382.将二叉搜索树变平衡)\n[144.二叉树的前序遍历](/leetcode/二叉树/144.二叉树的前序遍历)\n[1448.统计二叉树中好节点的数目](/leetcode/二叉树/1448.统计二叉树中好节点的数目)\n[145.二叉树的后序遍历](/leetcode/二叉树/145.二叉树的后序遍历)\n[1457.二叉树中的伪回文路径](/leetcode/二叉树/1457.二叉树中的伪回文路径)\n[173.二叉搜索树迭代器](/leetcode/二叉树/173.二叉搜索树迭代器)\n[199.二叉树的右视图](/leetcode/二叉树/199.二叉树的右视图)\n[226.翻转二叉树](/leetcode/二叉树/226.翻转二叉树)\n[230.二叉搜索树中第K小的元素](/leetcode/二叉树/230.二叉搜索树中第K小的元素)\n[235.二叉搜索树的最近公共祖先](/leetcode/二叉树/235.二叉搜索树的最近公共祖先)\n[236.二叉树的最近公共祖先](/leetcode/二叉树/236.二叉树的最近公共祖先)\n[257.二叉树的所有路径](/leetcode/二叉树/257.二叉树的所有路径)\n[297.二叉树的序列化与反序列化](/leetcode/二叉树/297.二叉树的序列化与反序列化)\n[331.验证二叉树的前序序列化](/leetcode/二叉树/331.验证二叉树的前序序列化)\n[337.打家劫舍III](/leetcode/二叉树/337.打家劫舍III)\n[341.扁平化嵌套列表迭代器](/leetcode/二叉树/341.扁平化嵌套列表迭代器)\n[404.左叶子之和](/leetcode/二叉树/404.左叶子之和)\n[429.N叉树的层序遍历](/leetcode/二叉树/429.N叉树的层序遍历)\n[437.路径总和III](/leetcode/二叉树/437.路径总和III)\n[449.序列化和反序列化二叉搜索树](/leetcode/二叉树/449.序列化和反序列化二叉搜索树)\n[450.删除二叉搜索树中的节点](/leetcode/二叉树/450.删除二叉搜索树中的节点)\n[501.二叉搜索树中的众数](/leetcode/二叉树/501.二叉搜索树中的众数)\n[508.出现次数最多的子树元素和](/leetcode/二叉树/508.出现次数最多的子树元素和)\n[513.找树左下角的值](/leetcode/二叉树/513.找树左下角的值)\n[515.在每个树行中找最大值](/leetcode/二叉树/515.在每个树行中找最大值)\n[530.二叉搜索树的最小绝对差](/leetcode/二叉树/530.二叉搜索树的最小绝对差)\n[538.把二叉搜索树转换为累加树](/leetcode/二叉树/538.把二叉搜索树转换为累加树)\n[543.二叉树的直径](/leetcode/二叉树/543.二叉树的直径)\n[559.N叉树的最大深度](/leetcode/二叉树/559.N叉树的最大深度)\n[563.二叉树的坡度](/leetcode/二叉树/563.二叉树的坡度)\n[572.另一个树的子树](/leetcode/二叉树/572.另一个树的子树)\n[589.N叉树的前序遍历](/leetcode/二叉树/589.N叉树的前序遍历)\n[590.N叉树的后序遍历](/leetcode/二叉树/590.N叉树的后序遍历)\n[606.根据二叉树创建字符串](/leetcode/二叉树/606.根据二叉树创建字符串)\n[617.合并二叉树](/leetcode/二叉树/617.合并二叉树)\n[623.在二叉树中增加一行](/leetcode/二叉树/623.在二叉树中增加一行)\n[637.二叉树的层平均值](/leetcode/二叉树/637.二叉树的层平均值)\n[652.寻找重复的子树](/leetcode/二叉树/652.寻找重复的子树)\n[653.两数之和IV-输入BST](/leetcode/二叉树/653.两数之和IV-输入BST)\n[654.最大二叉树](/leetcode/二叉树/654.最大二叉树)\n[655.输出二叉树](/leetcode/二叉树/655.输出二叉树)\n[662.二叉树最大宽度](/leetcode/二叉树/662.二叉树最大宽度)\n[669.修剪二叉搜索树](/leetcode/二叉树/669.修剪二叉搜索树)\n[671.二叉树中第二小的节点](/leetcode/二叉树/671.二叉树中第二小的节点)\n[684.冗余连接](/leetcode/二叉树/684.冗余连接)\n[685.冗余连接II](/leetcode/二叉树/685.冗余连接II)\n[687.最长同值路径](/leetcode/二叉树/687.最长同值路径)\n[700.二叉搜索树中的搜索](/leetcode/二叉树/700.二叉搜索树中的搜索)\n[701.二叉搜索树中的插入操作](/leetcode/二叉树/701.二叉搜索树中的插入操作)\n[703.数据流中的第K大元素](/leetcode/二叉树/703.数据流中的第K大元素)\n[814.二叉树剪枝](/leetcode/二叉树/814.二叉树剪枝)\n[863.二叉树中所有距离为K的结点](/leetcode/二叉树/863.二叉树中所有距离为K的结点)\n[865.具有所有最深节点的最小子树](/leetcode/二叉树/865.具有所有最深节点的最小子树)\n[872.叶子相似的树](/leetcode/二叉树/872.叶子相似的树)\n[889.根据前序和后序遍历构造二叉树](/leetcode/二叉树/889.根据前序和后序遍历构造二叉树)\n[894.所有可能的满二叉树](/leetcode/二叉树/894.所有可能的满二叉树)\n[897.递增顺序搜索树](/leetcode/二叉树/897.递增顺序搜索树)\n[919.完全二叉树插入器](/leetcode/二叉树/919.完全二叉树插入器)\n[938.二叉搜索树的范围和](/leetcode/二叉树/938.二叉搜索树的范围和)\n[94.二叉树的中序遍历](/leetcode/二叉树/94.二叉树的中序遍历)\n[95.不同的二叉搜索树II](/leetcode/二叉树/95.不同的二叉搜索树II)\n[951.翻转等价二叉树](/leetcode/二叉树/951.翻转等价二叉树)\n[958.二叉树的完全性检验](/leetcode/二叉树/958.二叉树的完全性检验)\n[98.验证二叉搜索树](/leetcode/二叉树/98.验证二叉搜索树)\n[988.从叶结点开始的最小字符串](/leetcode/二叉树/988.从叶结点开始的最小字符串)\n[99.恢复二叉搜索树](/leetcode/二叉树/99.恢复二叉搜索树)\n[993.二叉树的堂兄弟节点](/leetcode/二叉树/993.二叉树的堂兄弟节点)\n[998.最大二叉树II](/leetcode/二叉树/998.最大二叉树II)\n[二叉树的遍历方式](/leetcode/二叉树/二叉树的遍历方式)\n","source":"leetcode/二叉树/index.md","raw":"---\ntitle: 二叉树\n---\n[100.相同的树](/leetcode/二叉树/100.相同的树)\n[1008.前序遍历构造二叉搜索树](/leetcode/二叉树/1008.前序遍历构造二叉搜索树)\n[101.对称二叉树](/leetcode/二叉树/101.对称二叉树)\n[102.二叉树的层序遍历](/leetcode/二叉树/102.二叉树的层序遍历)\n[1022.从根到叶的二进制数之和](/leetcode/二叉树/1022.从根到叶的二进制数之和)\n[1026.节点与其祖先之间的最大差值](/leetcode/二叉树/1026.节点与其祖先之间的最大差值)\n[103.二叉树的锯齿形层序遍历](/leetcode/二叉树/103.二叉树的锯齿形层序遍历)\n[1038.把二叉搜索树转换为累加树](/leetcode/二叉树/1038.把二叉搜索树转换为累加树)\n[104.二叉树的最大深度](/leetcode/二叉树/104.二叉树的最大深度)\n[105.从前序与中序遍历序列构造二叉树](/leetcode/二叉树/105.从前序与中序遍历序列构造二叉树)\n[106.从中序与后序遍历序列构造二叉树](/leetcode/二叉树/106.从中序与后序遍历序列构造二叉树)\n[107.二叉树的层序遍历II](/leetcode/二叉树/107.二叉树的层序遍历II)\n[108.将有序数组转换为二叉搜索树](/leetcode/二叉树/108.将有序数组转换为二叉搜索树)\n[1080.根到叶路径上的不足节点](/leetcode/二叉树/1080.根到叶路径上的不足节点)\n[109.有序链表转换二叉搜索树](/leetcode/二叉树/109.有序链表转换二叉搜索树)\n[110.平衡二叉树](/leetcode/二叉树/110.平衡二叉树)\n[1104.二叉树寻路](/leetcode/二叉树/1104.二叉树寻路)\n[111.二叉树的最小深度](/leetcode/二叉树/111.二叉树的最小深度)\n[1110.删点成林](/leetcode/二叉树/1110.删点成林)\n[112.路径总和](/leetcode/二叉树/112.路径总和)\n[1123.最深叶节点的最近公共祖先](/leetcode/二叉树/1123.最深叶节点的最近公共祖先)\n[113.路径总和II](/leetcode/二叉树/113.路径总和II)\n[114.二叉树展开为链表](/leetcode/二叉树/114.二叉树展开为链表)\n[1145.二叉树着色游戏](/leetcode/二叉树/1145.二叉树着色游戏)\n[116.填充每个节点的下一个右侧节点指针](/leetcode/二叉树/116.填充每个节点的下一个右侧节点指针)\n[1161.最大层内元素和](/leetcode/二叉树/1161.最大层内元素和)\n[117.填充每个节点的下一个右侧节点指针II](/leetcode/二叉树/117.填充每个节点的下一个右侧节点指针II)\n[124.二叉树中的最大路径和](/leetcode/二叉树/124.二叉树中的最大路径和)\n[1261.在受污染的二叉树中查找元素](/leetcode/二叉树/1261.在受污染的二叉树中查找元素)\n[129.求根节点到叶节点数字之和](/leetcode/二叉树/129.求根节点到叶节点数字之和)\n[1302.层数最深叶子节点的和](/leetcode/二叉树/1302.层数最深叶子节点的和)\n[1305.两棵二叉搜索树中的所有元素](/leetcode/二叉树/1305.两棵二叉搜索树中的所有元素)\n[1315.祖父节点值为偶数的节点和](/leetcode/二叉树/1315.祖父节点值为偶数的节点和)\n[1325.删除给定值的叶子节点](/leetcode/二叉树/1325.删除给定值的叶子节点)\n[1339.分裂二叉树的最大乘积](/leetcode/二叉树/1339.分裂二叉树的最大乘积)\n[1361.验证二叉树](/leetcode/二叉树/1361.验证二叉树)\n[1367.二叉树中的列表](/leetcode/二叉树/1367.二叉树中的列表)\n[1376.通知所有员工所需的时间](/leetcode/二叉树/1376.通知所有员工所需的时间)\n[1379.找出克隆二叉树中的相同节点](/leetcode/二叉树/1379.找出克隆二叉树中的相同节点)\n[1382.将二叉搜索树变平衡](/leetcode/二叉树/1382.将二叉搜索树变平衡)\n[144.二叉树的前序遍历](/leetcode/二叉树/144.二叉树的前序遍历)\n[1448.统计二叉树中好节点的数目](/leetcode/二叉树/1448.统计二叉树中好节点的数目)\n[145.二叉树的后序遍历](/leetcode/二叉树/145.二叉树的后序遍历)\n[1457.二叉树中的伪回文路径](/leetcode/二叉树/1457.二叉树中的伪回文路径)\n[173.二叉搜索树迭代器](/leetcode/二叉树/173.二叉搜索树迭代器)\n[199.二叉树的右视图](/leetcode/二叉树/199.二叉树的右视图)\n[226.翻转二叉树](/leetcode/二叉树/226.翻转二叉树)\n[230.二叉搜索树中第K小的元素](/leetcode/二叉树/230.二叉搜索树中第K小的元素)\n[235.二叉搜索树的最近公共祖先](/leetcode/二叉树/235.二叉搜索树的最近公共祖先)\n[236.二叉树的最近公共祖先](/leetcode/二叉树/236.二叉树的最近公共祖先)\n[257.二叉树的所有路径](/leetcode/二叉树/257.二叉树的所有路径)\n[297.二叉树的序列化与反序列化](/leetcode/二叉树/297.二叉树的序列化与反序列化)\n[331.验证二叉树的前序序列化](/leetcode/二叉树/331.验证二叉树的前序序列化)\n[337.打家劫舍III](/leetcode/二叉树/337.打家劫舍III)\n[341.扁平化嵌套列表迭代器](/leetcode/二叉树/341.扁平化嵌套列表迭代器)\n[404.左叶子之和](/leetcode/二叉树/404.左叶子之和)\n[429.N叉树的层序遍历](/leetcode/二叉树/429.N叉树的层序遍历)\n[437.路径总和III](/leetcode/二叉树/437.路径总和III)\n[449.序列化和反序列化二叉搜索树](/leetcode/二叉树/449.序列化和反序列化二叉搜索树)\n[450.删除二叉搜索树中的节点](/leetcode/二叉树/450.删除二叉搜索树中的节点)\n[501.二叉搜索树中的众数](/leetcode/二叉树/501.二叉搜索树中的众数)\n[508.出现次数最多的子树元素和](/leetcode/二叉树/508.出现次数最多的子树元素和)\n[513.找树左下角的值](/leetcode/二叉树/513.找树左下角的值)\n[515.在每个树行中找最大值](/leetcode/二叉树/515.在每个树行中找最大值)\n[530.二叉搜索树的最小绝对差](/leetcode/二叉树/530.二叉搜索树的最小绝对差)\n[538.把二叉搜索树转换为累加树](/leetcode/二叉树/538.把二叉搜索树转换为累加树)\n[543.二叉树的直径](/leetcode/二叉树/543.二叉树的直径)\n[559.N叉树的最大深度](/leetcode/二叉树/559.N叉树的最大深度)\n[563.二叉树的坡度](/leetcode/二叉树/563.二叉树的坡度)\n[572.另一个树的子树](/leetcode/二叉树/572.另一个树的子树)\n[589.N叉树的前序遍历](/leetcode/二叉树/589.N叉树的前序遍历)\n[590.N叉树的后序遍历](/leetcode/二叉树/590.N叉树的后序遍历)\n[606.根据二叉树创建字符串](/leetcode/二叉树/606.根据二叉树创建字符串)\n[617.合并二叉树](/leetcode/二叉树/617.合并二叉树)\n[623.在二叉树中增加一行](/leetcode/二叉树/623.在二叉树中增加一行)\n[637.二叉树的层平均值](/leetcode/二叉树/637.二叉树的层平均值)\n[652.寻找重复的子树](/leetcode/二叉树/652.寻找重复的子树)\n[653.两数之和IV-输入BST](/leetcode/二叉树/653.两数之和IV-输入BST)\n[654.最大二叉树](/leetcode/二叉树/654.最大二叉树)\n[655.输出二叉树](/leetcode/二叉树/655.输出二叉树)\n[662.二叉树最大宽度](/leetcode/二叉树/662.二叉树最大宽度)\n[669.修剪二叉搜索树](/leetcode/二叉树/669.修剪二叉搜索树)\n[671.二叉树中第二小的节点](/leetcode/二叉树/671.二叉树中第二小的节点)\n[684.冗余连接](/leetcode/二叉树/684.冗余连接)\n[685.冗余连接II](/leetcode/二叉树/685.冗余连接II)\n[687.最长同值路径](/leetcode/二叉树/687.最长同值路径)\n[700.二叉搜索树中的搜索](/leetcode/二叉树/700.二叉搜索树中的搜索)\n[701.二叉搜索树中的插入操作](/leetcode/二叉树/701.二叉搜索树中的插入操作)\n[703.数据流中的第K大元素](/leetcode/二叉树/703.数据流中的第K大元素)\n[814.二叉树剪枝](/leetcode/二叉树/814.二叉树剪枝)\n[863.二叉树中所有距离为K的结点](/leetcode/二叉树/863.二叉树中所有距离为K的结点)\n[865.具有所有最深节点的最小子树](/leetcode/二叉树/865.具有所有最深节点的最小子树)\n[872.叶子相似的树](/leetcode/二叉树/872.叶子相似的树)\n[889.根据前序和后序遍历构造二叉树](/leetcode/二叉树/889.根据前序和后序遍历构造二叉树)\n[894.所有可能的满二叉树](/leetcode/二叉树/894.所有可能的满二叉树)\n[897.递增顺序搜索树](/leetcode/二叉树/897.递增顺序搜索树)\n[919.完全二叉树插入器](/leetcode/二叉树/919.完全二叉树插入器)\n[938.二叉搜索树的范围和](/leetcode/二叉树/938.二叉搜索树的范围和)\n[94.二叉树的中序遍历](/leetcode/二叉树/94.二叉树的中序遍历)\n[95.不同的二叉搜索树II](/leetcode/二叉树/95.不同的二叉搜索树II)\n[951.翻转等价二叉树](/leetcode/二叉树/951.翻转等价二叉树)\n[958.二叉树的完全性检验](/leetcode/二叉树/958.二叉树的完全性检验)\n[98.验证二叉搜索树](/leetcode/二叉树/98.验证二叉搜索树)\n[988.从叶结点开始的最小字符串](/leetcode/二叉树/988.从叶结点开始的最小字符串)\n[99.恢复二叉搜索树](/leetcode/二叉树/99.恢复二叉搜索树)\n[993.二叉树的堂兄弟节点](/leetcode/二叉树/993.二叉树的堂兄弟节点)\n[998.最大二叉树II](/leetcode/二叉树/998.最大二叉树II)\n[二叉树的遍历方式](/leetcode/二叉树/二叉树的遍历方式)\n","date":"2023-10-11T15:15:20.522Z","updated":"2023-10-11T15:15:20.522Z","path":"leetcode/二叉树/index.html","_id":"cln0gazop0001niw78ilt1wk6","comments":1,"layout":"page","content":"<p><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91\">100.相同的树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1008.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">1008.前序遍历构造二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91\">101.对称二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">102.二叉树的层序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1022.%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C\">1022.从根到叶的二进制数之和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1026.%E8%8A%82%E7%82%B9%E4%B8%8E%E5%85%B6%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC\">1026.节点与其祖先之间的最大差值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">103.二叉树的锯齿形层序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1038.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91\">1038.把二叉搜索树转换为累加树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6\">104.二叉树的最大深度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">105.从前序与中序遍历序列构造二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">106.从中序与后序遍历序列构造二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II\">107.二叉树的层序遍历II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">108.将有序数组转换为二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1080.%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9\">1080.根到叶路径上的不足节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">109.有序链表转换二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">110.平衡二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1104.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF\">1104.二叉树寻路</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6\">111.二叉树的最小深度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1110.%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97\">1110.删点成林</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C\">112.路径总和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1123.%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">1123.最深叶节点的最近公共祖先</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII\">113.路径总和II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8\">114.二叉树展开为链表</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F\">1145.二叉树着色游戏</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88\">116.填充每个节点的下一个右侧节点指针</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1161.%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C\">1161.最大层内元素和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/117.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II\">117.填充每个节点的下一个右侧节点指针II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C\">124.二叉树中的最大路径和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1261.%E5%9C%A8%E5%8F%97%E6%B1%A1%E6%9F%93%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0\">1261.在受污染的二叉树中查找元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C\">129.求根节点到叶节点数字之和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1302.%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C\">1302.层数最深叶子节点的和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1305.%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0\">1305.两棵二叉搜索树中的所有元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1315.%E7%A5%96%E7%88%B6%E8%8A%82%E7%82%B9%E5%80%BC%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C\">1315.祖父节点值为偶数的节点和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1325.%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9\">1325.删除给定值的叶子节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1339.%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF\">1339.分裂二叉树的最大乘积</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1361.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91\">1361.验证二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1367.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8\">1367.二叉树中的列表</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1376.%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4\">1376.通知所有员工所需的时间</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1379.%E6%89%BE%E5%87%BA%E5%85%8B%E9%9A%86%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9\">1379.找出克隆二叉树中的相同节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1382.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1\">1382.将二叉搜索树变平衡</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">144.二叉树的前序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1448.%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE\">1448.统计二叉树中好节点的数目</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\">145.二叉树的后序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1457.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84\">1457.二叉树中的伪回文路径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8\">173.二叉搜索树迭代器</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE\">199.二叉树的右视图</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91\">226.翻转二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0\">230.二叉搜索树中第K小的元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">235.二叉搜索树的最近公共祖先</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">236.二叉树的最近公共祖先</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84\">257.二叉树的所有路径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\">297.二叉树的序列化与反序列化</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/331.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96\">331.验证二叉树的前序序列化</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII\">337.打家劫舍III</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/341.%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8\">341.扁平化嵌套列表迭代器</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C\">404.左叶子之和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/429.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">429.N叉树的层序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII\">437.路径总和III</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/449.%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">449.序列化和反序列化二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9\">450.删除二叉搜索树中的节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0\">501.二叉搜索树中的众数</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/508.%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C\">508.出现次数最多的子树元素和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC\">513.找树左下角的值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/515.%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC\">515.在每个树行中找最大值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE\">530.二叉搜索树的最小绝对差</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91\">538.把二叉搜索树转换为累加树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84\">543.二叉树的直径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/559.N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6\">559.N叉树的最大深度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/563.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6\">563.二叉树的坡度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91\">572.另一个树的子树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/589.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">589.N叉树的前序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/590.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\">590.N叉树的后序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/606.%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\">606.根据二叉树创建字符串</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91\">617.合并二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/623.%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C\">623.在二叉树中增加一行</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/637.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC\">637.二叉树的层平均值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/652.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91\">652.寻找重复的子树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/653.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST\">653.两数之和IV-输入BST</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91\">654.最大二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/655.%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91\">655.输出二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6\">662.二叉树最大宽度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">669.修剪二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/671.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9\">671.二叉树中第二小的节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/684.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5\">684.冗余连接</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II\">685.冗余连接II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/687.%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84\">687.最长同值路径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2\">700.二叉搜索树中的搜索</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\">701.二叉搜索树中的插入操作</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/703.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0\">703.数据流中的第K大元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/814.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D\">814.二叉树剪枝</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/863.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BAK%E7%9A%84%E7%BB%93%E7%82%B9\">863.二叉树中所有距离为K的结点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/865.%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91\">865.具有所有最深节点的最小子树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/872.%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91\">872.叶子相似的树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/889.%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">889.根据前序和后序遍历构造二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/894.%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">894.所有可能的满二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/897.%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91\">897.递增顺序搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/919.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8\">919.完全二叉树插入器</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C\">938.二叉搜索树的范围和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">94.二叉树的中序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/95.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II\">95.不同的二叉搜索树II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/951.%E7%BF%BB%E8%BD%AC%E7%AD%89%E4%BB%B7%E4%BA%8C%E5%8F%89%E6%A0%91\">951.翻转等价二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/958.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C\">958.二叉树的完全性检验</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">98.验证二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/988.%E4%BB%8E%E5%8F%B6%E7%BB%93%E7%82%B9%E5%BC%80%E5%A7%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2\">988.从叶结点开始的最小字符串</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">99.恢复二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/993.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9\">993.二叉树的堂兄弟节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/998.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91II\">998.最大二叉树II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\">二叉树的遍历方式</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91\">100.相同的树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1008.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">1008.前序遍历构造二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91\">101.对称二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">102.二叉树的层序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1022.%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C\">1022.从根到叶的二进制数之和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1026.%E8%8A%82%E7%82%B9%E4%B8%8E%E5%85%B6%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC\">1026.节点与其祖先之间的最大差值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">103.二叉树的锯齿形层序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1038.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91\">1038.把二叉搜索树转换为累加树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6\">104.二叉树的最大深度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">105.从前序与中序遍历序列构造二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">106.从中序与后序遍历序列构造二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/107.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II\">107.二叉树的层序遍历II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">108.将有序数组转换为二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1080.%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9\">1080.根到叶路径上的不足节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">109.有序链表转换二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">110.平衡二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1104.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF\">1104.二叉树寻路</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6\">111.二叉树的最小深度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1110.%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97\">1110.删点成林</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C\">112.路径总和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1123.%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">1123.最深叶节点的最近公共祖先</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII\">113.路径总和II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8\">114.二叉树展开为链表</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F\">1145.二叉树着色游戏</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88\">116.填充每个节点的下一个右侧节点指针</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1161.%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C\">1161.最大层内元素和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/117.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II\">117.填充每个节点的下一个右侧节点指针II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C\">124.二叉树中的最大路径和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1261.%E5%9C%A8%E5%8F%97%E6%B1%A1%E6%9F%93%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0\">1261.在受污染的二叉树中查找元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/129.%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C\">129.求根节点到叶节点数字之和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1302.%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C\">1302.层数最深叶子节点的和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1305.%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0\">1305.两棵二叉搜索树中的所有元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1315.%E7%A5%96%E7%88%B6%E8%8A%82%E7%82%B9%E5%80%BC%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C\">1315.祖父节点值为偶数的节点和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1325.%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9\">1325.删除给定值的叶子节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1339.%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF\">1339.分裂二叉树的最大乘积</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1361.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91\">1361.验证二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1367.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8\">1367.二叉树中的列表</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1376.%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4\">1376.通知所有员工所需的时间</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1379.%E6%89%BE%E5%87%BA%E5%85%8B%E9%9A%86%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9\">1379.找出克隆二叉树中的相同节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1382.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1\">1382.将二叉搜索树变平衡</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">144.二叉树的前序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1448.%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE\">1448.统计二叉树中好节点的数目</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\">145.二叉树的后序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/1457.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84\">1457.二叉树中的伪回文路径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8\">173.二叉搜索树迭代器</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE\">199.二叉树的右视图</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91\">226.翻转二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0\">230.二叉搜索树中第K小的元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">235.二叉搜索树的最近公共祖先</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">236.二叉树的最近公共祖先</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84\">257.二叉树的所有路径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\">297.二叉树的序列化与反序列化</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/331.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96\">331.验证二叉树的前序序列化</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII\">337.打家劫舍III</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/341.%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8\">341.扁平化嵌套列表迭代器</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C\">404.左叶子之和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/429.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">429.N叉树的层序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII\">437.路径总和III</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/449.%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">449.序列化和反序列化二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9\">450.删除二叉搜索树中的节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0\">501.二叉搜索树中的众数</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/508.%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C\">508.出现次数最多的子树元素和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC\">513.找树左下角的值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/515.%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC\">515.在每个树行中找最大值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE\">530.二叉搜索树的最小绝对差</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91\">538.把二叉搜索树转换为累加树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84\">543.二叉树的直径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/559.N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6\">559.N叉树的最大深度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/563.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6\">563.二叉树的坡度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91\">572.另一个树的子树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/589.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">589.N叉树的前序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/590.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\">590.N叉树的后序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/606.%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\">606.根据二叉树创建字符串</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91\">617.合并二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/623.%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C\">623.在二叉树中增加一行</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/637.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC\">637.二叉树的层平均值</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/652.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91\">652.寻找重复的子树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/653.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CIV-%E8%BE%93%E5%85%A5BST\">653.两数之和IV-输入BST</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91\">654.最大二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/655.%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91\">655.输出二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6\">662.二叉树最大宽度</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">669.修剪二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/671.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9\">671.二叉树中第二小的节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/684.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5\">684.冗余连接</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II\">685.冗余连接II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/687.%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84\">687.最长同值路径</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2\">700.二叉搜索树中的搜索</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\">701.二叉搜索树中的插入操作</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/703.%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0\">703.数据流中的第K大元素</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/814.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D\">814.二叉树剪枝</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/863.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BAK%E7%9A%84%E7%BB%93%E7%82%B9\">863.二叉树中所有距离为K的结点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/865.%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91\">865.具有所有最深节点的最小子树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/872.%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91\">872.叶子相似的树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/889.%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">889.根据前序和后序遍历构造二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/894.%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">894.所有可能的满二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/897.%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91\">897.递增顺序搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/919.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8\">919.完全二叉树插入器</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C\">938.二叉搜索树的范围和</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">94.二叉树的中序遍历</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/95.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II\">95.不同的二叉搜索树II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/951.%E7%BF%BB%E8%BD%AC%E7%AD%89%E4%BB%B7%E4%BA%8C%E5%8F%89%E6%A0%91\">951.翻转等价二叉树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/958.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C\">958.二叉树的完全性检验</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">98.验证二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/988.%E4%BB%8E%E5%8F%B6%E7%BB%93%E7%82%B9%E5%BC%80%E5%A7%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2\">988.从叶结点开始的最小字符串</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">99.恢复二叉搜索树</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/993.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9\">993.二叉树的堂兄弟节点</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/998.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91II\">998.最大二叉树II</a><br><a href=\"/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\">二叉树的遍历方式</a></p>\n"},{"title":"链表","_content":"[234.回文链表](/leetcode/链表/234.回文链表)\n[25.K个一组翻转链表](/leetcode/链表/25.K个一组翻转链表)\n[92.反转列表II](/leetcode/链表/92.反转列表II)\n[链表的遍历方式](/leetcode/链表/链表的遍历方式)\n","source":"leetcode/链表/index.md","raw":"---\ntitle: 链表\n---\n[234.回文链表](/leetcode/链表/234.回文链表)\n[25.K个一组翻转链表](/leetcode/链表/25.K个一组翻转链表)\n[92.反转列表II](/leetcode/链表/92.反转列表II)\n[链表的遍历方式](/leetcode/链表/链表的遍历方式)\n","date":"2023-10-11T15:15:20.522Z","updated":"2023-10-11T15:15:20.522Z","path":"leetcode/链表/index.html","_id":"cln0gb2is0002niw72pbxgv1g","comments":1,"layout":"page","content":"<p><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8\">234.回文链表</a><br><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/25.K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8\">25.K个一组翻转链表</a><br><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/92.%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8II\">92.反转列表II</a><br><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\">链表的遍历方式</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8\">234.回文链表</a><br><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/25.K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8\">25.K个一组翻转链表</a><br><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/92.%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8II\">92.反转列表II</a><br><a href=\"/leetcode/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\">链表的遍历方式</a></p>\n"},{"title":"面试经典150题","_content":"[12.整数转罗马数字](/leetcode/面试经典150题/12.整数转罗马数字)\n[121.买卖股票的最佳时机](/leetcode/面试经典150题/121.买卖股票的最佳时机)\n[122.买卖股票的最佳时机II](/leetcode/面试经典150题/122.买卖股票的最佳时机II)\n[125.验证回文串](/leetcode/面试经典150题/125.验证回文串)\n[13.罗马数字转整数](/leetcode/面试经典150题/13.罗马数字转整数)\n[134.加油站](/leetcode/面试经典150题/134.加油站)\n[14.最长公共前缀](/leetcode/面试经典150题/14.最长公共前缀)\n[151.反转字符串中的单词](/leetcode/面试经典150题/151.反转字符串中的单词)\n[167.两数之和II-输入有序数组](/leetcode/面试经典150题/167.两数之和II-输入有序数组)\n[169.多数元素](/leetcode/面试经典150题/169.多数元素)\n[189.轮转数组](/leetcode/面试经典150题/189.轮转数组)\n[26.删除有序数组中的重复项](/leetcode/面试经典150题/26.删除有序数组中的重复项)\n[27.移除元素](/leetcode/面试经典150题/27.移除元素)\n[380.O(1)时间插入、删除和获取随机元素](/leetcode/面试经典150题/380.O(1)时间插入、删除和获取随机元素)\n[392.判断子序列](/leetcode/面试经典150题/392.判断子序列)\n[45.跳跃游戏II](/leetcode/面试经典150题/45.跳跃游戏II)\n[55.跳跃游戏](/leetcode/面试经典150题/55.跳跃游戏)\n[58.最后一个单词的长度](/leetcode/面试经典150题/58.最后一个单词的长度)\n[6.N字形变换](/leetcode/面试经典150题/6.N字形变换)\n[80.删除有序数组中的重复项II](/leetcode/面试经典150题/80.删除有序数组中的重复项II)\n[88.合并两个有序数组](/leetcode/面试经典150题/88.合并两个有序数组)\n","source":"leetcode/面试经典150题/index.md","raw":"---\ntitle: 面试经典150题\n---\n[12.整数转罗马数字](/leetcode/面试经典150题/12.整数转罗马数字)\n[121.买卖股票的最佳时机](/leetcode/面试经典150题/121.买卖股票的最佳时机)\n[122.买卖股票的最佳时机II](/leetcode/面试经典150题/122.买卖股票的最佳时机II)\n[125.验证回文串](/leetcode/面试经典150题/125.验证回文串)\n[13.罗马数字转整数](/leetcode/面试经典150题/13.罗马数字转整数)\n[134.加油站](/leetcode/面试经典150题/134.加油站)\n[14.最长公共前缀](/leetcode/面试经典150题/14.最长公共前缀)\n[151.反转字符串中的单词](/leetcode/面试经典150题/151.反转字符串中的单词)\n[167.两数之和II-输入有序数组](/leetcode/面试经典150题/167.两数之和II-输入有序数组)\n[169.多数元素](/leetcode/面试经典150题/169.多数元素)\n[189.轮转数组](/leetcode/面试经典150题/189.轮转数组)\n[26.删除有序数组中的重复项](/leetcode/面试经典150题/26.删除有序数组中的重复项)\n[27.移除元素](/leetcode/面试经典150题/27.移除元素)\n[380.O(1)时间插入、删除和获取随机元素](/leetcode/面试经典150题/380.O(1)时间插入、删除和获取随机元素)\n[392.判断子序列](/leetcode/面试经典150题/392.判断子序列)\n[45.跳跃游戏II](/leetcode/面试经典150题/45.跳跃游戏II)\n[55.跳跃游戏](/leetcode/面试经典150题/55.跳跃游戏)\n[58.最后一个单词的长度](/leetcode/面试经典150题/58.最后一个单词的长度)\n[6.N字形变换](/leetcode/面试经典150题/6.N字形变换)\n[80.删除有序数组中的重复项II](/leetcode/面试经典150题/80.删除有序数组中的重复项II)\n[88.合并两个有序数组](/leetcode/面试经典150题/88.合并两个有序数组)\n","date":"2023-10-11T15:15:20.522Z","updated":"2023-10-11T15:15:20.522Z","path":"leetcode/面试经典150题/index.html","_id":"cln0gb5160003niw7bytq4k6z","comments":1,"layout":"page","content":"<p><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97\">12.整数转罗马数字</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA\">121.买卖股票的最佳时机</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII\">122.买卖股票的最佳时机II</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2\">125.验证回文串</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0\">13.罗马数字转整数</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/134.%E5%8A%A0%E6%B2%B9%E7%AB%99\">134.加油站</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80\">14.最长公共前缀</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/151.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D\">151.反转字符串中的单词</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84\">167.两数之和II-输入有序数组</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0\">169.多数元素</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/189.%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84\">189.轮转数组</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/26.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9\">26.删除有序数组中的重复项</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0\">27.移除元素</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/380.O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0\">380.O(1)时间插入、删除和获取随机元素</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97\">392.判断子序列</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII\">45.跳跃游戏II</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F\">55.跳跃游戏</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6\">58.最后一个单词的长度</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/6.N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2\">6.N字形变换</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/80.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II\">80.删除有序数组中的重复项II</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84\">88.合并两个有序数组</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97\">12.整数转罗马数字</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA\">121.买卖股票的最佳时机</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII\">122.买卖股票的最佳时机II</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/125.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2\">125.验证回文串</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0\">13.罗马数字转整数</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/134.%E5%8A%A0%E6%B2%B9%E7%AB%99\">134.加油站</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80\">14.最长公共前缀</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/151.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D\">151.反转字符串中的单词</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84\">167.两数之和II-输入有序数组</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0\">169.多数元素</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/189.%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84\">189.轮转数组</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/26.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9\">26.删除有序数组中的重复项</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0\">27.移除元素</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/380.O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0\">380.O(1)时间插入、删除和获取随机元素</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97\">392.判断子序列</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII\">45.跳跃游戏II</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F\">55.跳跃游戏</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6\">58.最后一个单词的长度</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/6.N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2\">6.N字形变换</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/80.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II\">80.删除有序数组中的重复项II</a><br><a href=\"/leetcode/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84\">88.合并两个有序数组</a></p>\n"},{"title":"算法实现","_content":"[LRU](/leetcode/算法实现/LRU)\n","source":"leetcode/算法实现/index.md","raw":"---\ntitle: 算法实现\n---\n[LRU](/leetcode/算法实现/LRU)\n","date":"2023-10-11T15:15:20.522Z","updated":"2023-10-11T15:15:20.522Z","path":"leetcode/算法实现/index.html","_id":"cln0gb7zs0004niw7bl59bdda","comments":1,"layout":"page","content":"<p><a href=\"/leetcode/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/LRU\">LRU</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><a href=\"/leetcode/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/LRU\">LRU</a></p>\n"},{"_content":"# 118. 杨辉三角\n\n给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。\n\n[链接](https://leetcode-cn.com/problems/pascals-triangle/)\n\n```ts\nfunction generate(numRows: number): number[][] {\n  const dpTable: number[][] = Array.from(Array(numRows), (_data, index) => {\n    const arr = Array(index + 1).fill(0);\n    arr[0] = 1;\n    arr[arr.length - 1] = 1;\n    return arr;\n  });\n  for(let i = 2; i < numRows; i++) {\n    const len = dpTable[i].length - 1;\n    const preArr = dpTable[i - 1];\n    for(let j = 1; j < len; j++) {\n      dpTable[i][j] = preArr[j] + preArr[j - 1];\n    }\n  }\n  return dpTable;\n};\n```\n","source":"leetcode/动态规划/118.杨辉三角.md","raw":"# 118. 杨辉三角\n\n给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。\n\n[链接](https://leetcode-cn.com/problems/pascals-triangle/)\n\n```ts\nfunction generate(numRows: number): number[][] {\n  const dpTable: number[][] = Array.from(Array(numRows), (_data, index) => {\n    const arr = Array(index + 1).fill(0);\n    arr[0] = 1;\n    arr[arr.length - 1] = 1;\n    return arr;\n  });\n  for(let i = 2; i < numRows; i++) {\n    const len = dpTable[i].length - 1;\n    const preArr = dpTable[i - 1];\n    for(let j = 1; j < len; j++) {\n      dpTable[i][j] = preArr[j] + preArr[j - 1];\n    }\n  }\n  return dpTable;\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.528Z","path":"leetcode/动态规划/118.杨辉三角.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxi0001tnw7edni9utw","content":"<h1 id=\"118-杨辉三角\"><a href=\"#118-杨辉三角\" class=\"headerlink\" title=\"118. 杨辉三角\"></a>118. 杨辉三角</h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>\n<p><a href=\"https://leetcode-cn.com/problems/pascals-triangle/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">generate</span>(<span class=\"params\">numRows: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"built_in\">number</span>[][] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(numRows), <span class=\"function\">(<span class=\"params\">_data, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> arr = <span class=\"title class_\">Array</span>(index + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    arr[arr.<span class=\"property\">length</span> - <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; numRows; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = dpTable[i].<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> preArr = dpTable[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      dpTable[i][j] = preArr[j] + preArr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dpTable;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"118-杨辉三角\"><a href=\"#118-杨辉三角\" class=\"headerlink\" title=\"118. 杨辉三角\"></a>118. 杨辉三角</h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>\n<p><a href=\"https://leetcode-cn.com/problems/pascals-triangle/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">generate</span>(<span class=\"params\">numRows: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"built_in\">number</span>[][] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(numRows), <span class=\"function\">(<span class=\"params\">_data, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> arr = <span class=\"title class_\">Array</span>(index + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    arr[arr.<span class=\"property\">length</span> - <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; numRows; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = dpTable[i].<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> preArr = dpTable[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      dpTable[i][j] = preArr[j] + preArr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dpTable;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1137. 第 N 个泰波那契数\n\n泰波那契序列 Tn 定义如下：\n\nT0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n\n[链接](https://leetcode-cn.com/problems/n-th-tribonacci-number)\n\n```ts\nfunction tribonacci(n: number): number {\n  const dpTable: Record<number, number> = {};\n  dpTable[0] = 0;\n  dpTable[1] = 1;\n  dpTable[2] = 1;\n  if (n < 3) return dpTable[n];\n  const handleCount = (target: number) => {\n    if (dpTable[target] !== undefined) return dpTable[target]\n    const result = handleCount(target - 2) + handleCount(target - 1) + handleCount(target - 3);\n    dpTable[target] = result;\n    return result;\n  };\n  return handleCount(n);\n};\n```\n","source":"leetcode/动态规划/1137.第N个泰波那契数.md","raw":"# 1137. 第 N 个泰波那契数\n\n泰波那契序列 Tn 定义如下：\n\nT0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n\n[链接](https://leetcode-cn.com/problems/n-th-tribonacci-number)\n\n```ts\nfunction tribonacci(n: number): number {\n  const dpTable: Record<number, number> = {};\n  dpTable[0] = 0;\n  dpTable[1] = 1;\n  dpTable[2] = 1;\n  if (n < 3) return dpTable[n];\n  const handleCount = (target: number) => {\n    if (dpTable[target] !== undefined) return dpTable[target]\n    const result = handleCount(target - 2) + handleCount(target - 1) + handleCount(target - 3);\n    dpTable[target] = result;\n    return result;\n  };\n  return handleCount(n);\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.527Z","path":"leetcode/动态规划/1137.第N个泰波那契数.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxj0002tnw76jvu6swb","content":"<h1 id=\"1137-第-N-个泰波那契数\"><a href=\"#1137-第-N-个泰波那契数\" class=\"headerlink\" title=\"1137. 第 N 个泰波那契数\"></a>1137. 第 N 个泰波那契数</h1><p>泰波那契序列 Tn 定义如下：</p>\n<p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p>\n<p>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">tribonacci</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCount</span> = (<span class=\"params\">target: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[target] !== <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> dpTable[target]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title function_\">handleCount</span>(target - <span class=\"number\">2</span>) + <span class=\"title function_\">handleCount</span>(target - <span class=\"number\">1</span>) + <span class=\"title function_\">handleCount</span>(target - <span class=\"number\">3</span>);</span><br><span class=\"line\">    dpTable[target] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">handleCount</span>(n);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1137-第-N-个泰波那契数\"><a href=\"#1137-第-N-个泰波那契数\" class=\"headerlink\" title=\"1137. 第 N 个泰波那契数\"></a>1137. 第 N 个泰波那契数</h1><p>泰波那契序列 Tn 定义如下：</p>\n<p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p>\n<p>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">tribonacci</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCount</span> = (<span class=\"params\">target: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[target] !== <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> dpTable[target]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title function_\">handleCount</span>(target - <span class=\"number\">2</span>) + <span class=\"title function_\">handleCount</span>(target - <span class=\"number\">1</span>) + <span class=\"title function_\">handleCount</span>(target - <span class=\"number\">3</span>);</span><br><span class=\"line\">    dpTable[target] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">handleCount</span>(n);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 119. 杨辉三角 II\n\n给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。\n\n[链接](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n```ts\nfunction getRow(rowIndex: number): number[] {\n  let dpTable: number[] = [1];\n  for(let i = 1; i <= rowIndex; i++) {\n    const arr: number[] = Array(i + 1).fill(0);\n    arr[0] = 1\n    arr[arr.length - 1] = 1;\n    const len = arr.length - 1;\n    for(let j = 1; j < len; j++) {\n      arr[j] = dpTable[j - 1] + dpTable[j]\n    }\n    dpTable = arr;\n  }\n  return dpTable;\n};\n```\n","source":"leetcode/动态规划/119.杨辉三角II.md","raw":"# 119. 杨辉三角 II\n\n给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。\n\n[链接](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n```ts\nfunction getRow(rowIndex: number): number[] {\n  let dpTable: number[] = [1];\n  for(let i = 1; i <= rowIndex; i++) {\n    const arr: number[] = Array(i + 1).fill(0);\n    arr[0] = 1\n    arr[arr.length - 1] = 1;\n    const len = arr.length - 1;\n    for(let j = 1; j < len; j++) {\n      arr[j] = dpTable[j - 1] + dpTable[j]\n    }\n    dpTable = arr;\n  }\n  return dpTable;\n};\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.529Z","path":"leetcode/动态规划/119.杨辉三角II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxj0003tnw7325hgfd9","content":"<h1 id=\"119-杨辉三角-II\"><a href=\"#119-杨辉三角-II\" class=\"headerlink\" title=\"119. 杨辉三角 II\"></a>119. 杨辉三角 II</h1><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p>\n<p><a href=\"https://leetcode-cn.com/problems/pascals-triangle-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getRow</span>(<span class=\"params\">rowIndex: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">dpTable</span>: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">arr</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Array</span>(i + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    arr[arr.<span class=\"property\">length</span> - <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = arr.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      arr[j] = dpTable[j - <span class=\"number\">1</span>] + dpTable[j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable = arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dpTable;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"119-杨辉三角-II\"><a href=\"#119-杨辉三角-II\" class=\"headerlink\" title=\"119. 杨辉三角 II\"></a>119. 杨辉三角 II</h1><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p>\n<p><a href=\"https://leetcode-cn.com/problems/pascals-triangle-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getRow</span>(<span class=\"params\">rowIndex: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">dpTable</span>: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">arr</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Array</span>(i + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    arr[arr.<span class=\"property\">length</span> - <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = arr.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      arr[j] = dpTable[j - <span class=\"number\">1</span>] + dpTable[j]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable = arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dpTable;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 120. 三角形最小路径和\n\n给定一个三角形 triangle ，找出自顶向下的最小路径和。\n\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n\n[链接](https://leetcode-cn.com/problems/triangle)\n\n- 只用二维数组的情况\n\n```ts\nfunction minimumTotal(triangle: number[][]): number {\n  const len = triangle.length;\n  let dpTable = Array(len).fill(0);\n  dpTable[0] = triangle[0][0];\n  for(let i = 1; i < len; i++) {\n    const _dpTable = Array(len).fill(0);\n    _dpTable[0] = dpTable[0] + triangle[i][0];\n    for(let j = 1; j < i; j++) {\n      _dpTable[j] = Math.min(dpTable[j - 1], dpTable[j]) + triangle[i][j];\n    }\n    _dpTable[i] = dpTable[i - 1] + triangle[i][i];\n    dpTable = _dpTable;\n    console.log(_dpTable)\n  }\n  let result = dpTable[0];\n  for (let i = 1; i < len; i++) {\n    result = Math.min(dpTable[i], result) \n  }\n  return result;\n};\n```\n\n- 只用一维数组的情况\n\n```ts\nfunction minimumTotal(triangle: number[][]): number {\n  const len = triangle.length;\n  const dpTable = Array(len).fill(0);\n  dpTable[0] = triangle[0][0]\n  for(let i = 1; i < len; i++) {\n    dpTable[i] = dpTable[i - 1] + triangle[i][i];\n    for(let j = i - 1; j > 0; j--) {\n      dpTable[j] = Math.min(dpTable[j - 1], dpTable[j]) + triangle[i][j];\n    }\n    dpTable[0] = dpTable[0] + triangle[i][0];\n    console.log(dpTable);\n  }\n  let result = dpTable[0];\n  for (let i = 1; i < len; i++) {\n    result = Math.min(dpTable[i], result) \n  }\n  return result;\n};\n```\n","source":"leetcode/动态规划/120.三角形最小路径和.md","raw":"# 120. 三角形最小路径和\n\n给定一个三角形 triangle ，找出自顶向下的最小路径和。\n\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n\n[链接](https://leetcode-cn.com/problems/triangle)\n\n- 只用二维数组的情况\n\n```ts\nfunction minimumTotal(triangle: number[][]): number {\n  const len = triangle.length;\n  let dpTable = Array(len).fill(0);\n  dpTable[0] = triangle[0][0];\n  for(let i = 1; i < len; i++) {\n    const _dpTable = Array(len).fill(0);\n    _dpTable[0] = dpTable[0] + triangle[i][0];\n    for(let j = 1; j < i; j++) {\n      _dpTable[j] = Math.min(dpTable[j - 1], dpTable[j]) + triangle[i][j];\n    }\n    _dpTable[i] = dpTable[i - 1] + triangle[i][i];\n    dpTable = _dpTable;\n    console.log(_dpTable)\n  }\n  let result = dpTable[0];\n  for (let i = 1; i < len; i++) {\n    result = Math.min(dpTable[i], result) \n  }\n  return result;\n};\n```\n\n- 只用一维数组的情况\n\n```ts\nfunction minimumTotal(triangle: number[][]): number {\n  const len = triangle.length;\n  const dpTable = Array(len).fill(0);\n  dpTable[0] = triangle[0][0]\n  for(let i = 1; i < len; i++) {\n    dpTable[i] = dpTable[i - 1] + triangle[i][i];\n    for(let j = i - 1; j > 0; j--) {\n      dpTable[j] = Math.min(dpTable[j - 1], dpTable[j]) + triangle[i][j];\n    }\n    dpTable[0] = dpTable[0] + triangle[i][0];\n    console.log(dpTable);\n  }\n  let result = dpTable[0];\n  for (let i = 1; i < len; i++) {\n    result = Math.min(dpTable[i], result) \n  }\n  return result;\n};\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.529Z","path":"leetcode/动态规划/120.三角形最小路径和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxj0004tnw70owq6u8j","content":"<h1 id=\"120-三角形最小路径和\"><a href=\"#120-三角形最小路径和\" class=\"headerlink\" title=\"120. 三角形最小路径和\"></a>120. 三角形最小路径和</h1><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>\n<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/triangle\">链接</a></p>\n<ul>\n<li>只用二维数组的情况</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minimumTotal</span>(<span class=\"params\">triangle: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = triangle.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dpTable = <span class=\"title class_\">Array</span>(len).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> _dpTable = <span class=\"title class_\">Array</span>(len).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    _dpTable[<span class=\"number\">0</span>] = dpTable[<span class=\"number\">0</span>] + triangle[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      _dpTable[j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[j - <span class=\"number\">1</span>], dpTable[j]) + triangle[i][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _dpTable[i] = dpTable[i - <span class=\"number\">1</span>] + triangle[i][i];</span><br><span class=\"line\">    dpTable = _dpTable;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(_dpTable)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = dpTable[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    result = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[i], result) </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>只用一维数组的情况</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minimumTotal</span>(<span class=\"params\">triangle: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = triangle.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dpTable = <span class=\"title class_\">Array</span>(len).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    dpTable[i] = dpTable[i - <span class=\"number\">1</span>] + triangle[i][i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      dpTable[j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[j - <span class=\"number\">1</span>], dpTable[j]) + triangle[i][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable[<span class=\"number\">0</span>] = dpTable[<span class=\"number\">0</span>] + triangle[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dpTable);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = dpTable[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    result = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[i], result) </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"120-三角形最小路径和\"><a href=\"#120-三角形最小路径和\" class=\"headerlink\" title=\"120. 三角形最小路径和\"></a>120. 三角形最小路径和</h1><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>\n<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/triangle\">链接</a></p>\n<ul>\n<li>只用二维数组的情况</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minimumTotal</span>(<span class=\"params\">triangle: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = triangle.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dpTable = <span class=\"title class_\">Array</span>(len).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> _dpTable = <span class=\"title class_\">Array</span>(len).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    _dpTable[<span class=\"number\">0</span>] = dpTable[<span class=\"number\">0</span>] + triangle[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      _dpTable[j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[j - <span class=\"number\">1</span>], dpTable[j]) + triangle[i][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _dpTable[i] = dpTable[i - <span class=\"number\">1</span>] + triangle[i][i];</span><br><span class=\"line\">    dpTable = _dpTable;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(_dpTable)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = dpTable[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    result = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[i], result) </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>只用一维数组的情况</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minimumTotal</span>(<span class=\"params\">triangle: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = triangle.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dpTable = <span class=\"title class_\">Array</span>(len).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    dpTable[i] = dpTable[i - <span class=\"number\">1</span>] + triangle[i][i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      dpTable[j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[j - <span class=\"number\">1</span>], dpTable[j]) + triangle[i][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable[<span class=\"number\">0</span>] = dpTable[<span class=\"number\">0</span>] + triangle[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dpTable);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = dpTable[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    result = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dpTable[i], result) </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 322. 零钱兑换\n\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回  -1 。\n\n你可以认为每种硬币的数量是无限的。\n\n[链接](https://leetcode-cn.com/problems/coin-change)\n\n```ts\nfunction coinChange(coins: number[], amount: number): number {\n  const dpTable: Record<number, number> = {};\n  function dp(n) {\n    if (dpTable[n]) return dpTable[n];\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    let res = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < coins.length; i++) {\n      const c = dp(n - coins[i]);\n      if (c === -1) continue;\n      res = Math.min(res, c + 1);\n    }\n    dpTable[n] = res === Number.POSITIVE_INFINITY ? -1 : res;\n    return dpTable[n];\n  }\n  return dp(amount);\n}\n```\n","source":"leetcode/动态规划/322.零钱兑换.md","raw":"# 322. 零钱兑换\n\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回  -1 。\n\n你可以认为每种硬币的数量是无限的。\n\n[链接](https://leetcode-cn.com/problems/coin-change)\n\n```ts\nfunction coinChange(coins: number[], amount: number): number {\n  const dpTable: Record<number, number> = {};\n  function dp(n) {\n    if (dpTable[n]) return dpTable[n];\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    let res = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < coins.length; i++) {\n      const c = dp(n - coins[i]);\n      if (c === -1) continue;\n      res = Math.min(res, c + 1);\n    }\n    dpTable[n] = res === Number.POSITIVE_INFINITY ? -1 : res;\n    return dpTable[n];\n  }\n  return dp(amount);\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.530Z","path":"leetcode/动态规划/322.零钱兑换.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxk0005tnw7773jdzof","content":"<h1 id=\"322-零钱兑换\"><a href=\"#322-零钱兑换\" class=\"headerlink\" title=\"322. 零钱兑换\"></a>322. 零钱兑换</h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>\n<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回  -1 。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/coin-change\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">coinChange</span>(<span class=\"params\">coins: <span class=\"built_in\">number</span>[], amount: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dp</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[n]) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coins.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> c = <span class=\"title function_\">dp</span>(n - coins[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (c === -<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(res, c + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable[n] = res === <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span> ? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dp</span>(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"322-零钱兑换\"><a href=\"#322-零钱兑换\" class=\"headerlink\" title=\"322. 零钱兑换\"></a>322. 零钱兑换</h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>\n<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回  -1 。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/coin-change\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">coinChange</span>(<span class=\"params\">coins: <span class=\"built_in\">number</span>[], amount: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dp</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[n]) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coins.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> c = <span class=\"title function_\">dp</span>(n - coins[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (c === -<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(res, c + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable[n] = res === <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span> ? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dp</span>(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"45. 跳跃游戏 II","date":"2020-06-29T03:20:26.000Z","tags":null,"categories":null,"_content":"\n给你一个非负整数数组  nums ，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n假设你总是可以到达数组的最后一个位置。\n\n[链接](https://leetcode-cn.com/problems/jump-game-ii)\n\n```ts\nfunction jump(nums: number[]): number {\n  const dp: number[] = Array.from(Array(nums.length), () => {\n    return nums.length + 1;\n  });\n  dp[0] = 0;\n  for (let i = 0; i < dp.length; i++) {\n    for (let j = 1; j <= nums[i]; j++) {\n      if (i + j >= nums.length) return dp[dp.length - 1];\n      dp[i + j] = Math.min(dp[i + j], 1 + dp[i]);\n    }\n  }\n  return dp[dp.length - 1];\n}\n```\n","source":"leetcode/动态规划/45.跳跃游戏II.md","raw":"---\ntitle: 45. 跳跃游戏 II\ndate: 2020-06-29 11:20:26\ntags:\ncategories:\n---\n\n给你一个非负整数数组  nums ，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n假设你总是可以到达数组的最后一个位置。\n\n[链接](https://leetcode-cn.com/problems/jump-game-ii)\n\n```ts\nfunction jump(nums: number[]): number {\n  const dp: number[] = Array.from(Array(nums.length), () => {\n    return nums.length + 1;\n  });\n  dp[0] = 0;\n  for (let i = 0; i < dp.length; i++) {\n    for (let j = 1; j <= nums[i]; j++) {\n      if (i + j >= nums.length) return dp[dp.length - 1];\n      dp[i + j] = Math.min(dp[i + j], 1 + dp[i]);\n    }\n  }\n  return dp[dp.length - 1];\n}\n```\n","updated":"2023-09-26T15:02:18.473Z","path":"leetcode/动态规划/45.跳跃游戏II.html","comments":1,"layout":"page","_id":"clnlw1sxk0006tnw78afu0yj6","content":"<p>给你一个非负整数数组  nums ，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n<p>假设你总是可以到达数组的最后一个位置。</p>\n<p><a href=\"https://leetcode-cn.com/problems/jump-game-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dp</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(nums.<span class=\"property\">length</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.<span class=\"property\">length</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i + j &gt;= nums.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">      dp[i + j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i + j], <span class=\"number\">1</span> + dp[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>给你一个非负整数数组  nums ，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n<p>假设你总是可以到达数组的最后一个位置。</p>\n<p><a href=\"https://leetcode-cn.com/problems/jump-game-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dp</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(nums.<span class=\"property\">length</span>), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.<span class=\"property\">length</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i + j &gt;= nums.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">      dp[i + j] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i + j], <span class=\"number\">1</span> + dp[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[dp.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 509. 斐波那契数\n\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。\n\n```ts\nfunction fib(n: number): number {\n  const dpTable: Record<number, number> = {};\n  dpTable[0] = 0;\n  dpTable[1] = 1;\n  const handleFib = (target: number) => {\n    if (dpTable[target] !== undefined) {\n      return dpTable[target];\n    }\n\n    const result = handleFib(target - 1) + handleFib(target - 2);\n    dpTable[target] = result;\n    return result;\n  };\n  \n  return handleFib(n);  \n};\n```\n","source":"leetcode/动态规划/509.斐波那契数.md","raw":"# 509. 斐波那契数\n\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。\n\n```ts\nfunction fib(n: number): number {\n  const dpTable: Record<number, number> = {};\n  dpTable[0] = 0;\n  dpTable[1] = 1;\n  const handleFib = (target: number) => {\n    if (dpTable[target] !== undefined) {\n      return dpTable[target];\n    }\n\n    const result = handleFib(target - 1) + handleFib(target - 2);\n    dpTable[target] = result;\n    return result;\n  };\n  \n  return handleFib(n);  \n};\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.530Z","path":"leetcode/动态规划/509.斐波那契数.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxk0007tnw709g7c4q8","content":"<h1 id=\"509-斐波那契数\"><a href=\"#509-斐波那契数\" class=\"headerlink\" title=\"509. 斐波那契数\"></a>509. 斐波那契数</h1><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fib</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleFib</span> = (<span class=\"params\">target: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[target] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dpTable[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title function_\">handleFib</span>(target - <span class=\"number\">1</span>) + <span class=\"title function_\">handleFib</span>(target - <span class=\"number\">2</span>);</span><br><span class=\"line\">    dpTable[target] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">handleFib</span>(n);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"509-斐波那契数\"><a href=\"#509-斐波那契数\" class=\"headerlink\" title=\"509. 斐波那契数\"></a>509. 斐波那契数</h1><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fib</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleFib</span> = (<span class=\"params\">target: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[target] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dpTable[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"title function_\">handleFib</span>(target - <span class=\"number\">1</span>) + <span class=\"title function_\">handleFib</span>(target - <span class=\"number\">2</span>);</span><br><span class=\"line\">    dpTable[target] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">handleFib</span>(n);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 53. 最大子序和\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n[链接](https://leetcode-cn.com/problems/maximum-subarray/)\n\n```ts\nfunction maxSubArray(nums: number[]): number {\n  let pre = 0,\n    maxAns = nums[0];\n  nums.forEach((x) => {\n    pre = Math.max(pre + x, x);\n    maxAns = Math.max(maxAns, pre);\n  });\n  return maxAns;\n}\n```\n","source":"leetcode/动态规划/53.最大子序和.md","raw":"# 53. 最大子序和\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n[链接](https://leetcode-cn.com/problems/maximum-subarray/)\n\n```ts\nfunction maxSubArray(nums: number[]): number {\n  let pre = 0,\n    maxAns = nums[0];\n  nums.forEach((x) => {\n    pre = Math.max(pre + x, x);\n    maxAns = Math.max(maxAns, pre);\n  });\n  return maxAns;\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.531Z","path":"leetcode/动态规划/53.最大子序和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxk0008tnw73qdocv3f","content":"<h1 id=\"53-最大子序和\"><a href=\"#53-最大子序和\" class=\"headerlink\" title=\"53. 最大子序和\"></a>53. 最大子序和</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxSubArray</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"number\">0</span>,</span><br><span class=\"line\">    maxAns = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  nums.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    pre = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(pre + x, x);</span><br><span class=\"line\">    maxAns = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(maxAns, pre);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxAns;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"53-最大子序和\"><a href=\"#53-最大子序和\" class=\"headerlink\" title=\"53. 最大子序和\"></a>53. 最大子序和</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxSubArray</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"number\">0</span>,</span><br><span class=\"line\">    maxAns = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  nums.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    pre = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(pre + x, x);</span><br><span class=\"line\">    maxAns = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(maxAns, pre);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxAns;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 55. 跳跃游戏\n\n给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标。\n\n```ts\nfunction canJump(nums: number[]): boolean {\n  const len = nums.length - 1;\n  let rightMost = 0;\n  for (let i = 0; i <= len; i++) {\n    if (i <= rightMost) {\n      rightMost = Math.max(rightMost, i + nums[i]);\n      if (rightMost >= len) return true;\n    }\n  }\n  return false;\n}\n```\n","source":"leetcode/动态规划/55.跳跃游戏.md","raw":"# 55. 跳跃游戏\n\n给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标。\n\n```ts\nfunction canJump(nums: number[]): boolean {\n  const len = nums.length - 1;\n  let rightMost = 0;\n  for (let i = 0; i <= len; i++) {\n    if (i <= rightMost) {\n      rightMost = Math.max(rightMost, i + nums[i]);\n      if (rightMost >= len) return true;\n    }\n  }\n  return false;\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.531Z","path":"leetcode/动态规划/55.跳跃游戏.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxk0009tnw72fdl49xs","content":"<h1 id=\"55-跳跃游戏\"><a href=\"#55-跳跃游戏\" class=\"headerlink\" title=\"55. 跳跃游戏\"></a>55. 跳跃游戏</h1><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">canJump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightMost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= rightMost) &#123;</span><br><span class=\"line\">      rightMost = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rightMost, i + nums[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightMost &gt;= len) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"55-跳跃游戏\"><a href=\"#55-跳跃游戏\" class=\"headerlink\" title=\"55. 跳跃游戏\"></a>55. 跳跃游戏</h1><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">canJump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightMost = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= rightMost) &#123;</span><br><span class=\"line\">      rightMost = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rightMost, i + nums[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightMost &gt;= len) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 62. 不同路径\n\n一个机器人位于一个 m x n  网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n[链接](https://leetcode-cn.com/problems/unique-paths)\n\n```ts\nfunction uniquePaths(m: number, n: number): number {\n  let preRow = new Array(n).fill(1);\n  let row = new Array(n).fill(1);\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      row[j] = row[j - 1] + preRow[j];\n    }\n    preRow = row.slice(0);\n  }\n  return preRow[n - 1];\n}\n```\n\n- 空间 O(n)的答案\n\n```ts\nfunction uniquePaths(m: number, n: number): number {\n  let row = new Array(n).fill(1);\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      row[j] += row[j - 1];\n    }\n  }\n  return row[n - 1];\n}\n```\n","source":"leetcode/动态规划/62.不同路径.md","raw":"# 62. 不同路径\n\n一个机器人位于一个 m x n  网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n[链接](https://leetcode-cn.com/problems/unique-paths)\n\n```ts\nfunction uniquePaths(m: number, n: number): number {\n  let preRow = new Array(n).fill(1);\n  let row = new Array(n).fill(1);\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      row[j] = row[j - 1] + preRow[j];\n    }\n    preRow = row.slice(0);\n  }\n  return preRow[n - 1];\n}\n```\n\n- 空间 O(n)的答案\n\n```ts\nfunction uniquePaths(m: number, n: number): number {\n  let row = new Array(n).fill(1);\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      row[j] += row[j - 1];\n    }\n  }\n  return row[n - 1];\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.531Z","path":"leetcode/动态规划/62.不同路径.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxk000atnw79bvmbgj6","content":"<h1 id=\"62-不同路径\"><a href=\"#62-不同路径\" class=\"headerlink\" title=\"62. 不同路径\"></a>62. 不同路径</h1><p>一个机器人位于一个 m x n  网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">uniquePaths</span>(<span class=\"params\">m: <span class=\"built_in\">number</span>, n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preRow = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      row[j] = row[j - <span class=\"number\">1</span>] + preRow[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    preRow = row.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preRow[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>空间 O(n)的答案</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">uniquePaths</span>(<span class=\"params\">m: <span class=\"built_in\">number</span>, n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      row[j] += row[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> row[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"62-不同路径\"><a href=\"#62-不同路径\" class=\"headerlink\" title=\"62. 不同路径\"></a>62. 不同路径</h1><p>一个机器人位于一个 m x n  网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">uniquePaths</span>(<span class=\"params\">m: <span class=\"built_in\">number</span>, n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preRow = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      row[j] = row[j - <span class=\"number\">1</span>] + preRow[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    preRow = row.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preRow[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>空间 O(n)的答案</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">uniquePaths</span>(<span class=\"params\">m: <span class=\"built_in\">number</span>, n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      row[j] += row[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> row[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 63. 不同路径 II\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n[链接](https://leetcode-cn.com/problems/unique-paths-ii)\n\n```ts\nfunction uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n  const m = obstacleGrid.length;\n  const n = obstacleGrid[0].length;\n  const dp: number[][] = Array.from(Array(m), (data, row) => {\n    return Array(n).fill(0);\n  });\n  for (let i = 0; i < dp[0].length; i++) {\n    if (obstacleGrid[0][i] === 1) break;\n    dp[0][i] = 1;\n  }\n  for (let i = 0; i < dp.length; i++) {\n    if (obstacleGrid[i][0] === 1) break;\n    dp[i][0] = 1;\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (obstacleGrid[i][j] === 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n  }\n  return dp[m - 1][n - 1];\n}\n```\n","source":"leetcode/动态规划/63.不同路径II.md","raw":"# 63. 不同路径 II\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n[链接](https://leetcode-cn.com/problems/unique-paths-ii)\n\n```ts\nfunction uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n  const m = obstacleGrid.length;\n  const n = obstacleGrid[0].length;\n  const dp: number[][] = Array.from(Array(m), (data, row) => {\n    return Array(n).fill(0);\n  });\n  for (let i = 0; i < dp[0].length; i++) {\n    if (obstacleGrid[0][i] === 1) break;\n    dp[0][i] = 1;\n  }\n  for (let i = 0; i < dp.length; i++) {\n    if (obstacleGrid[i][0] === 1) break;\n    dp[i][0] = 1;\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (obstacleGrid[i][j] === 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n  }\n  return dp[m - 1][n - 1];\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.532Z","path":"leetcode/动态规划/63.不同路径II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxk000btnw7easgartv","content":"<h1 id=\"63-不同路径-II\"><a href=\"#63-不同路径-II\" class=\"headerlink\" title=\"63. 不同路径 II\"></a>63. 不同路径 II</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">uniquePathsWithObstacles</span>(<span class=\"params\">obstacleGrid: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = obstacleGrid.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = obstacleGrid[<span class=\"number\">0</span>].<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dp</span>: <span class=\"built_in\">number</span>[][] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(m), <span class=\"function\">(<span class=\"params\">data, row</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp[<span class=\"number\">0</span>].<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[<span class=\"number\">0</span>][i] === <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[i][<span class=\"number\">0</span>] === <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obstacleGrid[i][j] === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"63-不同路径-II\"><a href=\"#63-不同路径-II\" class=\"headerlink\" title=\"63. 不同路径 II\"></a>63. 不同路径 II</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">uniquePathsWithObstacles</span>(<span class=\"params\">obstacleGrid: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = obstacleGrid.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = obstacleGrid[<span class=\"number\">0</span>].<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dp</span>: <span class=\"built_in\">number</span>[][] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(m), <span class=\"function\">(<span class=\"params\">data, row</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp[<span class=\"number\">0</span>].<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[<span class=\"number\">0</span>][i] === <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obstacleGrid[i][<span class=\"number\">0</span>] === <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obstacleGrid[i][j] === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 64. 最小路径和\n\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n[链接](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n```ts\nfunction minPathSum(grid: number[][]): number {\n  const dp = grid.splice(0);\n  const m = dp.length;\n  const n = dp[0].length;\n  for (let i = 1; i < m; i++) {\n    dp[i][0] += dp[i - 1][0];\n  }\n  for (let i = 1; i < n; i++) {\n    dp[0][i] += dp[0][i - 1];\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[m - 1][n - 1];\n}\n```\n","source":"leetcode/动态规划/64.最小路径和.md","raw":"# 64. 最小路径和\n\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n[链接](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n```ts\nfunction minPathSum(grid: number[][]): number {\n  const dp = grid.splice(0);\n  const m = dp.length;\n  const n = dp[0].length;\n  for (let i = 1; i < m; i++) {\n    dp[i][0] += dp[i - 1][0];\n  }\n  for (let i = 1; i < n; i++) {\n    dp[0][i] += dp[0][i - 1];\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[m - 1][n - 1];\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.532Z","path":"leetcode/动态规划/64.最小路径和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000ctnw7eop7fx7l","content":"<h1 id=\"64-最小路径和\"><a href=\"#64-最小路径和\" class=\"headerlink\" title=\"64. 最小路径和\"></a>64. 最小路径和</h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n<p>说明：每次只能向下或者向右移动一步。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minPathSum</span>(<span class=\"params\">grid: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = grid.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = dp.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = dp[<span class=\"number\">0</span>].<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] += dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][i] += dp[<span class=\"number\">0</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      dp[i][j] += <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"64-最小路径和\"><a href=\"#64-最小路径和\" class=\"headerlink\" title=\"64. 最小路径和\"></a>64. 最小路径和</h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n<p>说明：每次只能向下或者向右移动一步。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minPathSum</span>(<span class=\"params\">grid: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = grid.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = dp.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = dp[<span class=\"number\">0</span>].<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] += dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][i] += dp[<span class=\"number\">0</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">      dp[i][j] += <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 70. 爬楼梯\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n[链接](https://leetcode-cn.com/problems/climbing-stairs/)\n\n```ts\nfunction climbStairs(n: number): number {\n  let p = 0;\n  let q = 0;\n  let r = 1;\n  for(let i = 1; i <= n; i++) {\n    p = q;\n    q = r;\n    r = p + q;\n  }\n  return r;\n};\n```\n","source":"leetcode/动态规划/70.爬楼梯.md","raw":"# 70. 爬楼梯\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n[链接](https://leetcode-cn.com/problems/climbing-stairs/)\n\n```ts\nfunction climbStairs(n: number): number {\n  let p = 0;\n  let q = 0;\n  let r = 1;\n  for(let i = 1; i <= n; i++) {\n    p = q;\n    q = r;\n    r = p + q;\n  }\n  return r;\n};\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.532Z","path":"leetcode/动态规划/70.爬楼梯.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000dtnw705tg7vvx","content":"<h1 id=\"70-爬楼梯\"><a href=\"#70-爬楼梯\" class=\"headerlink\" title=\"70. 爬楼梯\"></a>70. 爬楼梯</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">climbStairs</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> q = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    p = q;</span><br><span class=\"line\">    q = r;</span><br><span class=\"line\">    r = p + q;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"70-爬楼梯\"><a href=\"#70-爬楼梯\" class=\"headerlink\" title=\"70. 爬楼梯\"></a>70. 爬楼梯</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">climbStairs</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> q = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    p = q;</span><br><span class=\"line\">    q = r;</span><br><span class=\"line\">    r = p + q;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 746. 使用最小花费爬楼梯\n\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n\n请你计算并返回达到楼梯顶部的最低花费。\n\n[链接](https://leetcode-cn.com/problems/min-cost-climbing-stairs)\n\n```ts\nfunction minCostClimbingStairs(cost: number[]): number {\n  let cur = 0;\n  let pre = 0;\n  const costCounter = cost.length;\n  for(let i = 2; i <= costCounter; i++) {\n    const next = Math.min(cur + cost[i - 1], pre + cost[i - 2]);\n    pre = cur;\n    cur = next;\n  }\n  return cur;\n};\n```\n","source":"leetcode/动态规划/746.使用最小花费爬楼梯.md","raw":"# 746. 使用最小花费爬楼梯\n\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n\n请你计算并返回达到楼梯顶部的最低花费。\n\n[链接](https://leetcode-cn.com/problems/min-cost-climbing-stairs)\n\n```ts\nfunction minCostClimbingStairs(cost: number[]): number {\n  let cur = 0;\n  let pre = 0;\n  const costCounter = cost.length;\n  for(let i = 2; i <= costCounter; i++) {\n    const next = Math.min(cur + cost[i - 1], pre + cost[i - 2]);\n    pre = cur;\n    cur = next;\n  }\n  return cur;\n};\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.533Z","path":"leetcode/动态规划/746.使用最小花费爬楼梯.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000etnw7amh15mwa","content":"<h1 id=\"746-使用最小花费爬楼梯\"><a href=\"#746-使用最小花费爬楼梯\" class=\"headerlink\" title=\"746. 使用最小花费爬楼梯\"></a>746. 使用最小花费爬楼梯</h1><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n<p><a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minCostClimbingStairs</span>(<span class=\"params\">cost: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> costCounter = cost.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= costCounter; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> next = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(cur + cost[i - <span class=\"number\">1</span>], pre + cost[i - <span class=\"number\">2</span>]);</span><br><span class=\"line\">    pre = cur;</span><br><span class=\"line\">    cur = next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"746-使用最小花费爬楼梯\"><a href=\"#746-使用最小花费爬楼梯\" class=\"headerlink\" title=\"746. 使用最小花费爬楼梯\"></a>746. 使用最小花费爬楼梯</h1><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n<p><a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minCostClimbingStairs</span>(<span class=\"params\">cost: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> costCounter = cost.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= costCounter; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> next = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(cur + cost[i - <span class=\"number\">1</span>], pre + cost[i - <span class=\"number\">2</span>]);</span><br><span class=\"line\">    pre = cur;</span><br><span class=\"line\">    cur = next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 931. 下降路径最小和\n\n给你一个 n x n 的 方形 整数数组  matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。\n\n下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。\n\n[链接](https://leetcode-cn.com/problems/minimum-falling-path-sum)\n\n## 解析\n\n这题很容易找出转换方程和 base case\n\n- base case\n\n可以直接用 matrix 来做初始化 dp 数组，因为 dp 的初始值为第一行，根据转换方程，第一行的值为它本身\n\n- 转换方程\n\n```js\n0 <= i < dp.length;\n\n0 <= j < dp[i].length;\n\npreCol = j - 1 >= 0;\n\naftCol = j + 1 < dp[i].length;\n\ndp[i][j] =\n  Math.min(dp[i - 1][preCol], dp[i - 1][j], dp[i - 1][aftCol]) + dp[i][j];\n```\n\n```ts\nfunction minFallingPathSum(matrix: number[][]): number {\n  const dp = matrix.splice(0);\n  const rowLen = dp.length;\n  for (let row = 1; row < rowLen; row++) {\n    const cols = dp[row];\n    const colLen = cols.length;\n    const preRow = row - 1;\n    for (let col = 0; col < colLen; col++) {\n      const pres: number[] = [];\n      pres.push(dp[preRow][col]);\n      const preCol = col - 1;\n      const aftCol = col + 1;\n      if (preCol >= 0) {\n        pres.push(dp[preRow][preCol]);\n      }\n      if (aftCol < colLen) {\n        pres.push(dp[preRow][aftCol]);\n      }\n      dp[row][col] = Math.min(...pres) + dp[row][col];\n    }\n  }\n  const lastDp = dp[rowLen - 1];\n  let min = lastDp[0];\n  lastDp.forEach((num) => {\n    min = Math.min(min, num);\n  });\n  return min;\n}\n```\n","source":"leetcode/动态规划/931.下降路径最小和.md","raw":"# 931. 下降路径最小和\n\n给你一个 n x n 的 方形 整数数组  matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。\n\n下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。\n\n[链接](https://leetcode-cn.com/problems/minimum-falling-path-sum)\n\n## 解析\n\n这题很容易找出转换方程和 base case\n\n- base case\n\n可以直接用 matrix 来做初始化 dp 数组，因为 dp 的初始值为第一行，根据转换方程，第一行的值为它本身\n\n- 转换方程\n\n```js\n0 <= i < dp.length;\n\n0 <= j < dp[i].length;\n\npreCol = j - 1 >= 0;\n\naftCol = j + 1 < dp[i].length;\n\ndp[i][j] =\n  Math.min(dp[i - 1][preCol], dp[i - 1][j], dp[i - 1][aftCol]) + dp[i][j];\n```\n\n```ts\nfunction minFallingPathSum(matrix: number[][]): number {\n  const dp = matrix.splice(0);\n  const rowLen = dp.length;\n  for (let row = 1; row < rowLen; row++) {\n    const cols = dp[row];\n    const colLen = cols.length;\n    const preRow = row - 1;\n    for (let col = 0; col < colLen; col++) {\n      const pres: number[] = [];\n      pres.push(dp[preRow][col]);\n      const preCol = col - 1;\n      const aftCol = col + 1;\n      if (preCol >= 0) {\n        pres.push(dp[preRow][preCol]);\n      }\n      if (aftCol < colLen) {\n        pres.push(dp[preRow][aftCol]);\n      }\n      dp[row][col] = Math.min(...pres) + dp[row][col];\n    }\n  }\n  const lastDp = dp[rowLen - 1];\n  let min = lastDp[0];\n  lastDp.forEach((num) => {\n    min = Math.min(min, num);\n  });\n  return min;\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.533Z","path":"leetcode/动态规划/931.下降路径最小和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000ftnw78iaq9prt","content":"<h1 id=\"931-下降路径最小和\"><a href=\"#931-下降路径最小和\" class=\"headerlink\" title=\"931. 下降路径最小和\"></a>931. 下降路径最小和</h1><p>给你一个 n x n 的 方形 整数数组  matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>\n<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-falling-path-sum\">链接</a></p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>这题很容易找出转换方程和 base case</p>\n<ul>\n<li>base case</li>\n</ul>\n<p>可以直接用 matrix 来做初始化 dp 数组，因为 dp 的初始值为第一行，根据转换方程，第一行的值为它本身</p>\n<ul>\n<li>转换方程</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &lt;= i &lt; dp.<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> &lt;= j &lt; dp[i].<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">preCol = j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">aftCol = j + <span class=\"number\">1</span> &lt; dp[i].<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">dp[i][j] =</span><br><span class=\"line\">  <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i - <span class=\"number\">1</span>][preCol], dp[i - <span class=\"number\">1</span>][j], dp[i - <span class=\"number\">1</span>][aftCol]) + dp[i][j];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minFallingPathSum</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = matrix.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rowLen = dp.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">1</span>; row &lt; rowLen; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cols = dp[row];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> colLen = cols.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> preRow = row - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; colLen; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">pres</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">      pres.<span class=\"title function_\">push</span>(dp[preRow][col]);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> preCol = col - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> aftCol = col + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (preCol &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        pres.<span class=\"title function_\">push</span>(dp[preRow][preCol]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (aftCol &lt; colLen) &#123;</span><br><span class=\"line\">        pres.<span class=\"title function_\">push</span>(dp[preRow][aftCol]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      dp[row][col] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(...pres) + dp[row][col];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lastDp = dp[rowLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = lastDp[<span class=\"number\">0</span>];</span><br><span class=\"line\">  lastDp.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">num</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    min = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(min, num);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"931-下降路径最小和\"><a href=\"#931-下降路径最小和\" class=\"headerlink\" title=\"931. 下降路径最小和\"></a>931. 下降路径最小和</h1><p>给你一个 n x n 的 方形 整数数组  matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>\n<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-falling-path-sum\">链接</a></p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>这题很容易找出转换方程和 base case</p>\n<ul>\n<li>base case</li>\n</ul>\n<p>可以直接用 matrix 来做初始化 dp 数组，因为 dp 的初始值为第一行，根据转换方程，第一行的值为它本身</p>\n<ul>\n<li>转换方程</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &lt;= i &lt; dp.<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> &lt;= j &lt; dp[i].<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">preCol = j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">aftCol = j + <span class=\"number\">1</span> &lt; dp[i].<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">dp[i][j] =</span><br><span class=\"line\">  <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dp[i - <span class=\"number\">1</span>][preCol], dp[i - <span class=\"number\">1</span>][j], dp[i - <span class=\"number\">1</span>][aftCol]) + dp[i][j];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minFallingPathSum</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = matrix.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rowLen = dp.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> row = <span class=\"number\">1</span>; row &lt; rowLen; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cols = dp[row];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> colLen = cols.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> preRow = row - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> col = <span class=\"number\">0</span>; col &lt; colLen; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">pres</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">      pres.<span class=\"title function_\">push</span>(dp[preRow][col]);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> preCol = col - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> aftCol = col + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (preCol &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        pres.<span class=\"title function_\">push</span>(dp[preRow][preCol]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (aftCol &lt; colLen) &#123;</span><br><span class=\"line\">        pres.<span class=\"title function_\">push</span>(dp[preRow][aftCol]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      dp[row][col] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(...pres) + dp[row][col];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lastDp = dp[rowLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = lastDp[<span class=\"number\">0</span>];</span><br><span class=\"line\">  lastDp.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">num</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    min = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(min, num);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 91. 解码方法\n\n一条包含字母  A-Z 的消息通过以下映射进行了 编码 ：\n\n```js\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n```\n\n要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\" 可以映射为：\n\n- \"AAJF\" ，将消息分组为 (1 1 10 6)\n- \"KJF\" ，将消息分组为 (11 10 6)\n\n注意，消息不能分组为   (1 11 06) ，因为 \"06\" 不能映射为 \"F\" ，这是由于 \"6\" 和 \"06\" 在映射中并不等价。\n\n给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。\n\n题目数据保证答案肯定是一个 32 位 的整数。\n\n[链接](https://leetcode-cn.com/problems/decode-ways)\n\n```ts\nfunction numDecodings(s: string): number {\n  const n = s.length;\n  const dp = Array(n + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    if (s[i - 1] !== \"0\") {\n      dp[i] += dp[i - 1];\n    }\n    if (\n      i > 1 &&\n      s[i - 2] !== \"0\" &&\n      Number(s[i - 2]) * 10 + Number(s[i - 1]) <= 26\n    ) {\n      dp[i] += dp[i - 2];\n    }\n  }\n  return dp[n];\n}\n```\n","source":"leetcode/动态规划/91.解码方法.md","raw":"# 91. 解码方法\n\n一条包含字母  A-Z 的消息通过以下映射进行了 编码 ：\n\n```js\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n```\n\n要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\" 可以映射为：\n\n- \"AAJF\" ，将消息分组为 (1 1 10 6)\n- \"KJF\" ，将消息分组为 (11 10 6)\n\n注意，消息不能分组为   (1 11 06) ，因为 \"06\" 不能映射为 \"F\" ，这是由于 \"6\" 和 \"06\" 在映射中并不等价。\n\n给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。\n\n题目数据保证答案肯定是一个 32 位 的整数。\n\n[链接](https://leetcode-cn.com/problems/decode-ways)\n\n```ts\nfunction numDecodings(s: string): number {\n  const n = s.length;\n  const dp = Array(n + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    if (s[i - 1] !== \"0\") {\n      dp[i] += dp[i - 1];\n    }\n    if (\n      i > 1 &&\n      s[i - 2] !== \"0\" &&\n      Number(s[i - 2]) * 10 + Number(s[i - 1]) <= 26\n    ) {\n      dp[i] += dp[i - 2];\n    }\n  }\n  return dp[n];\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.533Z","path":"leetcode/动态规划/91.解码方法.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000gtnw73akgbg82","content":"<h1 id=\"91-解码方法\"><a href=\"#91-解码方法\" class=\"headerlink\" title=\"91. 解码方法\"></a>91. 解码方法</h1><p>一条包含字母  A-Z 的消息通过以下映射进行了 编码 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;A&#x27;</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">&#x27;B&#x27;</span> -&gt; <span class=\"number\">2</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"string\">&#x27;Z&#x27;</span> -&gt; <span class=\"number\">26</span></span><br></pre></td></tr></table></figure>\n\n<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>\n<ul>\n<li>“AAJF” ，将消息分组为 (1 1 10 6)</li>\n<li>“KJF” ，将消息分组为 (11 10 6)</li>\n</ul>\n<p>注意，消息不能分组为   (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>\n<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>\n<p>题目数据保证答案肯定是一个 32 位 的整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/decode-ways\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">numDecodings</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = <span class=\"title class_\">Array</span>(n + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i - <span class=\"number\">1</span>] !== <span class=\"string\">&quot;0&quot;</span>) &#123;</span><br><span class=\"line\">      dp[i] += dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      i &gt; <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">      s[i - <span class=\"number\">2</span>] !== <span class=\"string\">&quot;0&quot;</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"title class_\">Number</span>(s[i - <span class=\"number\">2</span>]) * <span class=\"number\">10</span> + <span class=\"title class_\">Number</span>(s[i - <span class=\"number\">1</span>]) &lt;= <span class=\"number\">26</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      dp[i] += dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"91-解码方法\"><a href=\"#91-解码方法\" class=\"headerlink\" title=\"91. 解码方法\"></a>91. 解码方法</h1><p>一条包含字母  A-Z 的消息通过以下映射进行了 编码 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;A&#x27;</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">&#x27;B&#x27;</span> -&gt; <span class=\"number\">2</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"string\">&#x27;Z&#x27;</span> -&gt; <span class=\"number\">26</span></span><br></pre></td></tr></table></figure>\n\n<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>\n<ul>\n<li>“AAJF” ，将消息分组为 (1 1 10 6)</li>\n<li>“KJF” ，将消息分组为 (11 10 6)</li>\n</ul>\n<p>注意，消息不能分组为   (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>\n<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>\n<p>题目数据保证答案肯定是一个 32 位 的整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/decode-ways\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">numDecodings</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = <span class=\"title class_\">Array</span>(n + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i - <span class=\"number\">1</span>] !== <span class=\"string\">&quot;0&quot;</span>) &#123;</span><br><span class=\"line\">      dp[i] += dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      i &gt; <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">      s[i - <span class=\"number\">2</span>] !== <span class=\"string\">&quot;0&quot;</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"title class_\">Number</span>(s[i - <span class=\"number\">2</span>]) * <span class=\"number\">10</span> + <span class=\"title class_\">Number</span>(s[i - <span class=\"number\">1</span>]) &lt;= <span class=\"number\">26</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      dp[i] += dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 剑指 Offer II 103. 最少的硬币数目\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。\n\n你可以认为每种硬币的数量是无限的。\n\n[链接](https://leetcode-cn.com/problems/gaM7Ch)\n\n```ts\nfunction coinChange(coins: number[], amount: number): number {\n  const dpTable: Record<number, number> = {};\n  function dp(n: number): number {\n    if (dpTable[n]) return dpTable[n];\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    let res = Number.POSITIVE_INFINITY;\n    const coinsLen = coins.length;\n    for (let i = 0; i < coinsLen; i++) {\n      const num = dp(n - coins[i]);\n      if (num === -1) continue;\n      res = Math.min(res, 1 + num);\n    }\n    dpTable[n] = res === Number.POSITIVE_INFINITY ? -1 : res;\n    return dpTable[n];\n  }\n  return dp(amount);\n}\n```\n","source":"leetcode/动态规划/剑指OfferII103.最少的硬币数目.md","raw":"# 剑指 Offer II 103. 最少的硬币数目\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。\n\n你可以认为每种硬币的数量是无限的。\n\n[链接](https://leetcode-cn.com/problems/gaM7Ch)\n\n```ts\nfunction coinChange(coins: number[], amount: number): number {\n  const dpTable: Record<number, number> = {};\n  function dp(n: number): number {\n    if (dpTable[n]) return dpTable[n];\n    if (n === 0) return 0;\n    if (n < 0) return -1;\n    let res = Number.POSITIVE_INFINITY;\n    const coinsLen = coins.length;\n    for (let i = 0; i < coinsLen; i++) {\n      const num = dp(n - coins[i]);\n      if (num === -1) continue;\n      res = Math.min(res, 1 + num);\n    }\n    dpTable[n] = res === Number.POSITIVE_INFINITY ? -1 : res;\n    return dpTable[n];\n  }\n  return dp(amount);\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.534Z","path":"leetcode/动态规划/剑指OfferII103.最少的硬币数目.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000htnw7cycrgu58","content":"<h1 id=\"剑指-Offer-II-103-最少的硬币数目\"><a href=\"#剑指-Offer-II-103-最少的硬币数目\" class=\"headerlink\" title=\"剑指 Offer II 103. 最少的硬币数目\"></a>剑指 Offer II 103. 最少的硬币数目</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/gaM7Ch\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">coinChange</span>(<span class=\"params\">coins: <span class=\"built_in\">number</span>[], amount: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dp</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[n]) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> coinsLen = coins.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coinsLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> num = <span class=\"title function_\">dp</span>(n - coins[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num === -<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(res, <span class=\"number\">1</span> + num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable[n] = res === <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span> ? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dp</span>(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"剑指-Offer-II-103-最少的硬币数目\"><a href=\"#剑指-Offer-II-103-最少的硬币数目\" class=\"headerlink\" title=\"剑指 Offer II 103. 最少的硬币数目\"></a>剑指 Offer II 103. 最少的硬币数目</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/gaM7Ch\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">coinChange</span>(<span class=\"params\">coins: <span class=\"built_in\">number</span>[], amount: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dp</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dpTable[n]) <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> coinsLen = coins.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; coinsLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> num = <span class=\"title function_\">dp</span>(n - coins[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (num === -<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(res, <span class=\"number\">1</span> + num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dpTable[n] = res === <span class=\"title class_\">Number</span>.<span class=\"property\">POSITIVE_INFINITY</span> ? -<span class=\"number\">1</span> : res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dpTable[n];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dp</span>(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 100. 相同的树\n\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n[链接](https://leetcode-cn.com/problems/same-tree/)\n\n```ts\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  if (p === null && q === null) return true\n  if ((p === null && q !== null) || (p !== null && q === null)) return false\n  if (p.val !== q.val) return false \n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n","source":"leetcode/二叉树/100.相同的树.md","raw":"# 100. 相同的树\n\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n[链接](https://leetcode-cn.com/problems/same-tree/)\n\n```ts\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  if (p === null && q === null) return true\n  if ((p === null && q !== null) || (p !== null && q === null)) return false\n  if (p.val !== q.val) return false \n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n","date":"2023-10-11T15:10:43.195Z","updated":"2023-09-26T14:49:23.543Z","path":"leetcode/二叉树/100.相同的树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxl000itnw7clsb6kfh","content":"<h1 id=\"100-相同的树\"><a href=\"#100-相同的树\" class=\"headerlink\" title=\"100. 相同的树\"></a>100. 相同的树</h1><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/same-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSameTree</span>(<span class=\"params\">p: TreeNode | <span class=\"literal\">null</span>, q: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p === <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p === <span class=\"literal\">null</span> &amp;&amp; q !== <span class=\"literal\">null</span>) || (p !== <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p.<span class=\"property\">val</span> !== q.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">left</span>, q.<span class=\"property\">left</span>) &amp;&amp; <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">right</span>, q.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"100-相同的树\"><a href=\"#100-相同的树\" class=\"headerlink\" title=\"100. 相同的树\"></a>100. 相同的树</h1><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/same-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSameTree</span>(<span class=\"params\">p: TreeNode | <span class=\"literal\">null</span>, q: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p === <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p === <span class=\"literal\">null</span> &amp;&amp; q !== <span class=\"literal\">null</span>) || (p !== <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p.<span class=\"property\">val</span> !== q.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">left</span>, q.<span class=\"property\">left</span>) &amp;&amp; <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">right</span>, q.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 101. 对称二叉树\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n[链接](https://leetcode-cn.com/problems/symmetric-tree/)\n\n递归\n\n```ts\nfunction isSymmetric(root: TreeNode | null): boolean {\n  if (root === null) return true\n  return isSameTree(root.left, root.right)\n};\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  if (p === null && q === null) return true\n  if ((p === null && q !== null) || (p !== null && q === null)) return false\n  if (p.val !== q.val) return false \n  return isSameTree(p.left, q.right) && isSameTree(p.right, q.left)\n}\n```\n\n迭代\n\n```ts\nfunction isSymmetric(root: TreeNode | null): boolean {\n  if (root === null) return true\n  let nodeList: Array<TreeNode | null> = []\n  nodeList.push(root)\n  while(nodeList.length > 0) {\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n    } else {\n      const nodeL = nodeList.splice(0)\n      const preList = []\n      const backList = []\n      const len = nodeL.length\n      for(let i = 0; i < len / 2;i++) {\n        const startNode = nodeL[i]\n        const endNode = nodeL[len - i - 1]\n        if (startNode === null && endNode === null) continue\n        if (\n          (startNode === null && endNode !== null) ||\n          (startNode !== null && endNode === null) ||\n          (startNode.val !== endNode.val)\n        ) {\n          return false\n        }\n        preList.push(startNode.left)\n        preList.push(startNode.right)\n        backList.unshift(endNode.right)\n        backList.unshift(endNode.left)\n      }\n      nodeList = preList.concat(backList)\n    }\n  }\n  return true\n}\n```\n","source":"leetcode/二叉树/101.对称二叉树.md","raw":"# 101. 对称二叉树\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n[链接](https://leetcode-cn.com/problems/symmetric-tree/)\n\n递归\n\n```ts\nfunction isSymmetric(root: TreeNode | null): boolean {\n  if (root === null) return true\n  return isSameTree(root.left, root.right)\n};\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  if (p === null && q === null) return true\n  if ((p === null && q !== null) || (p !== null && q === null)) return false\n  if (p.val !== q.val) return false \n  return isSameTree(p.left, q.right) && isSameTree(p.right, q.left)\n}\n```\n\n迭代\n\n```ts\nfunction isSymmetric(root: TreeNode | null): boolean {\n  if (root === null) return true\n  let nodeList: Array<TreeNode | null> = []\n  nodeList.push(root)\n  while(nodeList.length > 0) {\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n    } else {\n      const nodeL = nodeList.splice(0)\n      const preList = []\n      const backList = []\n      const len = nodeL.length\n      for(let i = 0; i < len / 2;i++) {\n        const startNode = nodeL[i]\n        const endNode = nodeL[len - i - 1]\n        if (startNode === null && endNode === null) continue\n        if (\n          (startNode === null && endNode !== null) ||\n          (startNode !== null && endNode === null) ||\n          (startNode.val !== endNode.val)\n        ) {\n          return false\n        }\n        preList.push(startNode.left)\n        preList.push(startNode.right)\n        backList.unshift(endNode.right)\n        backList.unshift(endNode.left)\n      }\n      nodeList = preList.concat(backList)\n    }\n  }\n  return true\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.544Z","path":"leetcode/二叉树/101.对称二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000jtnw770lmhrqc","content":"<h1 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a>101. 对称二叉树</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">链接</a></p>\n<p>递归</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSymmetric</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isSameTree</span>(root.<span class=\"property\">left</span>, root.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSameTree</span>(<span class=\"params\">p: TreeNode | <span class=\"literal\">null</span>, q: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p === <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p === <span class=\"literal\">null</span> &amp;&amp; q !== <span class=\"literal\">null</span>) || (p !== <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p.<span class=\"property\">val</span> !== q.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">left</span>, q.<span class=\"property\">right</span>) &amp;&amp; <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">right</span>, q.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSymmetric</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = []</span><br><span class=\"line\">  nodeList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> preList = []</span><br><span class=\"line\">      <span class=\"keyword\">const</span> backList = []</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len / <span class=\"number\">2</span>;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> startNode = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> endNode = nodeL[len - i - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startNode === <span class=\"literal\">null</span> &amp;&amp; endNode === <span class=\"literal\">null</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">          (startNode === <span class=\"literal\">null</span> &amp;&amp; endNode !== <span class=\"literal\">null</span>) ||</span><br><span class=\"line\">          (startNode !== <span class=\"literal\">null</span> &amp;&amp; endNode === <span class=\"literal\">null</span>) ||</span><br><span class=\"line\">          (startNode.<span class=\"property\">val</span> !== endNode.<span class=\"property\">val</span>)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        preList.<span class=\"title function_\">push</span>(startNode.<span class=\"property\">left</span>)</span><br><span class=\"line\">        preList.<span class=\"title function_\">push</span>(startNode.<span class=\"property\">right</span>)</span><br><span class=\"line\">        backList.<span class=\"title function_\">unshift</span>(endNode.<span class=\"property\">right</span>)</span><br><span class=\"line\">        backList.<span class=\"title function_\">unshift</span>(endNode.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      nodeList = preList.<span class=\"title function_\">concat</span>(backList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a>101. 对称二叉树</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">链接</a></p>\n<p>递归</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSymmetric</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isSameTree</span>(root.<span class=\"property\">left</span>, root.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSameTree</span>(<span class=\"params\">p: TreeNode | <span class=\"literal\">null</span>, q: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p === <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p === <span class=\"literal\">null</span> &amp;&amp; q !== <span class=\"literal\">null</span>) || (p !== <span class=\"literal\">null</span> &amp;&amp; q === <span class=\"literal\">null</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p.<span class=\"property\">val</span> !== q.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">left</span>, q.<span class=\"property\">right</span>) &amp;&amp; <span class=\"title function_\">isSameTree</span>(p.<span class=\"property\">right</span>, q.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSymmetric</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = []</span><br><span class=\"line\">  nodeList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> preList = []</span><br><span class=\"line\">      <span class=\"keyword\">const</span> backList = []</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len / <span class=\"number\">2</span>;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> startNode = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> endNode = nodeL[len - i - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startNode === <span class=\"literal\">null</span> &amp;&amp; endNode === <span class=\"literal\">null</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">          (startNode === <span class=\"literal\">null</span> &amp;&amp; endNode !== <span class=\"literal\">null</span>) ||</span><br><span class=\"line\">          (startNode !== <span class=\"literal\">null</span> &amp;&amp; endNode === <span class=\"literal\">null</span>) ||</span><br><span class=\"line\">          (startNode.<span class=\"property\">val</span> !== endNode.<span class=\"property\">val</span>)</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        preList.<span class=\"title function_\">push</span>(startNode.<span class=\"property\">left</span>)</span><br><span class=\"line\">        preList.<span class=\"title function_\">push</span>(startNode.<span class=\"property\">right</span>)</span><br><span class=\"line\">        backList.<span class=\"title function_\">unshift</span>(endNode.<span class=\"property\">right</span>)</span><br><span class=\"line\">        backList.<span class=\"title function_\">unshift</span>(endNode.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      nodeList = preList.<span class=\"title function_\">concat</span>(backList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1008. 前序遍历构造二叉搜索树\n\n返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。\n\n(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）\n\n题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction bstFromPreorder(preorder: number[]): TreeNode | null {\n  if (preorder.length === 0) return null\n  function traverse(preorder: number[], startIndex: number, endIndex: number) {\n    if (startIndex > endIndex) return null\n    const node = new TreeNode(preorder[startIndex])\n    let leftEndIndex = startIndex + 1\n    for(; leftEndIndex <= endIndex; leftEndIndex++) {\n      if (preorder[startIndex] < preorder[leftEndIndex]) break\n    }\n    node.left = traverse(preorder, startIndex + 1, leftEndIndex - 1)\n    node.right = traverse(preorder, leftEndIndex, endIndex)\n    return node\n  }\n  return traverse(preorder, 0, preorder.length - 1)\n};\n```\n","source":"leetcode/二叉树/1008.前序遍历构造二叉搜索树.md","raw":"# 1008. 前序遍历构造二叉搜索树\n\n返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。\n\n(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）\n\n题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction bstFromPreorder(preorder: number[]): TreeNode | null {\n  if (preorder.length === 0) return null\n  function traverse(preorder: number[], startIndex: number, endIndex: number) {\n    if (startIndex > endIndex) return null\n    const node = new TreeNode(preorder[startIndex])\n    let leftEndIndex = startIndex + 1\n    for(; leftEndIndex <= endIndex; leftEndIndex++) {\n      if (preorder[startIndex] < preorder[leftEndIndex]) break\n    }\n    node.left = traverse(preorder, startIndex + 1, leftEndIndex - 1)\n    node.right = traverse(preorder, leftEndIndex, endIndex)\n    return node\n  }\n  return traverse(preorder, 0, preorder.length - 1)\n};\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.543Z","path":"leetcode/二叉树/1008.前序遍历构造二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000ktnw7c95lftsr","content":"<h1 id=\"1008-前序遍历构造二叉搜索树\"><a href=\"#1008-前序遍历构造二叉搜索树\" class=\"headerlink\" title=\"1008. 前序遍历构造二叉搜索树\"></a>1008. 前序遍历构造二叉搜索树</h1><p>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</p>\n<p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）</p>\n<p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bstFromPreorder</span>(<span class=\"params\">preorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preorder.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">preorder: <span class=\"built_in\">number</span>[], startIndex: <span class=\"built_in\">number</span>, endIndex: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startIndex &gt; endIndex) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(preorder[startIndex])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> leftEndIndex = startIndex + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; leftEndIndex &lt;= endIndex; leftEndIndex++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (preorder[startIndex] &lt; preorder[leftEndIndex]) <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node.<span class=\"property\">left</span> = <span class=\"title function_\">traverse</span>(preorder, startIndex + <span class=\"number\">1</span>, leftEndIndex - <span class=\"number\">1</span>)</span><br><span class=\"line\">    node.<span class=\"property\">right</span> = <span class=\"title function_\">traverse</span>(preorder, leftEndIndex, endIndex)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(preorder, <span class=\"number\">0</span>, preorder.<span class=\"property\">length</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1008-前序遍历构造二叉搜索树\"><a href=\"#1008-前序遍历构造二叉搜索树\" class=\"headerlink\" title=\"1008. 前序遍历构造二叉搜索树\"></a>1008. 前序遍历构造二叉搜索树</h1><p>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</p>\n<p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）</p>\n<p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bstFromPreorder</span>(<span class=\"params\">preorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preorder.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">preorder: <span class=\"built_in\">number</span>[], startIndex: <span class=\"built_in\">number</span>, endIndex: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startIndex &gt; endIndex) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(preorder[startIndex])</span><br><span class=\"line\">    <span class=\"keyword\">let</span> leftEndIndex = startIndex + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; leftEndIndex &lt;= endIndex; leftEndIndex++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (preorder[startIndex] &lt; preorder[leftEndIndex]) <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node.<span class=\"property\">left</span> = <span class=\"title function_\">traverse</span>(preorder, startIndex + <span class=\"number\">1</span>, leftEndIndex - <span class=\"number\">1</span>)</span><br><span class=\"line\">    node.<span class=\"property\">right</span> = <span class=\"title function_\">traverse</span>(preorder, leftEndIndex, endIndex)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(preorder, <span class=\"number\">0</span>, preorder.<span class=\"property\">length</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 102. 二叉树的层序遍历\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\n```ts\nfunction levelOrder(root: TreeNode | null): number[][] {\n  if (root === null) return []\n  const nodeList: Array<TreeNode | null> = [root]\n  const res = []\n  while(nodeList.length > 0) {\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n      res.push([parent.val])\n    } else {\n      const nodeL = nodeList.splice(0)\n      const len = nodeL.length\n      const valList = []\n      for(let i = 0; i < len;i++) {\n        const node = nodeL[i]\n        if (node) {\n          valList.push(node.val)\n          nodeList.push(node.left)\n          nodeList.push(node.right)\n        }\n      }\n      valList.length > 0 && res.push(valList)\n    }\n  }\n  return res\n}\n```\n","source":"leetcode/二叉树/102.二叉树的层序遍历.md","raw":"# 102. 二叉树的层序遍历\n\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\n```ts\nfunction levelOrder(root: TreeNode | null): number[][] {\n  if (root === null) return []\n  const nodeList: Array<TreeNode | null> = [root]\n  const res = []\n  while(nodeList.length > 0) {\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n      res.push([parent.val])\n    } else {\n      const nodeL = nodeList.splice(0)\n      const len = nodeL.length\n      const valList = []\n      for(let i = 0; i < len;i++) {\n        const node = nodeL[i]\n        if (node) {\n          valList.push(node.val)\n          nodeList.push(node.left)\n          nodeList.push(node.right)\n        }\n      }\n      valList.length > 0 && res.push(valList)\n    }\n  }\n  return res\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.544Z","path":"leetcode/二叉树/102.二叉树的层序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000ltnw76qchdg7l","content":"<h1 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a>102. 二叉树的层序遍历</h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">levelOrder</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = [root]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>([parent.<span class=\"property\">val</span>])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> valList = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">          valList.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      valList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">push</span>(valList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a>102. 二叉树的层序遍历</h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">levelOrder</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = [root]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>([parent.<span class=\"property\">val</span>])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> valList = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">          valList.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      valList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">push</span>(valList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1022. 从根到叶的二进制数之和\n\n给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。\n\n对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。\n\n返回这些数字之和。题目数据保证答案是一个 32 位 整数。\n\n[链接](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumRootToLeaf = function(root) {\n  const paths: string[] = []\n  function findPath(node: TreeNode, path: string) {\n    if (node === null) return\n    path += node.val.toString()\n    if (!node.left && !node.right) {\n      paths.push(path)\n      return\n    }\n    findPath(node.left, path)\n    findPath(node.right, path)\n  }\n  findPath(root, \"\")\n  return paths.reduce((pre, data) => {\n    pre += parseInt(data, 2)\n    return pre\n  }, 0)\n};\n```\n","source":"leetcode/二叉树/1022.从根到叶的二进制数之和.md","raw":"# 1022. 从根到叶的二进制数之和\n\n给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。\n\n对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。\n\n返回这些数字之和。题目数据保证答案是一个 32 位 整数。\n\n[链接](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumRootToLeaf = function(root) {\n  const paths: string[] = []\n  function findPath(node: TreeNode, path: string) {\n    if (node === null) return\n    path += node.val.toString()\n    if (!node.left && !node.right) {\n      paths.push(path)\n      return\n    }\n    findPath(node.left, path)\n    findPath(node.right, path)\n  }\n  findPath(root, \"\")\n  return paths.reduce((pre, data) => {\n    pre += parseInt(data, 2)\n    return pre\n  }, 0)\n};\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.545Z","path":"leetcode/二叉树/1022.从根到叶的二进制数之和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000mtnw7fu6i33tl","content":"<h1 id=\"1022-从根到叶的二进制数之和\"><a href=\"#1022-从根到叶的二进制数之和\" class=\"headerlink\" title=\"1022. 从根到叶的二进制数之和\"></a>1022. 从根到叶的二进制数之和</h1><p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>\n<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>\n<p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sumRootToLeaf = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">paths</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">findPath</span>(<span class=\"params\">node: TreeNode, path: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    path += node.<span class=\"property\">val</span>.<span class=\"title function_\">toString</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.<span class=\"property\">left</span> &amp;&amp; !node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      paths.<span class=\"title function_\">push</span>(path)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">findPath</span>(node.<span class=\"property\">left</span>, path)</span><br><span class=\"line\">    <span class=\"title function_\">findPath</span>(node.<span class=\"property\">right</span>, path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findPath</span>(root, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    pre += <span class=\"built_in\">parseInt</span>(data, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1022-从根到叶的二进制数之和\"><a href=\"#1022-从根到叶的二进制数之和\" class=\"headerlink\" title=\"1022. 从根到叶的二进制数之和\"></a>1022. 从根到叶的二进制数之和</h1><p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>\n<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>\n<p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sumRootToLeaf = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">paths</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">findPath</span>(<span class=\"params\">node: TreeNode, path: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    path += node.<span class=\"property\">val</span>.<span class=\"title function_\">toString</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.<span class=\"property\">left</span> &amp;&amp; !node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      paths.<span class=\"title function_\">push</span>(path)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">findPath</span>(node.<span class=\"property\">left</span>, path)</span><br><span class=\"line\">    <span class=\"title function_\">findPath</span>(node.<span class=\"property\">right</span>, path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findPath</span>(root, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    pre += <span class=\"built_in\">parseInt</span>(data, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1026. 节点与其祖先之间的最大差值\n\n给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。\n\n（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n\n[链接](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxAncestorDiff(root: TreeNode | null): number {\n  if (root === null) return 0\n  function dfs(node: TreeNode | null, max: number, min: number) {\n    if (node === null) return 0\n    if (node.val > max) max = node.val\n    else if (node.val < min) min = node.val\n\n    if (node.left === null && node.right === null) {\n      return max - min\n    }\n\n    const l = dfs(node.left, max, min)\n    const r = dfs(node.right, max, min)\n\n    return Math.max(l, r)\n  }\n\n\n  const l = dfs(root.left, root.val, root.val)\n  const r = dfs(root.right, root.val, root.val)\n  return Math.max(l, r)\n};\n```\n","source":"leetcode/二叉树/1026.节点与其祖先之间的最大差值.md","raw":"# 1026. 节点与其祖先之间的最大差值\n\n给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。\n\n（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n\n[链接](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxAncestorDiff(root: TreeNode | null): number {\n  if (root === null) return 0\n  function dfs(node: TreeNode | null, max: number, min: number) {\n    if (node === null) return 0\n    if (node.val > max) max = node.val\n    else if (node.val < min) min = node.val\n\n    if (node.left === null && node.right === null) {\n      return max - min\n    }\n\n    const l = dfs(node.left, max, min)\n    const r = dfs(node.right, max, min)\n\n    return Math.max(l, r)\n  }\n\n\n  const l = dfs(root.left, root.val, root.val)\n  const r = dfs(root.right, root.val, root.val)\n  return Math.max(l, r)\n};\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.545Z","path":"leetcode/二叉树/1026.节点与其祖先之间的最大差值.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000ntnw778035zu9","content":"<h1 id=\"1026-节点与其祖先之间的最大差值\"><a href=\"#1026-节点与其祖先之间的最大差值\" class=\"headerlink\" title=\"1026. 节点与其祖先之间的最大差值\"></a>1026. 节点与其祖先之间的最大差值</h1><p>给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。</p>\n<p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxAncestorDiff</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, max: <span class=\"built_in\">number</span>, min: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt; max) max = node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &lt; min) min = node.<span class=\"property\">val</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max - min</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, max, min)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, max, min)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(l, r)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(root.<span class=\"property\">left</span>, root.<span class=\"property\">val</span>, root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(root.<span class=\"property\">right</span>, root.<span class=\"property\">val</span>, root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(l, r)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1026-节点与其祖先之间的最大差值\"><a href=\"#1026-节点与其祖先之间的最大差值\" class=\"headerlink\" title=\"1026. 节点与其祖先之间的最大差值\"></a>1026. 节点与其祖先之间的最大差值</h1><p>给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。</p>\n<p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxAncestorDiff</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, max: <span class=\"built_in\">number</span>, min: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt; max) max = node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &lt; min) min = node.<span class=\"property\">val</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> max - min</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, max, min)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, max, min)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(l, r)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(root.<span class=\"property\">left</span>, root.<span class=\"property\">val</span>, root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(root.<span class=\"property\">right</span>, root.<span class=\"property\">val</span>, root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(l, r)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 103. 二叉树的锯齿形层序遍历\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n```ts\nfunction zigzagLevelOrder(root: TreeNode | null): number[][] {\n  if (root === null) return []\n  const nodeList: Array<TreeNode | null> = [root]\n  let isResverse = false\n  const res = []\n  while(nodeList.length > 0) {\n    const method = isResverse ? Array.prototype.unshift : Array.prototype.push\n    isResverse = !isResverse\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n      res.push([parent.val])\n    } else {\n      const nodeL = nodeList.splice(0)\n      const len = nodeL.length\n      const valList = []\n      for(let i = 0; i < len;i++) {\n        const node = nodeL[i]\n        if (node) {\n          method.call(valList, node.val)\n          nodeList.push(node.left)\n          nodeList.push(node.right)\n        }\n      }\n      valList.length > 0 && res.push(valList)\n    }\n  }\n  return res\n}\n```\n","source":"leetcode/二叉树/103.二叉树的锯齿形层序遍历.md","raw":"# 103. 二叉树的锯齿形层序遍历\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n```ts\nfunction zigzagLevelOrder(root: TreeNode | null): number[][] {\n  if (root === null) return []\n  const nodeList: Array<TreeNode | null> = [root]\n  let isResverse = false\n  const res = []\n  while(nodeList.length > 0) {\n    const method = isResverse ? Array.prototype.unshift : Array.prototype.push\n    isResverse = !isResverse\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n      res.push([parent.val])\n    } else {\n      const nodeL = nodeList.splice(0)\n      const len = nodeL.length\n      const valList = []\n      for(let i = 0; i < len;i++) {\n        const node = nodeL[i]\n        if (node) {\n          method.call(valList, node.val)\n          nodeList.push(node.left)\n          nodeList.push(node.right)\n        }\n      }\n      valList.length > 0 && res.push(valList)\n    }\n  }\n  return res\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.546Z","path":"leetcode/二叉树/103.二叉树的锯齿形层序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000otnw70b5e8rea","content":"<h1 id=\"103-二叉树的锯齿形层序遍历\"><a href=\"#103-二叉树的锯齿形层序遍历\" class=\"headerlink\" title=\"103. 二叉树的锯齿形层序遍历\"></a>103. 二叉树的锯齿形层序遍历</h1><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">zigzagLevelOrder</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isResverse = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> method = isResverse ? <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">unshift</span> : <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">push</span></span><br><span class=\"line\">    isResverse = !isResverse</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>([parent.<span class=\"property\">val</span>])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> valList = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">          method.<span class=\"title function_\">call</span>(valList, node.<span class=\"property\">val</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      valList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">push</span>(valList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"103-二叉树的锯齿形层序遍历\"><a href=\"#103-二叉树的锯齿形层序遍历\" class=\"headerlink\" title=\"103. 二叉树的锯齿形层序遍历\"></a>103. 二叉树的锯齿形层序遍历</h1><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">zigzagLevelOrder</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isResverse = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> method = isResverse ? <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">unshift</span> : <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">push</span></span><br><span class=\"line\">    isResverse = !isResverse</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>([parent.<span class=\"property\">val</span>])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> valList = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">          method.<span class=\"title function_\">call</span>(valList, node.<span class=\"property\">val</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      valList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">push</span>(valList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1038. 把二叉搜索树转换为累加树\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n提醒一下，二叉搜索树满足下列约束条件：\n\n节点的左子树仅包含键 小于 节点键的节点。\n节点的右子树仅包含键 大于 节点键的节点。\n左右子树也必须是二叉搜索树。\n\n[链接](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nlet total = 0\n\nfunction bstToGst(root: TreeNode | null): TreeNode | null {\n  total = 0\n  traverse(root)\n  return root\n};\n\nfunction traverse(root: TreeNode | null): void {\n  if (root === null) return\n  traverse(root.right)\n  total += root.val\n  root.val = total\n  traverse(root.left)\n}\n```\n","source":"leetcode/二叉树/1038.把二叉搜索树转换为累加树.md","raw":"# 1038. 把二叉搜索树转换为累加树\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n提醒一下，二叉搜索树满足下列约束条件：\n\n节点的左子树仅包含键 小于 节点键的节点。\n节点的右子树仅包含键 大于 节点键的节点。\n左右子树也必须是二叉搜索树。\n\n[链接](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nlet total = 0\n\nfunction bstToGst(root: TreeNode | null): TreeNode | null {\n  total = 0\n  traverse(root)\n  return root\n};\n\nfunction traverse(root: TreeNode | null): void {\n  if (root === null) return\n  traverse(root.right)\n  total += root.val\n  root.val = total\n  traverse(root.left)\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.546Z","path":"leetcode/二叉树/1038.把二叉搜索树转换为累加树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000ptnw74dltebkl","content":"<h1 id=\"1038-把二叉搜索树转换为累加树\"><a href=\"#1038-把二叉搜索树转换为累加树\" class=\"headerlink\" title=\"1038. 把二叉搜索树转换为累加树\"></a>1038. 把二叉搜索树转换为累加树</h1><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bstToGst</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  total += root.<span class=\"property\">val</span></span><br><span class=\"line\">  root.<span class=\"property\">val</span> = total</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1038-把二叉搜索树转换为累加树\"><a href=\"#1038-把二叉搜索树转换为累加树\" class=\"headerlink\" title=\"1038. 把二叉搜索树转换为累加树\"></a>1038. 把二叉搜索树转换为累加树</h1><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bstToGst</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  total += root.<span class=\"property\">val</span></span><br><span class=\"line\">  root.<span class=\"property\">val</span> = total</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 104. 二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n[链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n```ts\nfunction maxDepth(root: TreeNode | null): number {\n  return traverse(root, 0)\n}\n\nfunction traverse(root: TreeNode, depth: number): number {\n  if (root === null) return depth\n  const leftD = traverse(root.left, depth + 1)\n  const rightD = traverse(root.right, depth + 1)\n  return Math.max(leftD, rightD)\n}\n```\n","source":"leetcode/二叉树/104.二叉树的最大深度.md","raw":"# 104. 二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n[链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n```ts\nfunction maxDepth(root: TreeNode | null): number {\n  return traverse(root, 0)\n}\n\nfunction traverse(root: TreeNode, depth: number): number {\n  if (root === null) return depth\n  const leftD = traverse(root.left, depth + 1)\n  const rightD = traverse(root.right, depth + 1)\n  return Math.max(leftD, rightD)\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.546Z","path":"leetcode/二叉树/104.二叉树的最大深度.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000qtnw7hl74f4kg","content":"<h1 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a>104. 二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxDepth</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, depth: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> depth</span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftD = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rightD = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(leftD, rightD)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a>104. 二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxDepth</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, depth: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> depth</span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftD = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rightD = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(leftD, rightD)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 105. 从前序与中序遍历序列构造二叉树\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n```ts\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n  return build(\n    preorder, 0, preorder.length - 1,\n    inorder, 0, inorder.length - 1\n  )\n}\n\nfunction build(\n  preorder: number[], preStart: number, preEnd: number,\n  inorder: number[], inStart: number, inEnd: number\n): TreeNode | null {\n  if (preStart > preEnd) return null\n  const rootVal = preorder[preStart]\n  let index = 0\n  for(let i = inStart;i <= inEnd;i++) {\n    if (inorder[i] === rootVal) {\n      index = i\n      break\n    }\n  }\n  const leftSize = index - inStart\n  const root = new TreeNode(rootVal)\n  root.left = build(\n    preorder, preStart + 1, preStart + leftSize,\n    inorder, inStart, index - 1\n  )\n  root.right = build(\n    preorder, preStart + leftSize + 1, preEnd,\n    inorder, index + 1, inEnd\n  )\n  return root\n}\n```\n","source":"leetcode/二叉树/105.从前序与中序遍历序列构造二叉树.md","raw":"# 105. 从前序与中序遍历序列构造二叉树\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n```ts\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n  return build(\n    preorder, 0, preorder.length - 1,\n    inorder, 0, inorder.length - 1\n  )\n}\n\nfunction build(\n  preorder: number[], preStart: number, preEnd: number,\n  inorder: number[], inStart: number, inEnd: number\n): TreeNode | null {\n  if (preStart > preEnd) return null\n  const rootVal = preorder[preStart]\n  let index = 0\n  for(let i = inStart;i <= inEnd;i++) {\n    if (inorder[i] === rootVal) {\n      index = i\n      break\n    }\n  }\n  const leftSize = index - inStart\n  const root = new TreeNode(rootVal)\n  root.left = build(\n    preorder, preStart + 1, preStart + leftSize,\n    inorder, inStart, index - 1\n  )\n  root.right = build(\n    preorder, preStart + leftSize + 1, preEnd,\n    inorder, index + 1, inEnd\n  )\n  return root\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.546Z","path":"leetcode/二叉树/105.从前序与中序遍历序列构造二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxm000rtnw780gz682a","content":"<h1 id=\"105-从前序与中序遍历序列构造二叉树\"><a href=\"#105-从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"105. 从前序与中序遍历序列构造二叉树\"></a>105. 从前序与中序遍历序列构造二叉树</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildTree</span>(<span class=\"params\">preorder: <span class=\"built_in\">number</span>[], inorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    preorder, <span class=\"number\">0</span>, preorder.<span class=\"property\">length</span> - <span class=\"number\">1</span>,</span><br><span class=\"line\">    inorder, <span class=\"number\">0</span>, inorder.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  preorder: <span class=\"built_in\">number</span>[], preStart: <span class=\"built_in\">number</span>, preEnd: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  inorder: <span class=\"built_in\">number</span>[], inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preStart &gt; preEnd) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = preorder[preStart]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = inStart;i &lt;= inEnd;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inorder[i] === rootVal) &#123;</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftSize = index - inStart</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootVal)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    preorder, preStart + <span class=\"number\">1</span>, preStart + leftSize,</span><br><span class=\"line\">    inorder, inStart, index - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    preorder, preStart + leftSize + <span class=\"number\">1</span>, preEnd,</span><br><span class=\"line\">    inorder, index + <span class=\"number\">1</span>, inEnd</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"105-从前序与中序遍历序列构造二叉树\"><a href=\"#105-从前序与中序遍历序列构造二叉树\" class=\"headerlink\" title=\"105. 从前序与中序遍历序列构造二叉树\"></a>105. 从前序与中序遍历序列构造二叉树</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildTree</span>(<span class=\"params\">preorder: <span class=\"built_in\">number</span>[], inorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    preorder, <span class=\"number\">0</span>, preorder.<span class=\"property\">length</span> - <span class=\"number\">1</span>,</span><br><span class=\"line\">    inorder, <span class=\"number\">0</span>, inorder.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  preorder: <span class=\"built_in\">number</span>[], preStart: <span class=\"built_in\">number</span>, preEnd: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  inorder: <span class=\"built_in\">number</span>[], inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preStart &gt; preEnd) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = preorder[preStart]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = inStart;i &lt;= inEnd;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inorder[i] === rootVal) &#123;</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftSize = index - inStart</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootVal)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    preorder, preStart + <span class=\"number\">1</span>, preStart + leftSize,</span><br><span class=\"line\">    inorder, inStart, index - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    preorder, preStart + leftSize + <span class=\"number\">1</span>, preEnd,</span><br><span class=\"line\">    inorder, index + <span class=\"number\">1</span>, inEnd</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 106. 从中序与后序遍历序列构造二叉树\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n注意:\n你可以假设树中没有重复的元素。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n```ts\nfunction buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n  return build(\n    inorder, 0, inorder.length - 1,\n    postorder, 0, postorder.length - 1\n  )\n}\n\nfunction build(\n  inorder: number[], inStart: number, inEnd: number,\n  postorder: number[], postStart: number, postEnd: number\n): TreeNode | null {\n  if (inStart > inEnd) return null\n  const rootVal = postorder[postEnd]\n  let index = 0\n  for(let i = inStart;i <= inEnd;i++) {\n    if (inorder[i] === rootVal) {\n      index = i\n      break\n    }\n  }\n  const leftSize = index - inStart\n  const root = new TreeNode(rootVal)\n  root.left = build(\n    inorder, inStart, index - 1,\n    postorder, postStart, postStart + leftSize - 1\n  )\n  root.right = build(\n    inorder, index + 1, inEnd,\n    postorder, postStart + leftSize, postEnd - 1\n  )\n  return root\n}\n```\n","source":"leetcode/二叉树/106.从中序与后序遍历序列构造二叉树.md","raw":"# 106. 从中序与后序遍历序列构造二叉树\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n注意:\n你可以假设树中没有重复的元素。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n```ts\nfunction buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n  return build(\n    inorder, 0, inorder.length - 1,\n    postorder, 0, postorder.length - 1\n  )\n}\n\nfunction build(\n  inorder: number[], inStart: number, inEnd: number,\n  postorder: number[], postStart: number, postEnd: number\n): TreeNode | null {\n  if (inStart > inEnd) return null\n  const rootVal = postorder[postEnd]\n  let index = 0\n  for(let i = inStart;i <= inEnd;i++) {\n    if (inorder[i] === rootVal) {\n      index = i\n      break\n    }\n  }\n  const leftSize = index - inStart\n  const root = new TreeNode(rootVal)\n  root.left = build(\n    inorder, inStart, index - 1,\n    postorder, postStart, postStart + leftSize - 1\n  )\n  root.right = build(\n    inorder, index + 1, inEnd,\n    postorder, postStart + leftSize, postEnd - 1\n  )\n  return root\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.547Z","path":"leetcode/二叉树/106.从中序与后序遍历序列构造二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000stnw70rzs9zyi","content":"<h1 id=\"106-从中序与后序遍历序列构造二叉树\"><a href=\"#106-从中序与后序遍历序列构造二叉树\" class=\"headerlink\" title=\"106. 从中序与后序遍历序列构造二叉树\"></a>106. 从中序与后序遍历序列构造二叉树</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>\n<p>注意:<br>你可以假设树中没有重复的元素。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildTree</span>(<span class=\"params\">inorder: <span class=\"built_in\">number</span>[], postorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    inorder, <span class=\"number\">0</span>, inorder.<span class=\"property\">length</span> - <span class=\"number\">1</span>,</span><br><span class=\"line\">    postorder, <span class=\"number\">0</span>, postorder.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  inorder: <span class=\"built_in\">number</span>[], inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  postorder: <span class=\"built_in\">number</span>[], postStart: <span class=\"built_in\">number</span>, postEnd: <span class=\"built_in\">number</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inStart &gt; inEnd) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = postorder[postEnd]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = inStart;i &lt;= inEnd;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inorder[i] === rootVal) &#123;</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftSize = index - inStart</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootVal)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    inorder, inStart, index - <span class=\"number\">1</span>,</span><br><span class=\"line\">    postorder, postStart, postStart + leftSize - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    inorder, index + <span class=\"number\">1</span>, inEnd,</span><br><span class=\"line\">    postorder, postStart + leftSize, postEnd - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"106-从中序与后序遍历序列构造二叉树\"><a href=\"#106-从中序与后序遍历序列构造二叉树\" class=\"headerlink\" title=\"106. 从中序与后序遍历序列构造二叉树\"></a>106. 从中序与后序遍历序列构造二叉树</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>\n<p>注意:<br>你可以假设树中没有重复的元素。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildTree</span>(<span class=\"params\">inorder: <span class=\"built_in\">number</span>[], postorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    inorder, <span class=\"number\">0</span>, inorder.<span class=\"property\">length</span> - <span class=\"number\">1</span>,</span><br><span class=\"line\">    postorder, <span class=\"number\">0</span>, postorder.<span class=\"property\">length</span> - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  inorder: <span class=\"built_in\">number</span>[], inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  postorder: <span class=\"built_in\">number</span>[], postStart: <span class=\"built_in\">number</span>, postEnd: <span class=\"built_in\">number</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inStart &gt; inEnd) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = postorder[postEnd]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = inStart;i &lt;= inEnd;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inorder[i] === rootVal) &#123;</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftSize = index - inStart</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootVal)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    inorder, inStart, index - <span class=\"number\">1</span>,</span><br><span class=\"line\">    postorder, postStart, postStart + leftSize - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(</span><br><span class=\"line\">    inorder, index + <span class=\"number\">1</span>, inEnd,</span><br><span class=\"line\">    postorder, postStart + leftSize, postEnd - <span class=\"number\">1</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 107. 二叉树的层序遍历 II\n\n给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n\n```ts\nfunction levelOrderBottom(root: TreeNode | null): number[][] {\n  if (root === null) return []\n  const nodeList: Array<TreeNode | null> = [root]\n  // let isResverse = false\n  const res = []\n  while(nodeList.length > 0) {\n    // const method = isResverse ? Array.prototype.unshift : Array.prototype.push\n    // isResverse = !isResverse\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n      res.unshift([parent.val])\n    } else {\n      const nodeL = nodeList.splice(0)\n      const len = nodeL.length\n      const valList = []\n      for(let i = 0; i < len;i++) {\n        const node = nodeL[i]\n        if (node) {\n          valList.push(node.val)\n          nodeList.push(node.left)\n          nodeList.push(node.right)\n        }\n      }\n      valList.length > 0 && res.unshift(valList)\n    }\n  }\n  return res\n}\n```\n","source":"leetcode/二叉树/107.二叉树的层序遍历II.md","raw":"# 107. 二叉树的层序遍历 II\n\n给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n\n```ts\nfunction levelOrderBottom(root: TreeNode | null): number[][] {\n  if (root === null) return []\n  const nodeList: Array<TreeNode | null> = [root]\n  // let isResverse = false\n  const res = []\n  while(nodeList.length > 0) {\n    // const method = isResverse ? Array.prototype.unshift : Array.prototype.push\n    // isResverse = !isResverse\n    if (nodeList.length === 1) {\n      const parent = nodeList.shift()\n      nodeList.push(parent.left)\n      nodeList.push(parent.right)\n      res.unshift([parent.val])\n    } else {\n      const nodeL = nodeList.splice(0)\n      const len = nodeL.length\n      const valList = []\n      for(let i = 0; i < len;i++) {\n        const node = nodeL[i]\n        if (node) {\n          valList.push(node.val)\n          nodeList.push(node.left)\n          nodeList.push(node.right)\n        }\n      }\n      valList.length > 0 && res.unshift(valList)\n    }\n  }\n  return res\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.547Z","path":"leetcode/二叉树/107.二叉树的层序遍历II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000ttnw756u58cq2","content":"<h1 id=\"107-二叉树的层序遍历-II\"><a href=\"#107-二叉树的层序遍历-II\" class=\"headerlink\" title=\"107. 二叉树的层序遍历 II\"></a>107. 二叉树的层序遍历 II</h1><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">levelOrderBottom</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = [root]</span><br><span class=\"line\">  <span class=\"comment\">// let isResverse = false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// const method = isResverse ? Array.prototype.unshift : Array.prototype.push</span></span><br><span class=\"line\">    <span class=\"comment\">// isResverse = !isResverse</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">      res.<span class=\"title function_\">unshift</span>([parent.<span class=\"property\">val</span>])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> valList = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">          valList.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      valList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">unshift</span>(valList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"107-二叉树的层序遍历-II\"><a href=\"#107-二叉树的层序遍历-II\" class=\"headerlink\" title=\"107. 二叉树的层序遍历 II\"></a>107. 二叉树的层序遍历 II</h1><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">levelOrderBottom</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = [root]</span><br><span class=\"line\">  <span class=\"comment\">// let isResverse = false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// const method = isResverse ? Array.prototype.unshift : Array.prototype.push</span></span><br><span class=\"line\">    <span class=\"comment\">// isResverse = !isResverse</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeList.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parent = nodeList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">      nodeList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">      res.<span class=\"title function_\">unshift</span>([parent.<span class=\"property\">val</span>])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> valList = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">          valList.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      valList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">unshift</span>(valList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 108. 将有序数组转换为二叉搜索树\n\n给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n\n[链接](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)\n\n```ts\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n  if (nums.length === 0) return null\n  return traverse(nums, 0, nums.length - 1)\n};\n\nfunction traverse(inorder: number[], inStart: number, inEnd: number): TreeNode | null {\n  if (inStart > inEnd) return null\n  const midIndex = Math.floor((inEnd - inStart) / 2) + inStart\n  const rootVal = inorder[midIndex]\n  const root = new TreeNode(rootVal)\n  const left = traverse(inorder, inStart, midIndex - 1)\n  const right = traverse(inorder, midIndex + 1, inEnd)\n  root.left = left\n  root.right = right\n  return root\n}\n```\n","source":"leetcode/二叉树/108.将有序数组转换为二叉搜索树.md","raw":"# 108. 将有序数组转换为二叉搜索树\n\n给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n\n[链接](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)\n\n```ts\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n  if (nums.length === 0) return null\n  return traverse(nums, 0, nums.length - 1)\n};\n\nfunction traverse(inorder: number[], inStart: number, inEnd: number): TreeNode | null {\n  if (inStart > inEnd) return null\n  const midIndex = Math.floor((inEnd - inStart) / 2) + inStart\n  const rootVal = inorder[midIndex]\n  const root = new TreeNode(rootVal)\n  const left = traverse(inorder, inStart, midIndex - 1)\n  const right = traverse(inorder, midIndex + 1, inEnd)\n  root.left = left\n  root.right = right\n  return root\n}\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.547Z","path":"leetcode/二叉树/108.将有序数组转换为二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000utnw77fs5fvpf","content":"<h1 id=\"108-将有序数组转换为二叉搜索树\"><a href=\"#108-将有序数组转换为二叉搜索树\" class=\"headerlink\" title=\"108. 将有序数组转换为二叉搜索树\"></a>108. 将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>\n<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sortedArrayToBST</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">inorder: <span class=\"built_in\">number</span>[], inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inStart &gt; inEnd) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> midIndex = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>((inEnd - inStart) / <span class=\"number\">2</span>) + inStart</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = inorder[midIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootVal)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = <span class=\"title function_\">traverse</span>(inorder, inStart, midIndex - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = <span class=\"title function_\">traverse</span>(inorder, midIndex + <span class=\"number\">1</span>, inEnd)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = left</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = right</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"108-将有序数组转换为二叉搜索树\"><a href=\"#108-将有序数组转换为二叉搜索树\" class=\"headerlink\" title=\"108. 将有序数组转换为二叉搜索树\"></a>108. 将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>\n<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sortedArrayToBST</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">inorder: <span class=\"built_in\">number</span>[], inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inStart &gt; inEnd) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> midIndex = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>((inEnd - inStart) / <span class=\"number\">2</span>) + inStart</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = inorder[midIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootVal)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = <span class=\"title function_\">traverse</span>(inorder, inStart, midIndex - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = <span class=\"title function_\">traverse</span>(inorder, midIndex + <span class=\"number\">1</span>, inEnd)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = left</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = right</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 109. 有序链表转换二叉搜索树\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n[链接](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)\n\n```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction findMid(left: ListNode, right: ListNode): ListNode {\n  let slow = left\n  let fast = left\n  while(fast !== right && fast.next !== right) {\n    fast = fast.next\n    fast = fast.next\n    slow = slow.next\n  }\n  return slow\n}\nfunction dfs(left: ListNode, right: ListNode): TreeNode | null {\n  if (left === right) return null\n  const middle = findMid(left, right)\n  const root = new TreeNode(middle.val)\n  root.left = dfs(left, middle)\n  root.right = dfs(middle.next, right)\n  return root\n}\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n  return dfs(head, null);\n};\n```\n","source":"leetcode/二叉树/109.有序链表转换二叉搜索树.md","raw":"# 109. 有序链表转换二叉搜索树\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n[链接](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)\n\n```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction findMid(left: ListNode, right: ListNode): ListNode {\n  let slow = left\n  let fast = left\n  while(fast !== right && fast.next !== right) {\n    fast = fast.next\n    fast = fast.next\n    slow = slow.next\n  }\n  return slow\n}\nfunction dfs(left: ListNode, right: ListNode): TreeNode | null {\n  if (left === right) return null\n  const middle = findMid(left, right)\n  const root = new TreeNode(middle.val)\n  root.left = dfs(left, middle)\n  root.right = dfs(middle.next, right)\n  return root\n}\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n  return dfs(head, null);\n};\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.548Z","path":"leetcode/二叉树/109.有序链表转换二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000vtnw759921l9q","content":"<h1 id=\"109-有序链表转换二叉搜索树\"><a href=\"#109-有序链表转换二叉搜索树\" class=\"headerlink\" title=\"109. 有序链表转换二叉搜索树\"></a>109. 有序链表转换二叉搜索树</h1><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>\n<p><a href=\"https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     next: ListNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.next = (next===undefined ? null : next)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMid</span>(<span class=\"params\">left: ListNode, right: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = left</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fast = left</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(fast !== right &amp;&amp; fast.<span class=\"property\">next</span> !== right) &#123;</span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span></span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span></span><br><span class=\"line\">    slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">left: ListNode, right: ListNode</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left === right) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> middle = <span class=\"title function_\">findMid</span>(left, right)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(middle.<span class=\"property\">val</span>)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">dfs</span>(left, middle)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">dfs</span>(middle.<span class=\"property\">next</span>, right)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sortedListToBST</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(head, <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"109-有序链表转换二叉搜索树\"><a href=\"#109-有序链表转换二叉搜索树\" class=\"headerlink\" title=\"109. 有序链表转换二叉搜索树\"></a>109. 有序链表转换二叉搜索树</h1><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>\n<p><a href=\"https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     next: ListNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.next = (next===undefined ? null : next)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMid</span>(<span class=\"params\">left: ListNode, right: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = left</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fast = left</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(fast !== right &amp;&amp; fast.<span class=\"property\">next</span> !== right) &#123;</span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span></span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span></span><br><span class=\"line\">    slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">left: ListNode, right: ListNode</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left === right) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> middle = <span class=\"title function_\">findMid</span>(left, right)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(middle.<span class=\"property\">val</span>)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">dfs</span>(left, middle)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">dfs</span>(middle.<span class=\"property\">next</span>, right)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sortedListToBST</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(head, <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1080. 根到叶路径上的不足节点\n\n给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）\n\n假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。\n\n请你删除所有不足节点，并返回生成的二叉树的根。\n\n[链接](https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} limit\n * @return {TreeNode}\n */\nvar sufficientSubset = function(root, limit) {\n  if (root === null) return null\n\n  if (root.left === null && root.right === null) {\n    if (root.val < limit) {\n      return null\n    }\n    return root\n  }\n\n  limit -= root.val\n  root.left = sufficientSubset(root.left, limit)\n  root.right = sufficientSubset(root.right, limit)\n\n  if (root.left == null && root.right === null) {\n    return null\n  }\n  \n  return root\n};\n```\n","source":"leetcode/二叉树/1080.根到叶路径上的不足节点.md","raw":"# 1080. 根到叶路径上的不足节点\n\n给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）\n\n假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。\n\n请你删除所有不足节点，并返回生成的二叉树的根。\n\n[链接](https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} limit\n * @return {TreeNode}\n */\nvar sufficientSubset = function(root, limit) {\n  if (root === null) return null\n\n  if (root.left === null && root.right === null) {\n    if (root.val < limit) {\n      return null\n    }\n    return root\n  }\n\n  limit -= root.val\n  root.left = sufficientSubset(root.left, limit)\n  root.right = sufficientSubset(root.right, limit)\n\n  if (root.left == null && root.right === null) {\n    return null\n  }\n  \n  return root\n};\n```\n","date":"2023-10-11T15:10:43.202Z","updated":"2023-09-26T14:49:23.547Z","path":"leetcode/二叉树/1080.根到叶路径上的不足节点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000wtnw71yqihvsq","content":"<h1 id=\"1080-根到叶路径上的不足节点\"><a href=\"#1080-根到叶路径上的不足节点\" class=\"headerlink\" title=\"1080. 根到叶路径上的不足节点\"></a>1080. 根到叶路径上的不足节点</h1><p>给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）</p>\n<p>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。</p>\n<p>请你删除所有不足节点，并返回生成的二叉树的根。</p>\n<p><a href=\"https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">limit</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sufficientSubset = <span class=\"keyword\">function</span>(<span class=\"params\">root, limit</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &lt; limit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  limit -= root.<span class=\"property\">val</span></span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">sufficientSubset</span>(root.<span class=\"property\">left</span>, limit)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">sufficientSubset</span>(root.<span class=\"property\">right</span>, limit)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> == <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1080-根到叶路径上的不足节点\"><a href=\"#1080-根到叶路径上的不足节点\" class=\"headerlink\" title=\"1080. 根到叶路径上的不足节点\"></a>1080. 根到叶路径上的不足节点</h1><p>给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）</p>\n<p>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。</p>\n<p>请你删除所有不足节点，并返回生成的二叉树的根。</p>\n<p><a href=\"https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">limit</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sufficientSubset = <span class=\"keyword\">function</span>(<span class=\"params\">root, limit</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &lt; limit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  limit -= root.<span class=\"property\">val</span></span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">sufficientSubset</span>(root.<span class=\"property\">left</span>, limit)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">sufficientSubset</span>(root.<span class=\"property\">right</span>, limit)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> == <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 110. 平衡二叉树\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n\n[链接](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n```ts\nfunction isBalanced(root: TreeNode | null): boolean {\n  if (root === null) return true\n  return traverse(root) >= 0\n};\n\nfunction traverse(root: TreeNode): number {\n  if (root === null) return 0\n  const leftDep = traverse(root.left)\n  const rightDep = traverse(root.right)\n  if (leftDep == -1 || rightDep == -1 || Math.abs(leftDep - rightDep) > 1) {\n    return -1;\n  } else {\n    return Math.max(leftDep, rightDep) + 1;\n  }\n}\n```\n","source":"leetcode/二叉树/110.平衡二叉树.md","raw":"# 110. 平衡二叉树\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n\n[链接](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n```ts\nfunction isBalanced(root: TreeNode | null): boolean {\n  if (root === null) return true\n  return traverse(root) >= 0\n};\n\nfunction traverse(root: TreeNode): number {\n  if (root === null) return 0\n  const leftDep = traverse(root.left)\n  const rightDep = traverse(root.right)\n  if (leftDep == -1 || rightDep == -1 || Math.abs(leftDep - rightDep) > 1) {\n    return -1;\n  } else {\n    return Math.max(leftDep, rightDep) + 1;\n  }\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.548Z","path":"leetcode/二叉树/110.平衡二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000xtnw76hmw80x4","content":"<h1 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a>110. 平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isBalanced</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root) &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftDep = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rightDep = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (leftDep == -<span class=\"number\">1</span> || rightDep == -<span class=\"number\">1</span> || <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(leftDep - rightDep) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(leftDep, rightDep) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a>110. 平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isBalanced</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root) &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftDep = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rightDep = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (leftDep == -<span class=\"number\">1</span> || rightDep == -<span class=\"number\">1</span> || <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(leftDep - rightDep) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(leftDep, rightDep) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1104. 二叉树寻路\n\n在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。\n\n如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；\n\n而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。\n\n[链接](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree)\n\n```ts\nfunction pathInZigZagTree(label: number): number[] {\n  let depth = 0\n  let total = 0\n  let res: number[] = []\n  const depMap: Record<number, number> = {}\n  while(total < label) {\n    depth++\n    depMap[depth] = 2 ** (depth - 1)\n    total += depMap[depth]\n  }\n  while(depth > 0) {\n    const start = 2 ** (depth - 1)\n    const len = depMap[depth]\n    res.unshift(label)\n    label = Math.floor(((start + len - 1 - label) + start) / 2)\n    depth--\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/1104.二叉树寻路.md","raw":"# 1104. 二叉树寻路\n\n在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。\n\n如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；\n\n而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。\n\n[链接](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree)\n\n```ts\nfunction pathInZigZagTree(label: number): number[] {\n  let depth = 0\n  let total = 0\n  let res: number[] = []\n  const depMap: Record<number, number> = {}\n  while(total < label) {\n    depth++\n    depMap[depth] = 2 ** (depth - 1)\n    total += depMap[depth]\n  }\n  while(depth > 0) {\n    const start = 2 ** (depth - 1)\n    const len = depMap[depth]\n    res.unshift(label)\n    label = Math.floor(((start + len - 1 - label) + start) / 2)\n    depth--\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.548Z","path":"leetcode/二叉树/1104.二叉树寻路.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000ytnw7cbwwgta3","content":"<h1 id=\"1104-二叉树寻路\"><a href=\"#1104-二叉树寻路\" class=\"headerlink\" title=\"1104. 二叉树寻路\"></a>1104. 二叉树寻路</h1><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。</p>\n<p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p>\n<p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pathInZigZagTree</span>(<span class=\"params\">label: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">depMap</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(total &lt; label) &#123;</span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    depMap[depth] = <span class=\"number\">2</span> ** (depth - <span class=\"number\">1</span>)</span><br><span class=\"line\">    total += depMap[depth]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> start = <span class=\"number\">2</span> ** (depth - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = depMap[depth]</span><br><span class=\"line\">    res.<span class=\"title function_\">unshift</span>(label)</span><br><span class=\"line\">    label = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(((start + len - <span class=\"number\">1</span> - label) + start) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    depth--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1104-二叉树寻路\"><a href=\"#1104-二叉树寻路\" class=\"headerlink\" title=\"1104. 二叉树寻路\"></a>1104. 二叉树寻路</h1><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。</p>\n<p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p>\n<p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pathInZigZagTree</span>(<span class=\"params\">label: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">depMap</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(total &lt; label) &#123;</span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    depMap[depth] = <span class=\"number\">2</span> ** (depth - <span class=\"number\">1</span>)</span><br><span class=\"line\">    total += depMap[depth]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> start = <span class=\"number\">2</span> ** (depth - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = depMap[depth]</span><br><span class=\"line\">    res.<span class=\"title function_\">unshift</span>(label)</span><br><span class=\"line\">    label = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(((start + len - <span class=\"number\">1</span> - label) + start) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    depth--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 111. 二叉树的最小深度\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n[链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n\n```ts\nlet minDep = Number.MAX_VALUE\nfunction minDepth(root: TreeNode | null): number {\n  if (root === null) return 0\n  minDep = Number.MAX_VALUE\n  traverse(root, 1)\n  return minDep\n};\n\nfunction traverse(root: TreeNode | null, depth: number): void {\n  if (root === null || depth > minDep) {\n    return\n  }\n  if (root.left === null && root.right === null) {\n    minDep = minDep > depth ? depth : minDep\n    return\n  }\n  traverse(root.left, depth + 1)\n  traverse(root.right, depth + 1)\n}\n```\n","source":"leetcode/二叉树/111.二叉树的最小深度.md","raw":"# 111. 二叉树的最小深度\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n[链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n\n```ts\nlet minDep = Number.MAX_VALUE\nfunction minDepth(root: TreeNode | null): number {\n  if (root === null) return 0\n  minDep = Number.MAX_VALUE\n  traverse(root, 1)\n  return minDep\n};\n\nfunction traverse(root: TreeNode | null, depth: number): void {\n  if (root === null || depth > minDep) {\n    return\n  }\n  if (root.left === null && root.right === null) {\n    minDep = minDep > depth ? depth : minDep\n    return\n  }\n  traverse(root.left, depth + 1)\n  traverse(root.right, depth + 1)\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.548Z","path":"leetcode/二叉树/111.二叉树的最小深度.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn000ztnw7grv3594a","content":"<h1 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111. 二叉树的最小深度\"></a>111. 二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> minDep = <span class=\"title class_\">Number</span>.<span class=\"property\">MAX_VALUE</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minDepth</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  minDep = <span class=\"title class_\">Number</span>.<span class=\"property\">MAX_VALUE</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minDep</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, depth: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span> || depth &gt; minDep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    minDep = minDep &gt; depth ? depth : minDep</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111. 二叉树的最小深度\"></a>111. 二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> minDep = <span class=\"title class_\">Number</span>.<span class=\"property\">MAX_VALUE</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">minDepth</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  minDep = <span class=\"title class_\">Number</span>.<span class=\"property\">MAX_VALUE</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> minDep</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, depth: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span> || depth &gt; minDep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    minDep = minDep &gt; depth ? depth : minDep</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1110. 删点成林\n\n给出二叉树的根节点 root，树上每个节点都有一个不同的值。\n\n如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。\n\n返回森林中的每棵树。你可以按任意顺序组织答案。\n\n[链接](https://leetcode-cn.com/problems/delete-nodes-and-return-forest/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number[]} to_delete\n * @return {TreeNode[]}\n */\nvar delNodes = function(root, to_delete) {\n  const res = []\n  if (root === null) return res\n  function dfs(node) {\n    if (node === null || to_delete.length === 0) return\n    if (node.left) node.left.parent = node\n    if (node.right) node.right.parent = node\n    dfs(node.left)\n    dfs(node.right)\n    const index = to_delete.indexOf(node.val)\n    if (index !== -1) {\n      to_delete.splice(index, 1)\n      if (node.parent) {\n        if (node.parent.left === node) {\n          node.parent.left = null\n        } else {\n          node.parent.right = null  \n        }\n      }\n      if (node.left) {\n        res.push(node.left)\n      }\n      if (node.right) {\n        res.push(node.right)\n      }\n    } else if (root === node) {\n      res.push(node)\n    }\n  }\n\n  dfs(root)\n  return res\n};\n```\n","source":"leetcode/二叉树/1110.删点成林.md","raw":"# 1110. 删点成林\n\n给出二叉树的根节点 root，树上每个节点都有一个不同的值。\n\n如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。\n\n返回森林中的每棵树。你可以按任意顺序组织答案。\n\n[链接](https://leetcode-cn.com/problems/delete-nodes-and-return-forest/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number[]} to_delete\n * @return {TreeNode[]}\n */\nvar delNodes = function(root, to_delete) {\n  const res = []\n  if (root === null) return res\n  function dfs(node) {\n    if (node === null || to_delete.length === 0) return\n    if (node.left) node.left.parent = node\n    if (node.right) node.right.parent = node\n    dfs(node.left)\n    dfs(node.right)\n    const index = to_delete.indexOf(node.val)\n    if (index !== -1) {\n      to_delete.splice(index, 1)\n      if (node.parent) {\n        if (node.parent.left === node) {\n          node.parent.left = null\n        } else {\n          node.parent.right = null  \n        }\n      }\n      if (node.left) {\n        res.push(node.left)\n      }\n      if (node.right) {\n        res.push(node.right)\n      }\n    } else if (root === node) {\n      res.push(node)\n    }\n  }\n\n  dfs(root)\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.549Z","path":"leetcode/二叉树/1110.删点成林.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn0010tnw73j2ucq59","content":"<h1 id=\"1110-删点成林\"><a href=\"#1110-删点成林\" class=\"headerlink\" title=\"1110. 删点成林\"></a>1110. 删点成林</h1><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p>\n<p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>\n<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>\n<p><a href=\"https://leetcode-cn.com/problems/delete-nodes-and-return-forest/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">to_delete</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> delNodes = <span class=\"keyword\">function</span>(<span class=\"params\">root, to_delete</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span> || to_delete.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = to_delete.<span class=\"title function_\">indexOf</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      to_delete.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">parent</span>.<span class=\"property\">left</span> === node) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">parent</span>.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          node.<span class=\"property\">parent</span>.<span class=\"property\">right</span> = <span class=\"literal\">null</span>  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">        res.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">        res.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root === node) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(node)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1110-删点成林\"><a href=\"#1110-删点成林\" class=\"headerlink\" title=\"1110. 删点成林\"></a>1110. 删点成林</h1><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p>\n<p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>\n<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>\n<p><a href=\"https://leetcode-cn.com/problems/delete-nodes-and-return-forest/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">to_delete</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> delNodes = <span class=\"keyword\">function</span>(<span class=\"params\">root, to_delete</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span> || to_delete.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = to_delete.<span class=\"title function_\">indexOf</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      to_delete.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">parent</span>.<span class=\"property\">left</span> === node) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">parent</span>.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          node.<span class=\"property\">parent</span>.<span class=\"property\">right</span> = <span class=\"literal\">null</span>  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">        res.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">        res.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root === node) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(node)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 112. 路径总和\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。\n\n叶子节点 是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/path-sum)\n\n```ts\nfunction hasPathSum(root: TreeNode | null, targetSum: number): boolean {\n  if (root === null) return false\n  if (root.left === null && root.right === null && targetSum === root.val) {\n    return true\n  }\n  const sum = targetSum - root.val\n  return hasPathSum(root.left, sum) || hasPathSum(root.right, sum)\n}\n```\n","source":"leetcode/二叉树/112.路径总和.md","raw":"# 112. 路径总和\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。\n\n叶子节点 是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/path-sum)\n\n```ts\nfunction hasPathSum(root: TreeNode | null, targetSum: number): boolean {\n  if (root === null) return false\n  if (root.left === null && root.right === null && targetSum === root.val) {\n    return true\n  }\n  const sum = targetSum - root.val\n  return hasPathSum(root.left, sum) || hasPathSum(root.right, sum)\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.549Z","path":"leetcode/二叉树/112.路径总和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn0011tnw78926153x","content":"<h1 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a>112. 路径总和</h1><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasPathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, targetSum: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> &amp;&amp; targetSum === root.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sum = targetSum - root.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">hasPathSum</span>(root.<span class=\"property\">left</span>, sum) || <span class=\"title function_\">hasPathSum</span>(root.<span class=\"property\">right</span>, sum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a>112. 路径总和</h1><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasPathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, targetSum: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> &amp;&amp; targetSum === root.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sum = targetSum - root.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">hasPathSum</span>(root.<span class=\"property\">left</span>, sum) || <span class=\"title function_\">hasPathSum</span>(root.<span class=\"property\">right</span>, sum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1123. 最深叶节点的最近公共祖先\n\n给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。\n\n回想一下：\n\n- 叶节点 是二叉树中没有子节点的节点\n- 树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1\n- 如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。\n\n[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\ntype Smallest = {\n  node: TreeNode | null;\n  depth: number\n}\n\n\nfunction lcaDeepestLeaves(root: TreeNode | null): TreeNode | null {\n  function dfs(node: TreeNode | null): Smallest {\n    if (node === null) return { node: null, depth: 0 }\n    const l = dfs(node.left)\n    const r = dfs(node.right)\n    if (l.depth > r.depth) return { node: l.node, depth: l.depth + 1 }\n    if (l.depth < r.depth) return { node: r.node, depth: r.depth + 1 }\n    return { node: node, depth: l.depth + 1 }\n  }\n  return dfs(root).node\n};\n\n```\n","source":"leetcode/二叉树/1123.最深叶节点的最近公共祖先.md","raw":"# 1123. 最深叶节点的最近公共祖先\n\n给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。\n\n回想一下：\n\n- 叶节点 是二叉树中没有子节点的节点\n- 树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1\n- 如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。\n\n[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\ntype Smallest = {\n  node: TreeNode | null;\n  depth: number\n}\n\n\nfunction lcaDeepestLeaves(root: TreeNode | null): TreeNode | null {\n  function dfs(node: TreeNode | null): Smallest {\n    if (node === null) return { node: null, depth: 0 }\n    const l = dfs(node.left)\n    const r = dfs(node.right)\n    if (l.depth > r.depth) return { node: l.node, depth: l.depth + 1 }\n    if (l.depth < r.depth) return { node: r.node, depth: r.depth + 1 }\n    return { node: node, depth: l.depth + 1 }\n  }\n  return dfs(root).node\n};\n\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.549Z","path":"leetcode/二叉树/1123.最深叶节点的最近公共祖先.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxn0012tnw77518cmzp","content":"<h1 id=\"1123-最深叶节点的最近公共祖先\"><a href=\"#1123-最深叶节点的最近公共祖先\" class=\"headerlink\" title=\"1123. 最深叶节点的最近公共祖先\"></a>1123. 最深叶节点的最近公共祖先</h1><p>给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。</p>\n<p>回想一下：</p>\n<ul>\n<li>叶节点 是二叉树中没有子节点的节点</li>\n<li>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</li>\n<li>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Smallest</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"attr\">depth</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lcaDeepestLeaves</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">Smallest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: <span class=\"literal\">null</span>, <span class=\"attr\">depth</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &gt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: l.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &lt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: r.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: r.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: node, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(root).<span class=\"property\">node</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1123-最深叶节点的最近公共祖先\"><a href=\"#1123-最深叶节点的最近公共祖先\" class=\"headerlink\" title=\"1123. 最深叶节点的最近公共祖先\"></a>1123. 最深叶节点的最近公共祖先</h1><p>给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。</p>\n<p>回想一下：</p>\n<ul>\n<li>叶节点 是二叉树中没有子节点的节点</li>\n<li>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</li>\n<li>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Smallest</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"attr\">depth</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lcaDeepestLeaves</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">Smallest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: <span class=\"literal\">null</span>, <span class=\"attr\">depth</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &gt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: l.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &lt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: r.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: r.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: node, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(root).<span class=\"property\">node</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 113. 路径总和 II\n\n给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n\n叶子节点 是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/path-sum-ii)\n\n```ts\nlet res = []\nfunction pathSum(root: TreeNode | null, targetSum: number): number[][] {\n  if (root === null) return []\n  res = []\n  traverse(root, targetSum, [])\n  return res\n};\n\nfunction traverse(root: TreeNode, targetSum: number, nodeList: number[]) {\n  if (root === null) {\n    return\n  }\n  targetSum -= root.val\n  nodeList.push(root.val)\n  if (root.left === null && root.right === null && targetSum === 0) {\n    res.push(nodeList)\n    return\n  }\n  traverse(root.left, targetSum, nodeList.slice(0))\n  traverse(root.right, targetSum, nodeList.slice(0))\n}\n```\n","source":"leetcode/二叉树/113.路径总和II.md","raw":"# 113. 路径总和 II\n\n给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n\n叶子节点 是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/path-sum-ii)\n\n```ts\nlet res = []\nfunction pathSum(root: TreeNode | null, targetSum: number): number[][] {\n  if (root === null) return []\n  res = []\n  traverse(root, targetSum, [])\n  return res\n};\n\nfunction traverse(root: TreeNode, targetSum: number, nodeList: number[]) {\n  if (root === null) {\n    return\n  }\n  targetSum -= root.val\n  nodeList.push(root.val)\n  if (root.left === null && root.right === null && targetSum === 0) {\n    res.push(nodeList)\n    return\n  }\n  traverse(root.left, targetSum, nodeList.slice(0))\n  traverse(root.right, targetSum, nodeList.slice(0))\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.549Z","path":"leetcode/二叉树/113.路径总和II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0013tnw77khj67fj","content":"<h1 id=\"113-路径总和-II\"><a href=\"#113-路径总和-II\" class=\"headerlink\" title=\"113. 路径总和 II\"></a>113. 路径总和 II</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> res = []</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, targetSum: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, targetSum, [])</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, targetSum: <span class=\"built_in\">number</span>, nodeList: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  targetSum -= root.<span class=\"property\">val</span></span><br><span class=\"line\">  nodeList.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> &amp;&amp; targetSum === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(nodeList)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, targetSum, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, targetSum, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"113-路径总和-II\"><a href=\"#113-路径总和-II\" class=\"headerlink\" title=\"113. 路径总和 II\"></a>113. 路径总和 II</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> res = []</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, targetSum: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, targetSum, [])</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, targetSum: <span class=\"built_in\">number</span>, nodeList: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  targetSum -= root.<span class=\"property\">val</span></span><br><span class=\"line\">  nodeList.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> &amp;&amp; targetSum === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(nodeList)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, targetSum, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, targetSum, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1145. 二叉树着色游戏\n\n有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。\n\n游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，\n\n「一号」玩家从 [1, n] 中取一个值 x（1 <= x <= n）；\n\n「二号」玩家也从 [1, n] 中取一个值 y（1 <= y <= n）且 y != x。\n\n「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。\n\n之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。\n\n如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。\n\n若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。\n\n现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-coloring-game/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction btreeGameWinningMove(root: TreeNode | null, n: number, x: number): boolean {\n  const node = findNode(root, x)\n  const l = countNodes(node.left)\n  const r = countNodes(node.right)\n  const half = Math.floor(n / 2)\n  if (l > half || r > half || l + r < half) {\n    return true\n  }\n  return false\n};\n\nfunction findNode(node: TreeNode, target: number) {{\n  if (node === null) return null\n  if (node.val === target) {\n    return node\n  }\n  const l = findNode(node.left, target)\n  const r = findNode(node.right, target)\n  return l ? l : r\n}}\n\nfunction countNodes(node: TreeNode): number {\n  if (node === null) return 0\n  return countNodes(node.left) + countNodes(node.right) + 1\n}\n```\n","source":"leetcode/二叉树/1145.二叉树着色游戏.md","raw":"# 1145. 二叉树着色游戏\n\n有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。\n\n游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，\n\n「一号」玩家从 [1, n] 中取一个值 x（1 <= x <= n）；\n\n「二号」玩家也从 [1, n] 中取一个值 y（1 <= y <= n）且 y != x。\n\n「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。\n\n之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。\n\n如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。\n\n若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。\n\n现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-coloring-game/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction btreeGameWinningMove(root: TreeNode | null, n: number, x: number): boolean {\n  const node = findNode(root, x)\n  const l = countNodes(node.left)\n  const r = countNodes(node.right)\n  const half = Math.floor(n / 2)\n  if (l > half || r > half || l + r < half) {\n    return true\n  }\n  return false\n};\n\nfunction findNode(node: TreeNode, target: number) {{\n  if (node === null) return null\n  if (node.val === target) {\n    return node\n  }\n  const l = findNode(node.left, target)\n  const r = findNode(node.right, target)\n  return l ? l : r\n}}\n\nfunction countNodes(node: TreeNode): number {\n  if (node === null) return 0\n  return countNodes(node.left) + countNodes(node.right) + 1\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.550Z","path":"leetcode/二叉树/1145.二叉树着色游戏.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0014tnw70kviacpp","content":"<h1 id=\"1145-二叉树着色游戏\"><a href=\"#1145-二叉树着色游戏\" class=\"headerlink\" title=\"1145. 二叉树着色游戏\"></a>1145. 二叉树着色游戏</h1><p>有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。</p>\n<p>游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，</p>\n<p>「一号」玩家从 [1, n] 中取一个值 x（1 &lt;= x &lt;= n）；</p>\n<p>「二号」玩家也从 [1, n] 中取一个值 y（1 &lt;= y &lt;= n）且 y != x。</p>\n<p>「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。</p>\n<p>之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。</p>\n<p>如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。</p>\n<p>若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。</p>\n<p>现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-coloring-game/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">btreeGameWinningMove</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, n: <span class=\"built_in\">number</span>, x: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"title function_\">findNode</span>(root, x)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> half = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(n / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l &gt; half || r &gt; half || l + r &lt; half) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findNode</span>(<span class=\"params\">node: TreeNode, target: <span class=\"built_in\">number</span></span>) &#123;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">findNode</span>(node.<span class=\"property\">left</span>, target)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">findNode</span>(node.<span class=\"property\">right</span>, target)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l ? l : r</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">countNodes</span>(<span class=\"params\">node: TreeNode</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">left</span>) + <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">right</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1145-二叉树着色游戏\"><a href=\"#1145-二叉树着色游戏\" class=\"headerlink\" title=\"1145. 二叉树着色游戏\"></a>1145. 二叉树着色游戏</h1><p>有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。</p>\n<p>游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，</p>\n<p>「一号」玩家从 [1, n] 中取一个值 x（1 &lt;= x &lt;= n）；</p>\n<p>「二号」玩家也从 [1, n] 中取一个值 y（1 &lt;= y &lt;= n）且 y != x。</p>\n<p>「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。</p>\n<p>之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。</p>\n<p>如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。</p>\n<p>若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。</p>\n<p>现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-coloring-game/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">btreeGameWinningMove</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, n: <span class=\"built_in\">number</span>, x: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"title function_\">findNode</span>(root, x)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> half = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(n / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l &gt; half || r &gt; half || l + r &lt; half) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findNode</span>(<span class=\"params\">node: TreeNode, target: <span class=\"built_in\">number</span></span>) &#123;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">findNode</span>(node.<span class=\"property\">left</span>, target)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">findNode</span>(node.<span class=\"property\">right</span>, target)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l ? l : r</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">countNodes</span>(<span class=\"params\">node: TreeNode</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">left</span>) + <span class=\"title function_\">countNodes</span>(node.<span class=\"property\">right</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 114. 二叉树展开为链表\n\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n[链接](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)\n\n```ts\nfunction flatten(root: TreeNode | null): void {\n  if (root === null) return\n  flatten(root.left)\n  flatten(root.right)\n  const left = root.left\n  const right = root.right\n\n  root.left = null\n  root.right = left\n  let p = root\n  while(p.right !== null) {\n    p = p.right\n  }\n  p.right = right\n}\n```\n","source":"leetcode/二叉树/114.二叉树展开为链表.md","raw":"# 114. 二叉树展开为链表\n\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。\n展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n[链接](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)\n\n```ts\nfunction flatten(root: TreeNode | null): void {\n  if (root === null) return\n  flatten(root.left)\n  flatten(root.right)\n  const left = root.left\n  const right = root.right\n\n  root.left = null\n  root.right = left\n  let p = root\n  while(p.right !== null) {\n    p = p.right\n  }\n  p.right = right\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.550Z","path":"leetcode/二叉树/114.二叉树展开为链表.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0015tnw74c3o4dah","content":"<h1 id=\"114-二叉树展开为链表\"><a href=\"#114-二叉树展开为链表\" class=\"headerlink\" title=\"114. 二叉树展开为链表\"></a>114. 二叉树展开为链表</h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>\n<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flatten</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">flatten</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">flatten</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = root.<span class=\"property\">left</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = root.<span class=\"property\">right</span></span><br><span class=\"line\"></span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  root.<span class=\"property\">right</span> = left</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = root</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p.<span class=\"property\">right</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    p = p.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  p.<span class=\"property\">right</span> = right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"114-二叉树展开为链表\"><a href=\"#114-二叉树展开为链表\" class=\"headerlink\" title=\"114. 二叉树展开为链表\"></a>114. 二叉树展开为链表</h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>\n<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flatten</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">flatten</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">flatten</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = root.<span class=\"property\">left</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = root.<span class=\"property\">right</span></span><br><span class=\"line\"></span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  root.<span class=\"property\">right</span> = left</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = root</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p.<span class=\"property\">right</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    p = p.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  p.<span class=\"property\">right</span> = right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1161. 最大层内元素和\n\n给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。\n\n请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。\n\n[链接](https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxLevelSum(root: TreeNode | null): number {\n  const nodeQue: TreeNode[] = [root]\n  let max = Number.NEGATIVE_INFINITY\n  let depth = 0\n  let res = 0\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    let floorTotal = 0\n    depth++\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      floorTotal += node.val\n      node.left && nodeQue.push(node.left)\n      node.right && nodeQue.push(node.right)\n    }\n    if (max < floorTotal) {\n      max = floorTotal\n      res = depth\n    }\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/1161.最大层内元素和.md","raw":"# 1161. 最大层内元素和\n\n给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。\n\n请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。\n\n[链接](https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxLevelSum(root: TreeNode | null): number {\n  const nodeQue: TreeNode[] = [root]\n  let max = Number.NEGATIVE_INFINITY\n  let depth = 0\n  let res = 0\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    let floorTotal = 0\n    depth++\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      floorTotal += node.val\n      node.left && nodeQue.push(node.left)\n      node.right && nodeQue.push(node.right)\n    }\n    if (max < floorTotal) {\n      max = floorTotal\n      res = depth\n    }\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.551Z","path":"leetcode/二叉树/1161.最大层内元素和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0016tnw79w9p9z2s","content":"<h1 id=\"1161-最大层内元素和\"><a href=\"#1161-最大层内元素和\" class=\"headerlink\" title=\"1161. 最大层内元素和\"></a>1161. 最大层内元素和</h1><p>给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。</p>\n<p>请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxLevelSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQue</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> floorTotal = <span class=\"number\">0</span></span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      floorTotal += node.<span class=\"property\">val</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> &amp;&amp; nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      node.<span class=\"property\">right</span> &amp;&amp; nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max &lt; floorTotal) &#123;</span><br><span class=\"line\">      max = floorTotal</span><br><span class=\"line\">      res = depth</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1161-最大层内元素和\"><a href=\"#1161-最大层内元素和\" class=\"headerlink\" title=\"1161. 最大层内元素和\"></a>1161. 最大层内元素和</h1><p>给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。</p>\n<p>请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxLevelSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQue</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> floorTotal = <span class=\"number\">0</span></span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      floorTotal += node.<span class=\"property\">val</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> &amp;&amp; nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      node.<span class=\"property\">right</span> &amp;&amp; nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max &lt; floorTotal) &#123;</span><br><span class=\"line\">      max = floorTotal</span><br><span class=\"line\">      res = depth</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 116. 填充每个节点的下一个右侧节点指针\n\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n初始状态下，所有 next 指针都被设置为 NULL。\n\n[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node)\n\n```js\nvar connect = function(root) {\n  if (root === null) return root\n  connectTwoNode(root.left, root.right)\n  return root\n}\n\nfunction connectTwoNode(node1, node2) {\n  if (node1 === null || node2 === null) {\n    return\n  }\n  node1.next = node2\n  connectTwoNode(node1.left, node1.right)\n  connectTwoNode(node2.left, node2.right)\n\n  connectTwoNode(node1.right, node2.left)\n}\n```\n","source":"leetcode/二叉树/116.填充每个节点的下一个右侧节点指针.md","raw":"# 116. 填充每个节点的下一个右侧节点指针\n\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n初始状态下，所有 next 指针都被设置为 NULL。\n\n[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node)\n\n```js\nvar connect = function(root) {\n  if (root === null) return root\n  connectTwoNode(root.left, root.right)\n  return root\n}\n\nfunction connectTwoNode(node1, node2) {\n  if (node1 === null || node2 === null) {\n    return\n  }\n  node1.next = node2\n  connectTwoNode(node1.left, node1.right)\n  connectTwoNode(node2.left, node2.right)\n\n  connectTwoNode(node1.right, node2.left)\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.550Z","path":"leetcode/二叉树/116.填充每个节点的下一个右侧节点指针.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0017tnw79owng7zh","content":"<h1 id=\"116-填充每个节点的下一个右侧节点指针\"><a href=\"#116-填充每个节点的下一个右侧节点指针\" class=\"headerlink\" title=\"116. 填充每个节点的下一个右侧节点指针\"></a>116. 填充每个节点的下一个右侧节点指针</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Node &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> connect = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(root.<span class=\"property\">left</span>, root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">connectTwoNode</span>(<span class=\"params\">node1, node2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node1 === <span class=\"literal\">null</span> || node2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  node1.<span class=\"property\">next</span> = node2</span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(node1.<span class=\"property\">left</span>, node1.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(node2.<span class=\"property\">left</span>, node2.<span class=\"property\">right</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(node1.<span class=\"property\">right</span>, node2.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"116-填充每个节点的下一个右侧节点指针\"><a href=\"#116-填充每个节点的下一个右侧节点指针\" class=\"headerlink\" title=\"116. 填充每个节点的下一个右侧节点指针\"></a>116. 填充每个节点的下一个右侧节点指针</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Node &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> connect = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(root.<span class=\"property\">left</span>, root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">connectTwoNode</span>(<span class=\"params\">node1, node2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node1 === <span class=\"literal\">null</span> || node2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  node1.<span class=\"property\">next</span> = node2</span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(node1.<span class=\"property\">left</span>, node1.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(node2.<span class=\"property\">left</span>, node2.<span class=\"property\">right</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connectTwoNode</span>(node1.<span class=\"property\">right</span>, node2.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 117. 填充每个节点的下一个右侧节点指针 II\n\n给定一个二叉树\n\n```js\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n初始状态下，所有 next 指针都被设置为 NULL。\n\n[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii)\n\n```ts\nvar connect = function(root) {\n  if (root === null) return null\n  const nodeList = [root]\n  while(nodeList.length > 0) {\n    const nodeL = nodeList.splice(0)\n    const len = nodeL.length\n    for(let i = 0; i < len; i++) {\n      const node = nodeL[i]\n      if (node === null) {\n        continue\n      }\n      const back = nodeL[i + 1]\n      node.next = back ? back : null\n      node.left && nodeList.push(node.left)\n      node.right && nodeList.push(node.right)\n    }\n  }\n  return root\n}\n```\n","source":"leetcode/二叉树/117.填充每个节点的下一个右侧节点指针II.md","raw":"# 117. 填充每个节点的下一个右侧节点指针 II\n\n给定一个二叉树\n\n```js\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n初始状态下，所有 next 指针都被设置为 NULL。\n\n[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii)\n\n```ts\nvar connect = function(root) {\n  if (root === null) return null\n  const nodeList = [root]\n  while(nodeList.length > 0) {\n    const nodeL = nodeList.splice(0)\n    const len = nodeL.length\n    for(let i = 0; i < len; i++) {\n      const node = nodeL[i]\n      if (node === null) {\n        continue\n      }\n      const back = nodeL[i + 1]\n      node.next = back ? back : null\n      node.left && nodeList.push(node.left)\n      node.right && nodeList.push(node.right)\n    }\n  }\n  return root\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.551Z","path":"leetcode/二叉树/117.填充每个节点的下一个右侧节点指针II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0018tnw76xhf6ep6","content":"<h1 id=\"117-填充每个节点的下一个右侧节点指针-II\"><a href=\"#117-填充每个节点的下一个右侧节点指针-II\" class=\"headerlink\" title=\"117. 填充每个节点的下一个右侧节点指针 II\"></a>117. 填充每个节点的下一个右侧节点指针 II</h1><p>给定一个二叉树</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  int val;</span><br><span class=\"line\">  <span class=\"title class_\">Node</span> *left;</span><br><span class=\"line\">  <span class=\"title class_\">Node</span> *right;</span><br><span class=\"line\">  <span class=\"title class_\">Node</span> *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> connect = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> back = nodeL[i + <span class=\"number\">1</span>]</span><br><span class=\"line\">      node.<span class=\"property\">next</span> = back ? back : <span class=\"literal\">null</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> &amp;&amp; nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      node.<span class=\"property\">right</span> &amp;&amp; nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"117-填充每个节点的下一个右侧节点指针-II\"><a href=\"#117-填充每个节点的下一个右侧节点指针-II\" class=\"headerlink\" title=\"117. 填充每个节点的下一个右侧节点指针 II\"></a>117. 填充每个节点的下一个右侧节点指针 II</h1><p>给定一个二叉树</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  int val;</span><br><span class=\"line\">  <span class=\"title class_\">Node</span> *left;</span><br><span class=\"line\">  <span class=\"title class_\">Node</span> *right;</span><br><span class=\"line\">  <span class=\"title class_\">Node</span> *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> connect = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeList = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodeL = nodeList.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodeL.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodeL[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> back = nodeL[i + <span class=\"number\">1</span>]</span><br><span class=\"line\">      node.<span class=\"property\">next</span> = back ? back : <span class=\"literal\">null</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> &amp;&amp; nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      node.<span class=\"property\">right</span> &amp;&amp; nodeList.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 124. 二叉树中的最大路径和\n\n路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n\n路径和 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)\n\n```ts\nlet maxG = Number.NEGATIVE_INFINITY\n\nfunction maxPathSum(root: TreeNode | null): number {\n  if (root === null) return 0\n  maxG = Number.NEGATIVE_INFINITY\n  traverse(root)\n  return maxG\n};\n\nfunction traverse(root: TreeNode): number {\n  if (root === null) return 0\n  const leftG = Math.max(traverse(root.left), 0)\n  const rightG = Math.max(traverse(root.right), 0)\n  const max = root.val + leftG + rightG\n  maxG = Math.max(max, maxG)\n  return root.val + Math.max(leftG, rightG)\n}\n```\n","source":"leetcode/二叉树/124.二叉树中的最大路径和.md","raw":"# 124. 二叉树中的最大路径和\n\n路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n\n路径和 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)\n\n```ts\nlet maxG = Number.NEGATIVE_INFINITY\n\nfunction maxPathSum(root: TreeNode | null): number {\n  if (root === null) return 0\n  maxG = Number.NEGATIVE_INFINITY\n  traverse(root)\n  return maxG\n};\n\nfunction traverse(root: TreeNode): number {\n  if (root === null) return 0\n  const leftG = Math.max(traverse(root.left), 0)\n  const rightG = Math.max(traverse(root.right), 0)\n  const max = root.val + leftG + rightG\n  maxG = Math.max(max, maxG)\n  return root.val + Math.max(leftG, rightG)\n}\n```\n","date":"2023-10-11T15:10:43.203Z","updated":"2023-09-26T14:49:23.551Z","path":"leetcode/二叉树/124.二叉树中的最大路径和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo0019tnw7c8k6due4","content":"<h1 id=\"124-二叉树中的最大路径和\"><a href=\"#124-二叉树中的最大路径和\" class=\"headerlink\" title=\"124. 二叉树中的最大路径和\"></a>124. 二叉树中的最大路径和</h1><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>\n<p>路径和 是路径中各节点值的总和。</p>\n<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> maxG = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxPathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  maxG = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxG</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftG = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>), <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rightG = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>), <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> max = root.<span class=\"property\">val</span> + leftG + rightG</span><br><span class=\"line\">  maxG = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, maxG)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root.<span class=\"property\">val</span> + <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(leftG, rightG)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"124-二叉树中的最大路径和\"><a href=\"#124-二叉树中的最大路径和\" class=\"headerlink\" title=\"124. 二叉树中的最大路径和\"></a>124. 二叉树中的最大路径和</h1><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>\n<p>路径和 是路径中各节点值的总和。</p>\n<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> maxG = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxPathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  maxG = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxG</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> leftG = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>), <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rightG = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>), <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> max = root.<span class=\"property\">val</span> + leftG + rightG</span><br><span class=\"line\">  maxG = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, maxG)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root.<span class=\"property\">val</span> + <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(leftG, rightG)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 129. 求根节点到叶节点数字之和\n\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers)\n\n```ts\nlet total = 0\n\nfunction sumNumbers(root: TreeNode | null): number {\n  if (root === null) return 0\n  total = 0\n  traverse(root, [])\n  return total\n};\n\nfunction traverse(root: TreeNode | null, nodeList: number[]) {\n  if (root === null) {\n    return\n  }\n  nodeList.push(root.val)\n  if (root.left === null && root.right === null) {\n    total += Number(nodeList.join(''))\n    return\n  }\n  traverse(root.left, nodeList.slice(0))\n  traverse(root.right, nodeList.slice(0))\n}\n```\n","source":"leetcode/二叉树/129.求根节点到叶节点数字之和.md","raw":"# 129. 求根节点到叶节点数字之和\n\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers)\n\n```ts\nlet total = 0\n\nfunction sumNumbers(root: TreeNode | null): number {\n  if (root === null) return 0\n  total = 0\n  traverse(root, [])\n  return total\n};\n\nfunction traverse(root: TreeNode | null, nodeList: number[]) {\n  if (root === null) {\n    return\n  }\n  nodeList.push(root.val)\n  if (root.left === null && root.right === null) {\n    total += Number(nodeList.join(''))\n    return\n  }\n  traverse(root.left, nodeList.slice(0))\n  traverse(root.right, nodeList.slice(0))\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.552Z","path":"leetcode/二叉树/129.求根节点到叶节点数字之和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001atnw78kv3aa1o","content":"<h1 id=\"129-求根节点到叶节点数字之和\"><a href=\"#129-求根节点到叶节点数字之和\" class=\"headerlink\" title=\"129. 求根节点到叶节点数字之和\"></a>129. 求根节点到叶节点数字之和</h1><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>\n<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>\n<p>叶节点 是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumNumbers</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, [])</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, nodeList: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nodeList.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    total += <span class=\"title class_\">Number</span>(nodeList.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"129-求根节点到叶节点数字之和\"><a href=\"#129-求根节点到叶节点数字之和\" class=\"headerlink\" title=\"129. 求根节点到叶节点数字之和\"></a>129. 求根节点到叶节点数字之和</h1><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>\n<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>\n<p>叶节点 是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumNumbers</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, [])</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, nodeList: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nodeList.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    total += <span class=\"title class_\">Number</span>(nodeList.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, nodeList.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1302. 层数最深叶子节点的和\n\n给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deepestLeavesSum(root: TreeNode | null): number {\n  let res = 0\n  if (root === null) return res\n  const nodeQue: TreeNode[] = [root]\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node.left) {\n        nodeQue.push(node.left)\n      }\n      if (node.right) {\n        nodeQue.push(node.right)\n      }\n    }\n    if (nodeQue.length === 0) {\n      res = nodes.reduce((pre, node) => {\n        pre += node.val\n        return pre\n      }, 0)\n    }\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/1302.层数最深叶子节点的和.md","raw":"# 1302. 层数最深叶子节点的和\n\n给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deepestLeavesSum(root: TreeNode | null): number {\n  let res = 0\n  if (root === null) return res\n  const nodeQue: TreeNode[] = [root]\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node.left) {\n        nodeQue.push(node.left)\n      }\n      if (node.right) {\n        nodeQue.push(node.right)\n      }\n    }\n    if (nodeQue.length === 0) {\n      res = nodes.reduce((pre, node) => {\n        pre += node.val\n        return pre\n      }, 0)\n    }\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.205Z","updated":"2023-09-26T14:49:23.552Z","path":"leetcode/二叉树/1302.层数最深叶子节点的和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001btnw79gejghz5","content":"<h1 id=\"1302-层数最深叶子节点的和\"><a href=\"#1302-层数最深叶子节点的和\" class=\"headerlink\" title=\"1302. 层数最深叶子节点的和\"></a>1302. 层数最深叶子节点的和</h1><p>给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deepestLeavesSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQue</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeQue.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res = nodes.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre, node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        pre += node.<span class=\"property\">val</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1302-层数最深叶子节点的和\"><a href=\"#1302-层数最深叶子节点的和\" class=\"headerlink\" title=\"1302. 层数最深叶子节点的和\"></a>1302. 层数最深叶子节点的和</h1><p>给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deepestLeavesSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQue</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeQue.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res = nodes.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre, node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        pre += node.<span class=\"property\">val</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1305. 两棵二叉搜索树中的所有元素\n\n给你 root1 和 root2 这两棵二叉搜索树。\n\n请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getAllElements(root1: TreeNode | null, root2: TreeNode | null): number[] {\n  const res: number[] = []\n  const stack1: TreeNode[] = []\n  const stack2: TreeNode[] = []\n\n  while((root1 !== null || stack1.length !== 0) && (root2 !== null || stack2.length !== 0)) {\n    while(root1 !== null) {\n      stack1.push(root1)\n      root1 = root1.left\n    }\n    while(root2 !== null) {\n      stack2.push(root2)\n      root2 = root2.left\n    }\n\n    if (stack1[stack1.length - 1].val > stack2[stack2.length - 1].val) {\n      root2 = stack2.pop()\n      res.push(root2.val)\n      root2 = root2.right\n    } else {\n      root1 = stack1.pop()\n      res.push(root1.val)\n      root1 = root1.right\n    }\n  }\n  addItem(root1, stack1, res)\n  addItem(root2, stack2, res)\n  return res\n};\n\nfunction addItem(node: TreeNode, stack: TreeNode[], rs: number[]) {\n  while(node !== null || stack.length > 0) {\n    while(node !== null) {\n      stack.push(node)\n      node = node.left\n    }\n    node = stack.pop()\n    rs.push(node.val)\n    node = node.right\n  }\n}\n```\n","source":"leetcode/二叉树/1305.两棵二叉搜索树中的所有元素.md","raw":"# 1305. 两棵二叉搜索树中的所有元素\n\n给你 root1 和 root2 这两棵二叉搜索树。\n\n请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getAllElements(root1: TreeNode | null, root2: TreeNode | null): number[] {\n  const res: number[] = []\n  const stack1: TreeNode[] = []\n  const stack2: TreeNode[] = []\n\n  while((root1 !== null || stack1.length !== 0) && (root2 !== null || stack2.length !== 0)) {\n    while(root1 !== null) {\n      stack1.push(root1)\n      root1 = root1.left\n    }\n    while(root2 !== null) {\n      stack2.push(root2)\n      root2 = root2.left\n    }\n\n    if (stack1[stack1.length - 1].val > stack2[stack2.length - 1].val) {\n      root2 = stack2.pop()\n      res.push(root2.val)\n      root2 = root2.right\n    } else {\n      root1 = stack1.pop()\n      res.push(root1.val)\n      root1 = root1.right\n    }\n  }\n  addItem(root1, stack1, res)\n  addItem(root2, stack2, res)\n  return res\n};\n\nfunction addItem(node: TreeNode, stack: TreeNode[], rs: number[]) {\n  while(node !== null || stack.length > 0) {\n    while(node !== null) {\n      stack.push(node)\n      node = node.left\n    }\n    node = stack.pop()\n    rs.push(node.val)\n    node = node.right\n  }\n}\n```\n","date":"2023-10-11T15:10:43.205Z","updated":"2023-09-26T14:49:23.553Z","path":"leetcode/二叉树/1305.两棵二叉搜索树中的所有元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001ctnw75x416z7z","content":"<h1 id=\"1305-两棵二叉搜索树中的所有元素\"><a href=\"#1305-两棵二叉搜索树中的所有元素\" class=\"headerlink\" title=\"1305. 两棵二叉搜索树中的所有元素\"></a>1305. 两棵二叉搜索树中的所有元素</h1><p>给你 root1 和 root2 这两棵二叉搜索树。</p>\n<p>请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getAllElements</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">stack1</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">stack2</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((root1 !== <span class=\"literal\">null</span> || stack1.<span class=\"property\">length</span> !== <span class=\"number\">0</span>) &amp;&amp; (root2 !== <span class=\"literal\">null</span> || stack2.<span class=\"property\">length</span> !== <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root1 !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack1.<span class=\"title function_\">push</span>(root1)</span><br><span class=\"line\">      root1 = root1.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root2 !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack2.<span class=\"title function_\">push</span>(root2)</span><br><span class=\"line\">      root2 = root2.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack1[stack1.<span class=\"property\">length</span> - <span class=\"number\">1</span>].<span class=\"property\">val</span> &gt; stack2[stack2.<span class=\"property\">length</span> - <span class=\"number\">1</span>].<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      root2 = stack2.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root2.<span class=\"property\">val</span>)</span><br><span class=\"line\">      root2 = root2.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      root1 = stack1.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root1.<span class=\"property\">val</span>)</span><br><span class=\"line\">      root1 = root1.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">addItem</span>(root1, stack1, res)</span><br><span class=\"line\">  <span class=\"title function_\">addItem</span>(root2, stack2, res)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">addItem</span>(<span class=\"params\">node: TreeNode, stack: TreeNode[], rs: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(node !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(node)</span><br><span class=\"line\">      node = node.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node = stack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    rs.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    node = node.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1305-两棵二叉搜索树中的所有元素\"><a href=\"#1305-两棵二叉搜索树中的所有元素\" class=\"headerlink\" title=\"1305. 两棵二叉搜索树中的所有元素\"></a>1305. 两棵二叉搜索树中的所有元素</h1><p>给你 root1 和 root2 这两棵二叉搜索树。</p>\n<p>请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getAllElements</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">stack1</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">stack2</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((root1 !== <span class=\"literal\">null</span> || stack1.<span class=\"property\">length</span> !== <span class=\"number\">0</span>) &amp;&amp; (root2 !== <span class=\"literal\">null</span> || stack2.<span class=\"property\">length</span> !== <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root1 !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack1.<span class=\"title function_\">push</span>(root1)</span><br><span class=\"line\">      root1 = root1.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root2 !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack2.<span class=\"title function_\">push</span>(root2)</span><br><span class=\"line\">      root2 = root2.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack1[stack1.<span class=\"property\">length</span> - <span class=\"number\">1</span>].<span class=\"property\">val</span> &gt; stack2[stack2.<span class=\"property\">length</span> - <span class=\"number\">1</span>].<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      root2 = stack2.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root2.<span class=\"property\">val</span>)</span><br><span class=\"line\">      root2 = root2.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      root1 = stack1.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root1.<span class=\"property\">val</span>)</span><br><span class=\"line\">      root1 = root1.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">addItem</span>(root1, stack1, res)</span><br><span class=\"line\">  <span class=\"title function_\">addItem</span>(root2, stack2, res)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">addItem</span>(<span class=\"params\">node: TreeNode, stack: TreeNode[], rs: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(node !== <span class=\"literal\">null</span> || stack.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(node)</span><br><span class=\"line\">      node = node.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node = stack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    rs.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    node = node.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1261. 在受污染的二叉树中查找元素\n\n给出一个满足下述规则的二叉树：\n\n- root.val == 0\n- 如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1\n- 如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2\n\n现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。\n\n请你先还原二叉树，然后实现 FindElements 类：\n\n- FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。\n- bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。\n\n[链接](https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass FindElements {\n  node: TreeNode\n  constructor(root: TreeNode | null) {\n    this.init(root)\n    this.node = root\n  }\n  init(node: TreeNode) {\n    if (node === null) return\n    if (node.val === -1) {\n      node.val = 0\n    }\n    if (node.left) {\n      node.left.val = node.val * 2 + 1\n    }\n    if (node.right) {\n      node.right.val = node.val * 2 + 2\n    }\n    this.init(node.left)\n    this.init(node.right)\n  }\n  findDfs(node: TreeNode, target: number): boolean {\n    if (node === null) return false\n    const l = this.findDfs(node.left, target)\n    const r = this.findDfs(node.right, target)\n    return node.val === target || l || r\n  }\n  find(target: number): boolean {\n    return this.findDfs(this.node, target)\n  }\n}\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * var obj = new FindElements(root)\n * var param_1 = obj.find(target)\n */\n```\n","source":"leetcode/二叉树/1261.在受污染的二叉树中查找元素.md","raw":"# 1261. 在受污染的二叉树中查找元素\n\n给出一个满足下述规则的二叉树：\n\n- root.val == 0\n- 如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1\n- 如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2\n\n现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。\n\n请你先还原二叉树，然后实现 FindElements 类：\n\n- FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。\n- bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。\n\n[链接](https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass FindElements {\n  node: TreeNode\n  constructor(root: TreeNode | null) {\n    this.init(root)\n    this.node = root\n  }\n  init(node: TreeNode) {\n    if (node === null) return\n    if (node.val === -1) {\n      node.val = 0\n    }\n    if (node.left) {\n      node.left.val = node.val * 2 + 1\n    }\n    if (node.right) {\n      node.right.val = node.val * 2 + 2\n    }\n    this.init(node.left)\n    this.init(node.right)\n  }\n  findDfs(node: TreeNode, target: number): boolean {\n    if (node === null) return false\n    const l = this.findDfs(node.left, target)\n    const r = this.findDfs(node.right, target)\n    return node.val === target || l || r\n  }\n  find(target: number): boolean {\n    return this.findDfs(this.node, target)\n  }\n}\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * var obj = new FindElements(root)\n * var param_1 = obj.find(target)\n */\n```\n","date":"2023-10-11T15:10:43.205Z","updated":"2023-09-26T14:49:23.552Z","path":"leetcode/二叉树/1261.在受污染的二叉树中查找元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001dtnw75mvkeosg","content":"<h1 id=\"1261-在受污染的二叉树中查找元素\"><a href=\"#1261-在受污染的二叉树中查找元素\" class=\"headerlink\" title=\"1261. 在受污染的二叉树中查找元素\"></a>1261. 在受污染的二叉树中查找元素</h1><p>给出一个满足下述规则的二叉树：</p>\n<ul>\n<li>root.val == 0</li>\n<li>如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1</li>\n<li>如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2</li>\n</ul>\n<p>现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。</p>\n<p>请你先还原二叉树，然后实现 FindElements 类：</p>\n<ul>\n<li>FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。</li>\n<li>bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FindElements</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">init</span>(root)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">node</span> = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">init</span>(<span class=\"params\">node: TreeNode</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">val</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">left</span>.<span class=\"property\">val</span> = node.<span class=\"property\">val</span> * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">right</span>.<span class=\"property\">val</span> = node.<span class=\"property\">val</span> * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">init</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">init</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findDfs</span>(<span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span>, <span class=\"attr\">target</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"variable language_\">this</span>.<span class=\"title function_\">findDfs</span>(node.<span class=\"property\">left</span>, target)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"variable language_\">this</span>.<span class=\"title function_\">findDfs</span>(node.<span class=\"property\">right</span>, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.<span class=\"property\">val</span> === target || l || r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">find</span>(<span class=\"attr\">target</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">findDfs</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">node</span>, target)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new FindElements(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.find(target)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1261-在受污染的二叉树中查找元素\"><a href=\"#1261-在受污染的二叉树中查找元素\" class=\"headerlink\" title=\"1261. 在受污染的二叉树中查找元素\"></a>1261. 在受污染的二叉树中查找元素</h1><p>给出一个满足下述规则的二叉树：</p>\n<ul>\n<li>root.val == 0</li>\n<li>如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1</li>\n<li>如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2</li>\n</ul>\n<p>现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。</p>\n<p>请你先还原二叉树，然后实现 FindElements 类：</p>\n<ul>\n<li>FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。</li>\n<li>bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FindElements</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">init</span>(root)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">node</span> = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">init</span>(<span class=\"params\">node: TreeNode</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">val</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">left</span>.<span class=\"property\">val</span> = node.<span class=\"property\">val</span> * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">right</span>.<span class=\"property\">val</span> = node.<span class=\"property\">val</span> * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">init</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">init</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findDfs</span>(<span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span>, <span class=\"attr\">target</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"variable language_\">this</span>.<span class=\"title function_\">findDfs</span>(node.<span class=\"property\">left</span>, target)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"variable language_\">this</span>.<span class=\"title function_\">findDfs</span>(node.<span class=\"property\">right</span>, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.<span class=\"property\">val</span> === target || l || r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">find</span>(<span class=\"attr\">target</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">findDfs</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">node</span>, target)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new FindElements(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.find(target)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1315. 祖父节点值为偶数的节点和\n\n给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：\n\n- 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）\n\n如果不存在祖父节点值为偶数的节点，那么返回 0 。\n\n[链接](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumEvenGrandparent = function(root) {\n  let total = 0\n  function dfs(node) {\n    if (node === null) return\n    if (node.left) {\n      node.left.parent = node\n    }\n    if (node.right) {\n      node.right.parent = node\n    }\n    dfs(node.left)\n    dfs(node.right)\n    const gf = node.parent ? node.parent.parent : null\n    if (gf && gf.val % 2 === 0) {\n      total += node.val\n    }\n  }\n  dfs(root)\n  return total\n};\n```\n","source":"leetcode/二叉树/1315.祖父节点值为偶数的节点和.md","raw":"# 1315. 祖父节点值为偶数的节点和\n\n给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：\n\n- 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）\n\n如果不存在祖父节点值为偶数的节点，那么返回 0 。\n\n[链接](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumEvenGrandparent = function(root) {\n  let total = 0\n  function dfs(node) {\n    if (node === null) return\n    if (node.left) {\n      node.left.parent = node\n    }\n    if (node.right) {\n      node.right.parent = node\n    }\n    dfs(node.left)\n    dfs(node.right)\n    const gf = node.parent ? node.parent.parent : null\n    if (gf && gf.val % 2 === 0) {\n      total += node.val\n    }\n  }\n  dfs(root)\n  return total\n};\n```\n","date":"2023-10-11T15:10:43.205Z","updated":"2023-09-26T14:49:23.553Z","path":"leetcode/二叉树/1315.祖父节点值为偶数的节点和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001etnw78h85bh2e","content":"<h1 id=\"1315-祖父节点值为偶数的节点和\"><a href=\"#1315-祖父节点值为偶数的节点和\" class=\"headerlink\" title=\"1315. 祖父节点值为偶数的节点和\"></a>1315. 祖父节点值为偶数的节点和</h1><p>给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p>\n<ul>\n<li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li>\n</ul>\n<p>如果不存在祖父节点值为偶数的节点，那么返回 0 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sumEvenGrandparent = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gf = node.<span class=\"property\">parent</span> ? node.<span class=\"property\">parent</span>.<span class=\"property\">parent</span> : <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gf &amp;&amp; gf.<span class=\"property\">val</span> % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      total += node.<span class=\"property\">val</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1315-祖父节点值为偶数的节点和\"><a href=\"#1315-祖父节点值为偶数的节点和\" class=\"headerlink\" title=\"1315. 祖父节点值为偶数的节点和\"></a>1315. 祖父节点值为偶数的节点和</h1><p>给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p>\n<ul>\n<li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li>\n</ul>\n<p>如果不存在祖父节点值为偶数的节点，那么返回 0 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sumEvenGrandparent = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gf = node.<span class=\"property\">parent</span> ? node.<span class=\"property\">parent</span>.<span class=\"property\">parent</span> : <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gf &amp;&amp; gf.<span class=\"property\">val</span> % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      total += node.<span class=\"property\">val</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1325. 删除给定值的叶子节点\n\n给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。\n\n注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。\n\n也就是说，你需要重复此过程直到不能继续删除。\n\n[链接](https://leetcode-cn.com/problems/delete-leaves-with-a-given-value)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {TreeNode}\n */\nvar removeLeafNodes = function(root, target) {\n  if (root === null) return null\n  \n  if (root.left) {\n    root.left.parent = root\n  }\n  \n  if (root.right) {\n    root.right.parent = root\n  }\n\n  removeLeafNodes(root.left, target)\n  removeLeafNodes(root.right, target)\n  \n  if (root.left === null && root.right === null && root.val === target) {\n    if (root.parent) {\n      if (root.parent.left === root) root.parent.left = null\n      else root.parent.right = null\n    } else {\n      root = null\n    }\n  }\n\n\n  return root\n};\n```\n","source":"leetcode/二叉树/1325.删除给定值的叶子节点.md","raw":"# 1325. 删除给定值的叶子节点\n\n给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。\n\n注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。\n\n也就是说，你需要重复此过程直到不能继续删除。\n\n[链接](https://leetcode-cn.com/problems/delete-leaves-with-a-given-value)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {TreeNode}\n */\nvar removeLeafNodes = function(root, target) {\n  if (root === null) return null\n  \n  if (root.left) {\n    root.left.parent = root\n  }\n  \n  if (root.right) {\n    root.right.parent = root\n  }\n\n  removeLeafNodes(root.left, target)\n  removeLeafNodes(root.right, target)\n  \n  if (root.left === null && root.right === null && root.val === target) {\n    if (root.parent) {\n      if (root.parent.left === root) root.parent.left = null\n      else root.parent.right = null\n    } else {\n      root = null\n    }\n  }\n\n\n  return root\n};\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.553Z","path":"leetcode/二叉树/1325.删除给定值的叶子节点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001ftnw7ac5kfqbu","content":"<h1 id=\"1325-删除给定值的叶子节点\"><a href=\"#1325-删除给定值的叶子节点\" class=\"headerlink\" title=\"1325. 删除给定值的叶子节点\"></a>1325. 删除给定值的叶子节点</h1><p>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。</p>\n<p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p>\n<p>也就是说，你需要重复此过程直到不能继续删除。</p>\n<p><a href=\"https://leetcode-cn.com/problems/delete-leaves-with-a-given-value\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">target</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeLeafNodes = <span class=\"keyword\">function</span>(<span class=\"params\">root, target</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">    root.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">    root.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">removeLeafNodes</span>(root.<span class=\"property\">left</span>, target)</span><br><span class=\"line\">  <span class=\"title function_\">removeLeafNodes</span>(root.<span class=\"property\">right</span>, target)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">val</span> === target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root.<span class=\"property\">parent</span>.<span class=\"property\">left</span> === root) root.<span class=\"property\">parent</span>.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> root.<span class=\"property\">parent</span>.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      root = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1325-删除给定值的叶子节点\"><a href=\"#1325-删除给定值的叶子节点\" class=\"headerlink\" title=\"1325. 删除给定值的叶子节点\"></a>1325. 删除给定值的叶子节点</h1><p>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。</p>\n<p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p>\n<p>也就是说，你需要重复此过程直到不能继续删除。</p>\n<p><a href=\"https://leetcode-cn.com/problems/delete-leaves-with-a-given-value\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">target</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeLeafNodes = <span class=\"keyword\">function</span>(<span class=\"params\">root, target</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">    root.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">    root.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">removeLeafNodes</span>(root.<span class=\"property\">left</span>, target)</span><br><span class=\"line\">  <span class=\"title function_\">removeLeafNodes</span>(root.<span class=\"property\">right</span>, target)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">val</span> === target) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root.<span class=\"property\">parent</span>.<span class=\"property\">left</span> === root) root.<span class=\"property\">parent</span>.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> root.<span class=\"property\">parent</span>.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      root = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1339. 分裂二叉树的最大乘积\n\n给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。\n\n由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。\n\n[链接](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxProduct = function(root) {\n  let sum = 0\n  function count(node) {\n    if (node == null) return\n    sum += node.val\n    count(node.left)\n    count(node.right)\n  }\n  count(root)\n  let best = 0\n  function findMax(node) {\n    if (node === null) return 0\n    const cur = findMax(node.left) + findMax(node.right) + node.val\n    if (Math.abs(cur * 2 - sum) < Math.abs(best * 2 - sum)) {\n      best = cur\n    }\n    return cur\n  }\n  findMax(root)\n\n  return best * (sum - best) % 1000000007\n};\n```\n","source":"leetcode/二叉树/1339.分裂二叉树的最大乘积.md","raw":"# 1339. 分裂二叉树的最大乘积\n\n给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。\n\n由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。\n\n[链接](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxProduct = function(root) {\n  let sum = 0\n  function count(node) {\n    if (node == null) return\n    sum += node.val\n    count(node.left)\n    count(node.right)\n  }\n  count(root)\n  let best = 0\n  function findMax(node) {\n    if (node === null) return 0\n    const cur = findMax(node.left) + findMax(node.right) + node.val\n    if (Math.abs(cur * 2 - sum) < Math.abs(best * 2 - sum)) {\n      best = cur\n    }\n    return cur\n  }\n  findMax(root)\n\n  return best * (sum - best) % 1000000007\n};\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.554Z","path":"leetcode/二叉树/1339.分裂二叉树的最大乘积.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxo001gtnw7f954g6jn","content":"<h1 id=\"1339-分裂二叉树的最大乘积\"><a href=\"#1339-分裂二叉树的最大乘积\" class=\"headerlink\" title=\"1339. 分裂二叉树的最大乘积\"></a>1339. 分裂二叉树的最大乘积</h1><p>给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>\n<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxProduct = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">count</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    sum += node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"title function_\">count</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">count</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">count</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> best = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">findMax</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = <span class=\"title function_\">findMax</span>(node.<span class=\"property\">left</span>) + <span class=\"title function_\">findMax</span>(node.<span class=\"property\">right</span>) + node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(cur * <span class=\"number\">2</span> - sum) &lt; <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(best * <span class=\"number\">2</span> - sum)) &#123;</span><br><span class=\"line\">      best = cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findMax</span>(root)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> best * (sum - best) % <span class=\"number\">1000000007</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1339-分裂二叉树的最大乘积\"><a href=\"#1339-分裂二叉树的最大乘积\" class=\"headerlink\" title=\"1339. 分裂二叉树的最大乘积\"></a>1339. 分裂二叉树的最大乘积</h1><p>给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>\n<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxProduct = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">count</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    sum += node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"title function_\">count</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">count</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">count</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> best = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">findMax</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = <span class=\"title function_\">findMax</span>(node.<span class=\"property\">left</span>) + <span class=\"title function_\">findMax</span>(node.<span class=\"property\">right</span>) + node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(cur * <span class=\"number\">2</span> - sum) &lt; <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(best * <span class=\"number\">2</span> - sum)) &#123;</span><br><span class=\"line\">      best = cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findMax</span>(root)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> best * (sum - best) % <span class=\"number\">1000000007</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1361. 验证二叉树\n\n二叉树上有 n  个节点，按从  0  到 n - 1  编号，其中节点  i  的两个子节点分别是  leftChild[i]  和  rightChild[i]。\n\n只有 所有 节点能够形成且 只 形成 一颗   有效的二叉树时，返回  true；否则返回 false。\n\n如果节点  i  没有左子节点，那么  leftChild[i]  就等于  -1。右子节点也符合该规则。\n\n注意：节点没有值，本问题中仅仅使用节点编号。\n\n[链接](https://leetcode-cn.com/problems/validate-binary-tree-nodes)\n\n```js\n/**\n * @param {number} n\n * @param {number[]} leftChild\n * @param {number[]} rightChild\n * @return {boolean}\n */\nvar validateBinaryTreeNodes = function (n, leftChild, rightChild) {\n  const inDegree = new Array(n).fill(0);\n\n  // 计算入度, 每出现一次入度 + 1\n  for (let i = 0; i < n; i++) {\n    const l = leftChild[i];\n    const r = rightChild[i];\n    if (l !== -1) {\n      inDegree[l] += 1;\n    }\n    if (r !== -1) {\n      inDegree[r] += 1;\n    }\n  }\n\n  let count = 0;\n  if (inDegree.filter((deg) => deg === 0).length !== 1) {\n    return false;\n  } else {\n    const que = [inDegree.indexOf(0)];\n    while (que.length) {\n      const node = que.shift();\n      count += 1;\n      if (count > n) {\n        break;\n      }\n      if (leftChild[node] !== -1) {\n        que.push(leftChild[node]);\n      }\n      if (rightChild[node] !== -1) {\n        que.push(rightChild[node]);\n      }\n    }\n    return n === count;\n  }\n};\n```\n","source":"leetcode/二叉树/1361.验证二叉树.md","raw":"# 1361. 验证二叉树\n\n二叉树上有 n  个节点，按从  0  到 n - 1  编号，其中节点  i  的两个子节点分别是  leftChild[i]  和  rightChild[i]。\n\n只有 所有 节点能够形成且 只 形成 一颗   有效的二叉树时，返回  true；否则返回 false。\n\n如果节点  i  没有左子节点，那么  leftChild[i]  就等于  -1。右子节点也符合该规则。\n\n注意：节点没有值，本问题中仅仅使用节点编号。\n\n[链接](https://leetcode-cn.com/problems/validate-binary-tree-nodes)\n\n```js\n/**\n * @param {number} n\n * @param {number[]} leftChild\n * @param {number[]} rightChild\n * @return {boolean}\n */\nvar validateBinaryTreeNodes = function (n, leftChild, rightChild) {\n  const inDegree = new Array(n).fill(0);\n\n  // 计算入度, 每出现一次入度 + 1\n  for (let i = 0; i < n; i++) {\n    const l = leftChild[i];\n    const r = rightChild[i];\n    if (l !== -1) {\n      inDegree[l] += 1;\n    }\n    if (r !== -1) {\n      inDegree[r] += 1;\n    }\n  }\n\n  let count = 0;\n  if (inDegree.filter((deg) => deg === 0).length !== 1) {\n    return false;\n  } else {\n    const que = [inDegree.indexOf(0)];\n    while (que.length) {\n      const node = que.shift();\n      count += 1;\n      if (count > n) {\n        break;\n      }\n      if (leftChild[node] !== -1) {\n        que.push(leftChild[node]);\n      }\n      if (rightChild[node] !== -1) {\n        que.push(rightChild[node]);\n      }\n    }\n    return n === count;\n  }\n};\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.554Z","path":"leetcode/二叉树/1361.验证二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001htnw72bt0dyrf","content":"<h1 id=\"1361-验证二叉树\"><a href=\"#1361-验证二叉树\" class=\"headerlink\" title=\"1361. 验证二叉树\"></a>1361. 验证二叉树</h1><p>二叉树上有 n  个节点，按从  0  到 n - 1  编号，其中节点  i  的两个子节点分别是  leftChild[i]  和  rightChild[i]。</p>\n<p>只有 所有 节点能够形成且 只 形成 一颗   有效的二叉树时，返回  true；否则返回 false。</p>\n<p>如果节点  i  没有左子节点，那么  leftChild[i]  就等于  -1。右子节点也符合该规则。</p>\n<p>注意：节点没有值，本问题中仅仅使用节点编号。</p>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-tree-nodes\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">n</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">leftChild</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">rightChild</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> validateBinaryTreeNodes = <span class=\"keyword\">function</span> (<span class=\"params\">n, leftChild, rightChild</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inDegree = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 计算入度, 每出现一次入度 + 1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = leftChild[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = rightChild[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      inDegree[l] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      inDegree[r] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inDegree.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">deg</span>) =&gt;</span> deg === <span class=\"number\">0</span>).<span class=\"property\">length</span> !== <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> que = [inDegree.<span class=\"title function_\">indexOf</span>(<span class=\"number\">0</span>)];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (que.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = que.<span class=\"title function_\">shift</span>();</span><br><span class=\"line\">      count += <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (leftChild[node] !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        que.<span class=\"title function_\">push</span>(leftChild[node]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightChild[node] !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        que.<span class=\"title function_\">push</span>(rightChild[node]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n === count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1361-验证二叉树\"><a href=\"#1361-验证二叉树\" class=\"headerlink\" title=\"1361. 验证二叉树\"></a>1361. 验证二叉树</h1><p>二叉树上有 n  个节点，按从  0  到 n - 1  编号，其中节点  i  的两个子节点分别是  leftChild[i]  和  rightChild[i]。</p>\n<p>只有 所有 节点能够形成且 只 形成 一颗   有效的二叉树时，返回  true；否则返回 false。</p>\n<p>如果节点  i  没有左子节点，那么  leftChild[i]  就等于  -1。右子节点也符合该规则。</p>\n<p>注意：节点没有值，本问题中仅仅使用节点编号。</p>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-tree-nodes\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">n</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">leftChild</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">rightChild</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> validateBinaryTreeNodes = <span class=\"keyword\">function</span> (<span class=\"params\">n, leftChild, rightChild</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inDegree = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 计算入度, 每出现一次入度 + 1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = leftChild[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = rightChild[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      inDegree[l] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      inDegree[r] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inDegree.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">deg</span>) =&gt;</span> deg === <span class=\"number\">0</span>).<span class=\"property\">length</span> !== <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> que = [inDegree.<span class=\"title function_\">indexOf</span>(<span class=\"number\">0</span>)];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (que.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = que.<span class=\"title function_\">shift</span>();</span><br><span class=\"line\">      count += <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (leftChild[node] !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        que.<span class=\"title function_\">push</span>(leftChild[node]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightChild[node] !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        que.<span class=\"title function_\">push</span>(rightChild[node]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n === count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1367. 二叉树中的列表\n\n给你一棵以  root  为根的二叉树和一个  head  为第一个节点的链表。\n\n如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以  head  为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。\n\n一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。\n\n[链接](https://leetcode-cn.com/problems/linked-list-in-binary-tree)\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {TreeNode} root\n * @return {boolean}\n */\n\nfunction same(node, head) {\n  if (node === null) {\n    return head === null;\n  }\n  if (head === null) return true;\n  return (\n    node.val === head.val &&\n    (same(node.left, head.next) || same(node.right, head.next))\n  );\n}\n\nvar isSubPath = function (head, root) {\n  function dfs(node) {\n    if (node === null) {\n      return false;\n    }\n\n    const lr = dfs(node.left);\n    const rl = dfs(node.right);\n\n    return same(node, head) || lr || rl;\n  }\n\n  return dfs(root);\n};\n```\n","source":"leetcode/二叉树/1367.二叉树中的列表.md","raw":"# 1367. 二叉树中的列表\n\n给你一棵以  root  为根的二叉树和一个  head  为第一个节点的链表。\n\n如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以  head  为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。\n\n一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。\n\n[链接](https://leetcode-cn.com/problems/linked-list-in-binary-tree)\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {TreeNode} root\n * @return {boolean}\n */\n\nfunction same(node, head) {\n  if (node === null) {\n    return head === null;\n  }\n  if (head === null) return true;\n  return (\n    node.val === head.val &&\n    (same(node.left, head.next) || same(node.right, head.next))\n  );\n}\n\nvar isSubPath = function (head, root) {\n  function dfs(node) {\n    if (node === null) {\n      return false;\n    }\n\n    const lr = dfs(node.left);\n    const rl = dfs(node.right);\n\n    return same(node, head) || lr || rl;\n  }\n\n  return dfs(root);\n};\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.554Z","path":"leetcode/二叉树/1367.二叉树中的列表.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001itnw7dlgafosq","content":"<h1 id=\"1367-二叉树中的列表\"><a href=\"#1367-二叉树中的列表\" class=\"headerlink\" title=\"1367. 二叉树中的列表\"></a>1367. 二叉树中的列表</h1><p>给你一棵以  root  为根的二叉树和一个  head  为第一个节点的链表。</p>\n<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以  head  为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p>\n<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-in-binary-tree\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * function ListNode(val, next) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.next = (next===undefined ? null : next)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">ListNode</span>&#125; <span class=\"variable\">head</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">same</span>(<span class=\"params\">node, head</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head === <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    node.<span class=\"property\">val</span> === head.<span class=\"property\">val</span> &amp;&amp;</span><br><span class=\"line\">    (<span class=\"title function_\">same</span>(node.<span class=\"property\">left</span>, head.<span class=\"property\">next</span>) || <span class=\"title function_\">same</span>(node.<span class=\"property\">right</span>, head.<span class=\"property\">next</span>))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> isSubPath = <span class=\"keyword\">function</span> (<span class=\"params\">head, root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> lr = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rl = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">same</span>(node, head) || lr || rl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(root);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1367-二叉树中的列表\"><a href=\"#1367-二叉树中的列表\" class=\"headerlink\" title=\"1367. 二叉树中的列表\"></a>1367. 二叉树中的列表</h1><p>给你一棵以  root  为根的二叉树和一个  head  为第一个节点的链表。</p>\n<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以  head  为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p>\n<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-in-binary-tree\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * function ListNode(val, next) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.next = (next===undefined ? null : next)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">ListNode</span>&#125; <span class=\"variable\">head</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">same</span>(<span class=\"params\">node, head</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head === <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    node.<span class=\"property\">val</span> === head.<span class=\"property\">val</span> &amp;&amp;</span><br><span class=\"line\">    (<span class=\"title function_\">same</span>(node.<span class=\"property\">left</span>, head.<span class=\"property\">next</span>) || <span class=\"title function_\">same</span>(node.<span class=\"property\">right</span>, head.<span class=\"property\">next</span>))</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> isSubPath = <span class=\"keyword\">function</span> (<span class=\"params\">head, root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> lr = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rl = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">same</span>(node, head) || lr || rl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(root);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1376. 通知所有员工所需的时间\n\n公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。\n\n在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。\n\n公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。\n\n第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。\n\n返回通知所有员工这一紧急消息所需要的 分钟数 。\n\n[链接](https://leetcode-cn.com/problems/time-needed-to-inform-all-employees)\n\n```ts\nfunction numOfMinutes(\n  n: number,\n  headID: number,\n  manager: number[],\n  informTime: number[]\n): number {\n  let res = 0;\n  const mLen = manager.length;\n  for (let i = 0; i < mLen; i++) {\n    if (informTime[i] === 0) {\n      let temp = 0;\n      let index = i;\n      while (index !== -1) {\n        temp += informTime[index];\n        index = manager[index];\n      }\n      res = Math.max(res, temp);\n    }\n  }\n  return res;\n}\n```\n","source":"leetcode/二叉树/1376.通知所有员工所需的时间.md","raw":"# 1376. 通知所有员工所需的时间\n\n公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。\n\n在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。\n\n公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。\n\n第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。\n\n返回通知所有员工这一紧急消息所需要的 分钟数 。\n\n[链接](https://leetcode-cn.com/problems/time-needed-to-inform-all-employees)\n\n```ts\nfunction numOfMinutes(\n  n: number,\n  headID: number,\n  manager: number[],\n  informTime: number[]\n): number {\n  let res = 0;\n  const mLen = manager.length;\n  for (let i = 0; i < mLen; i++) {\n    if (informTime[i] === 0) {\n      let temp = 0;\n      let index = i;\n      while (index !== -1) {\n        temp += informTime[index];\n        index = manager[index];\n      }\n      res = Math.max(res, temp);\n    }\n  }\n  return res;\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.554Z","path":"leetcode/二叉树/1376.通知所有员工所需的时间.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001jtnw75sn9gvte","content":"<h1 id=\"1376-通知所有员工所需的时间\"><a href=\"#1376-通知所有员工所需的时间\" class=\"headerlink\" title=\"1376. 通知所有员工所需的时间\"></a>1376. 通知所有员工所需的时间</h1><p>公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。</p>\n<p>在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。</p>\n<p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p>\n<p>第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。</p>\n<p>返回通知所有员工这一紧急消息所需要的 分钟数 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/time-needed-to-inform-all-employees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">numOfMinutes</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  n: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  headID: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  manager: <span class=\"built_in\">number</span>[],</span></span><br><span class=\"line\"><span class=\"params\">  informTime: <span class=\"built_in\">number</span>[]</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mLen = manager.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; mLen; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (informTime[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = i;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        temp += informTime[index];</span><br><span class=\"line\">        index = manager[index];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(res, temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1376-通知所有员工所需的时间\"><a href=\"#1376-通知所有员工所需的时间\" class=\"headerlink\" title=\"1376. 通知所有员工所需的时间\"></a>1376. 通知所有员工所需的时间</h1><p>公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。</p>\n<p>在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。</p>\n<p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p>\n<p>第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。</p>\n<p>返回通知所有员工这一紧急消息所需要的 分钟数 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/time-needed-to-inform-all-employees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">numOfMinutes</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  n: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  headID: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  manager: <span class=\"built_in\">number</span>[],</span></span><br><span class=\"line\"><span class=\"params\">  informTime: <span class=\"built_in\">number</span>[]</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mLen = manager.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; mLen; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (informTime[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = i;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        temp += informTime[index];</span><br><span class=\"line\">        index = manager[index];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(res, temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1379. 找出克隆二叉树中的相同节点\n\n给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original  中的目标节点  target。\n\n其中，克隆树 cloned  是原始树 original  的一个 副本 。\n\n请找出在树  cloned  中，与  target  相同   的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。\n\n[链接](https://leetcode-cn.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getTargetCopy(\n  original: TreeNode | null,\n  cloned: TreeNode | null,\n  target: TreeNode | null\n): TreeNode | null {\n  function dfs(node: TreeNode | null) {\n    if (node === null) return null;\n    if (node.val === target.val) {\n      return node;\n    }\n    const lRes = dfs(node.left);\n    if (lRes) {\n      return lRes;\n    }\n    const rRes = dfs(node.right);\n    return rRes;\n  }\n  return dfs(cloned);\n}\n```\n","source":"leetcode/二叉树/1379.找出克隆二叉树中的相同节点.md","raw":"# 1379. 找出克隆二叉树中的相同节点\n\n给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original  中的目标节点  target。\n\n其中，克隆树 cloned  是原始树 original  的一个 副本 。\n\n请找出在树  cloned  中，与  target  相同   的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。\n\n[链接](https://leetcode-cn.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getTargetCopy(\n  original: TreeNode | null,\n  cloned: TreeNode | null,\n  target: TreeNode | null\n): TreeNode | null {\n  function dfs(node: TreeNode | null) {\n    if (node === null) return null;\n    if (node.val === target.val) {\n      return node;\n    }\n    const lRes = dfs(node.left);\n    if (lRes) {\n      return lRes;\n    }\n    const rRes = dfs(node.right);\n    return rRes;\n  }\n  return dfs(cloned);\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.555Z","path":"leetcode/二叉树/1379.找出克隆二叉树中的相同节点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001ktnw7cy1u87n9","content":"<h1 id=\"1379-找出克隆二叉树中的相同节点\"><a href=\"#1379-找出克隆二叉树中的相同节点\" class=\"headerlink\" title=\"1379. 找出克隆二叉树中的相同节点\"></a>1379. 找出克隆二叉树中的相同节点</h1><p>给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original  中的目标节点  target。</p>\n<p>其中，克隆树 cloned  是原始树 original  的一个 副本 。</p>\n<p>请找出在树  cloned  中，与  target  相同   的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTargetCopy</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  original: TreeNode | <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">  cloned: TreeNode | <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">  target: TreeNode | <span class=\"literal\">null</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === target.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lRes = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lRes) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lRes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rRes = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rRes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(cloned);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1379-找出克隆二叉树中的相同节点\"><a href=\"#1379-找出克隆二叉树中的相同节点\" class=\"headerlink\" title=\"1379. 找出克隆二叉树中的相同节点\"></a>1379. 找出克隆二叉树中的相同节点</h1><p>给你两棵二叉树，原始树 original 和克隆树 cloned，以及一个位于原始树 original  中的目标节点  target。</p>\n<p>其中，克隆树 cloned  是原始树 original  的一个 副本 。</p>\n<p>请找出在树  cloned  中，与  target  相同   的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTargetCopy</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  original: TreeNode | <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">  cloned: TreeNode | <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"params\">  target: TreeNode | <span class=\"literal\">null</span></span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === target.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lRes = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lRes) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lRes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rRes = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rRes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(cloned);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1382. 将二叉搜索树变平衡\n\n给你一棵二叉搜索树，请你返回一棵   平衡后   的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。\n\n如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是   平衡的 。\n\n如果有多种构造方法，请你返回任意一种。\n\n[链接](https://leetcode-cn.com/problems/balance-a-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nvar balanceBST = function (root) {\n  // 获取节点值。bst中序遍历返回升序数组。\n  let arr = [];\n  let fn = (node) => {\n    if (!node) return;\n    fn(node.left);\n    arr.push(node.val);\n    fn(node.right);\n  };\n  fn(root);\n\n  // 重建平衡bst\n  let mid = ~~(arr.length / 2);\n  let h = new TreeNode(arr[mid]);\n  let buildTree = (node, arr, mid) => {\n    if (!arr.length || arr.length === 1) {\n      return;\n    }\n    if (arr.length === 2) {\n      // 跟mid的划分有关，有两个数，mid是右侧那个\n      node.left = new TreeNode(arr[0]);\n      return;\n    }\n\n    // 左树\n    node.left = new TreeNode(arr[~~(mid / 2)]);\n    buildTree(node.left, arr.slice(0, mid), ~~(mid / 2));\n\n    // 右树\n    let a = arr.slice(mid + 1);\n    let mi = ~~(a.length / 2);\n    node.right = new TreeNode(a[mi]);\n    buildTree(node.right, a, mi);\n  };\n  // 参数解释：给定一个数组，已经锁定了head和head的index\n  buildTree(h, arr, mid);\n  return h;\n};\n```\n","source":"leetcode/二叉树/1382.将二叉搜索树变平衡.md","raw":"# 1382. 将二叉搜索树变平衡\n\n给你一棵二叉搜索树，请你返回一棵   平衡后   的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。\n\n如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是   平衡的 。\n\n如果有多种构造方法，请你返回任意一种。\n\n[链接](https://leetcode-cn.com/problems/balance-a-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nvar balanceBST = function (root) {\n  // 获取节点值。bst中序遍历返回升序数组。\n  let arr = [];\n  let fn = (node) => {\n    if (!node) return;\n    fn(node.left);\n    arr.push(node.val);\n    fn(node.right);\n  };\n  fn(root);\n\n  // 重建平衡bst\n  let mid = ~~(arr.length / 2);\n  let h = new TreeNode(arr[mid]);\n  let buildTree = (node, arr, mid) => {\n    if (!arr.length || arr.length === 1) {\n      return;\n    }\n    if (arr.length === 2) {\n      // 跟mid的划分有关，有两个数，mid是右侧那个\n      node.left = new TreeNode(arr[0]);\n      return;\n    }\n\n    // 左树\n    node.left = new TreeNode(arr[~~(mid / 2)]);\n    buildTree(node.left, arr.slice(0, mid), ~~(mid / 2));\n\n    // 右树\n    let a = arr.slice(mid + 1);\n    let mi = ~~(a.length / 2);\n    node.right = new TreeNode(a[mi]);\n    buildTree(node.right, a, mi);\n  };\n  // 参数解释：给定一个数组，已经锁定了head和head的index\n  buildTree(h, arr, mid);\n  return h;\n};\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.555Z","path":"leetcode/二叉树/1382.将二叉搜索树变平衡.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001ltnw79tvchch1","content":"<h1 id=\"1382-将二叉搜索树变平衡\"><a href=\"#1382-将二叉搜索树变平衡\" class=\"headerlink\" title=\"1382. 将二叉搜索树变平衡\"></a>1382. 将二叉搜索树变平衡</h1><p>给你一棵二叉搜索树，请你返回一棵   平衡后   的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p>\n<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是   平衡的 。</p>\n<p>如果有多种构造方法，请你返回任意一种。</p>\n<p><a href=\"https://leetcode-cn.com/problems/balance-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> balanceBST = <span class=\"keyword\">function</span> (<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取节点值。bst中序遍历返回升序数组。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title function_\">fn</span> = (<span class=\"params\">node</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>(node.<span class=\"property\">left</span>);</span><br><span class=\"line\">    arr.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>);</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>(node.<span class=\"property\">right</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"title function_\">fn</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 重建平衡bst</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = ~~(arr.<span class=\"property\">length</span> / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[mid]);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title function_\">buildTree</span> = (<span class=\"params\">node, arr, mid</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!arr.<span class=\"property\">length</span> || arr.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.<span class=\"property\">length</span> === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 跟mid的划分有关，有两个数，mid是右侧那个</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 左树</span></span><br><span class=\"line\">    node.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[~~(mid / <span class=\"number\">2</span>)]);</span><br><span class=\"line\">    <span class=\"title function_\">buildTree</span>(node.<span class=\"property\">left</span>, arr.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, mid), ~~(mid / <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 右树</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = arr.<span class=\"title function_\">slice</span>(mid + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mi = ~~(a.<span class=\"property\">length</span> / <span class=\"number\">2</span>);</span><br><span class=\"line\">    node.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(a[mi]);</span><br><span class=\"line\">    <span class=\"title function_\">buildTree</span>(node.<span class=\"property\">right</span>, a, mi);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 参数解释：给定一个数组，已经锁定了head和head的index</span></span><br><span class=\"line\">  <span class=\"title function_\">buildTree</span>(h, arr, mid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1382-将二叉搜索树变平衡\"><a href=\"#1382-将二叉搜索树变平衡\" class=\"headerlink\" title=\"1382. 将二叉搜索树变平衡\"></a>1382. 将二叉搜索树变平衡</h1><p>给你一棵二叉搜索树，请你返回一棵   平衡后   的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p>\n<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是   平衡的 。</p>\n<p>如果有多种构造方法，请你返回任意一种。</p>\n<p><a href=\"https://leetcode-cn.com/problems/balance-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> balanceBST = <span class=\"keyword\">function</span> (<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取节点值。bst中序遍历返回升序数组。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title function_\">fn</span> = (<span class=\"params\">node</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>(node.<span class=\"property\">left</span>);</span><br><span class=\"line\">    arr.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>);</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>(node.<span class=\"property\">right</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"title function_\">fn</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 重建平衡bst</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = ~~(arr.<span class=\"property\">length</span> / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[mid]);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title function_\">buildTree</span> = (<span class=\"params\">node, arr, mid</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!arr.<span class=\"property\">length</span> || arr.<span class=\"property\">length</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.<span class=\"property\">length</span> === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 跟mid的划分有关，有两个数，mid是右侧那个</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 左树</span></span><br><span class=\"line\">    node.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[~~(mid / <span class=\"number\">2</span>)]);</span><br><span class=\"line\">    <span class=\"title function_\">buildTree</span>(node.<span class=\"property\">left</span>, arr.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, mid), ~~(mid / <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 右树</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = arr.<span class=\"title function_\">slice</span>(mid + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mi = ~~(a.<span class=\"property\">length</span> / <span class=\"number\">2</span>);</span><br><span class=\"line\">    node.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(a[mi]);</span><br><span class=\"line\">    <span class=\"title function_\">buildTree</span>(node.<span class=\"property\">right</span>, a, mi);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 参数解释：给定一个数组，已经锁定了head和head的index</span></span><br><span class=\"line\">  <span class=\"title function_\">buildTree</span>(h, arr, mid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 144. 二叉树的前序遍历\n\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n\n```ts\nlet res = []\n\nfunction preorderTraversal(root: TreeNode | null): number[] {\n  if (root === null) return []\n  res = []\n  traverse(root)\n  return res\n};\n\nfunction traverse(root: TreeNode | null) {\n  if (root === null) return\n  res.push(root.val)\n  traverse(root.left)\n  traverse(root.right)\n}\n```\n","source":"leetcode/二叉树/144.二叉树的前序遍历.md","raw":"# 144. 二叉树的前序遍历\n\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n\n```ts\nlet res = []\n\nfunction preorderTraversal(root: TreeNode | null): number[] {\n  if (root === null) return []\n  res = []\n  traverse(root)\n  return res\n};\n\nfunction traverse(root: TreeNode | null) {\n  if (root === null) return\n  res.push(root.val)\n  traverse(root.left)\n  traverse(root.right)\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.555Z","path":"leetcode/二叉树/144.二叉树的前序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001mtnw70hwb2gfb","content":"<h1 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a>144. 二叉树的前序遍历</h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">preorderTraversal</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a>144. 二叉树的前序遍历</h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">preorderTraversal</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1448. 统计二叉树中好节点的数目\n\n给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。\n\n「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。\n\n[链接](https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction goodNodes(root: TreeNode | null): number {\n  let num = 0;\n  if (root === null) return num;\n  function dfs(node: TreeNode, maxVal: number) {\n    if (node === null) return;\n    if (node.val >= maxVal) {\n      num++;\n      maxVal = node.val;\n    }\n    dfs(node.left, maxVal);\n    dfs(node.right, maxVal);\n  }\n  dfs(root, root.val);\n  return num;\n}\n```\n","source":"leetcode/二叉树/1448.统计二叉树中好节点的数目.md","raw":"# 1448. 统计二叉树中好节点的数目\n\n给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。\n\n「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。\n\n[链接](https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction goodNodes(root: TreeNode | null): number {\n  let num = 0;\n  if (root === null) return num;\n  function dfs(node: TreeNode, maxVal: number) {\n    if (node === null) return;\n    if (node.val >= maxVal) {\n      num++;\n      maxVal = node.val;\n    }\n    dfs(node.left, maxVal);\n    dfs(node.right, maxVal);\n  }\n  dfs(root, root.val);\n  return num;\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.555Z","path":"leetcode/二叉树/1448.统计二叉树中好节点的数目.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001ntnw7defi5916","content":"<h1 id=\"1448-统计二叉树中好节点的数目\"><a href=\"#1448-统计二叉树中好节点的数目\" class=\"headerlink\" title=\"1448. 统计二叉树中好节点的数目\"></a>1448. 统计二叉树中好节点的数目</h1><p>给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。</p>\n<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">goodNodes</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode, maxVal: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt;= maxVal) &#123;</span><br><span class=\"line\">      num++;</span><br><span class=\"line\">      maxVal = node.<span class=\"property\">val</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, maxVal);</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, maxVal);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root, root.<span class=\"property\">val</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1448-统计二叉树中好节点的数目\"><a href=\"#1448-统计二叉树中好节点的数目\" class=\"headerlink\" title=\"1448. 统计二叉树中好节点的数目\"></a>1448. 统计二叉树中好节点的数目</h1><p>给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。</p>\n<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">goodNodes</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode, maxVal: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt;= maxVal) &#123;</span><br><span class=\"line\">      num++;</span><br><span class=\"line\">      maxVal = node.<span class=\"property\">val</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, maxVal);</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, maxVal);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root, root.<span class=\"property\">val</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 145. 二叉树的后序遍历\n\n给定一个二叉树，返回它的 后序 遍历。\n\n```ts\nlet res = []\n\nfunction postorderTraversal(root: TreeNode | null): number[] {\n  if (root === null) return []\n  res = []\n  traverse(root)\n  return res\n};\n\nfunction traverse(root: TreeNode | null) {\n  if (root === null) return\n  traverse(root.left)\n  traverse(root.right)\n  res.push(root.val)\n}\n```\n","source":"leetcode/二叉树/145.二叉树的后序遍历.md","raw":"# 145. 二叉树的后序遍历\n\n给定一个二叉树，返回它的 后序 遍历。\n\n```ts\nlet res = []\n\nfunction postorderTraversal(root: TreeNode | null): number[] {\n  if (root === null) return []\n  res = []\n  traverse(root)\n  return res\n};\n\nfunction traverse(root: TreeNode | null) {\n  if (root === null) return\n  traverse(root.left)\n  traverse(root.right)\n  res.push(root.val)\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.555Z","path":"leetcode/二叉树/145.二叉树的后序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001otnw7f4kv1k08","content":"<h1 id=\"145-二叉树的后序遍历\"><a href=\"#145-二叉树的后序遍历\" class=\"headerlink\" title=\"145. 二叉树的后序遍历\"></a>145. 二叉树的后序遍历</h1><p>给定一个二叉树，返回它的 后序 遍历。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">postorderTraversal</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"145-二叉树的后序遍历\"><a href=\"#145-二叉树的后序遍历\" class=\"headerlink\" title=\"145. 二叉树的后序遍历\"></a>145. 二叉树的后序遍历</h1><p>给定一个二叉树，返回它的 后序 遍历。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">postorderTraversal</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 1457. 二叉树中的伪回文路径\n\n给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。\n\n请你返回从根到叶子节点的所有路径中   伪回文   路径的数目。\n\n[链接](https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pseudoPalindromicPaths(root: TreeNode | null): number {\n  let res = 0;\n  if (root === null) return res;\n  function dfs(node: TreeNode, pathMap: Record<number, number>) {\n    if (node === null) {\n      return;\n    }\n    if (!pathMap[node.val]) {\n      pathMap[node.val] = 0;\n    }\n    pathMap[node.val] += 1;\n    if (node.left === null && node.right === null) {\n      const vals: number[] = Object.values(pathMap);\n      const len = vals.length;\n      const oneArr: number[] = [];\n      let total = 0;\n      for (let i = 0; i < len; i++) {\n        const count = vals[i];\n        if (count % 2 === 1) {\n          oneArr.push(count);\n        }\n        total += count;\n      }\n      if (oneArr.length === 0 || (oneArr.length === 1 && total % 2 === 1)) {\n        res++;\n      }\n      return;\n    }\n    dfs(node.left, Object.assign({}, pathMap));\n    dfs(node.right, Object.assign({}, pathMap));\n  }\n  dfs(root, {});\n  return res;\n}\n```\n","source":"leetcode/二叉树/1457.二叉树中的伪回文路径.md","raw":"# 1457. 二叉树中的伪回文路径\n\n给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。\n\n请你返回从根到叶子节点的所有路径中   伪回文   路径的数目。\n\n[链接](https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pseudoPalindromicPaths(root: TreeNode | null): number {\n  let res = 0;\n  if (root === null) return res;\n  function dfs(node: TreeNode, pathMap: Record<number, number>) {\n    if (node === null) {\n      return;\n    }\n    if (!pathMap[node.val]) {\n      pathMap[node.val] = 0;\n    }\n    pathMap[node.val] += 1;\n    if (node.left === null && node.right === null) {\n      const vals: number[] = Object.values(pathMap);\n      const len = vals.length;\n      const oneArr: number[] = [];\n      let total = 0;\n      for (let i = 0; i < len; i++) {\n        const count = vals[i];\n        if (count % 2 === 1) {\n          oneArr.push(count);\n        }\n        total += count;\n      }\n      if (oneArr.length === 0 || (oneArr.length === 1 && total % 2 === 1)) {\n        res++;\n      }\n      return;\n    }\n    dfs(node.left, Object.assign({}, pathMap));\n    dfs(node.right, Object.assign({}, pathMap));\n  }\n  dfs(root, {});\n  return res;\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.556Z","path":"leetcode/二叉树/1457.二叉树中的伪回文路径.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001ptnw7hddc2ahq","content":"<h1 id=\"1457-二叉树中的伪回文路径\"><a href=\"#1457-二叉树中的伪回文路径\" class=\"headerlink\" title=\"1457. 二叉树中的伪回文路径\"></a>1457. 二叉树中的伪回文路径</h1><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>\n<p>请你返回从根到叶子节点的所有路径中   伪回文   路径的数目。</p>\n<p><a href=\"https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pseudoPalindromicPaths</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode, pathMap: Record&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pathMap[node.<span class=\"property\">val</span>]) &#123;</span><br><span class=\"line\">      pathMap[node.<span class=\"property\">val</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pathMap[node.<span class=\"property\">val</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">vals</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Object</span>.<span class=\"title function_\">values</span>(pathMap);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = vals.<span class=\"property\">length</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">oneArr</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> count = vals[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count % <span class=\"number\">2</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          oneArr.<span class=\"title function_\">push</span>(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        total += count;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oneArr.<span class=\"property\">length</span> === <span class=\"number\">0</span> || (oneArr.<span class=\"property\">length</span> === <span class=\"number\">1</span> &amp;&amp; total % <span class=\"number\">2</span> === <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        res++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, pathMap));</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, pathMap));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root, &#123;&#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1457-二叉树中的伪回文路径\"><a href=\"#1457-二叉树中的伪回文路径\" class=\"headerlink\" title=\"1457. 二叉树中的伪回文路径\"></a>1457. 二叉树中的伪回文路径</h1><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>\n<p>请你返回从根到叶子节点的所有路径中   伪回文   路径的数目。</p>\n<p><a href=\"https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pseudoPalindromicPaths</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode, pathMap: Record&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pathMap[node.<span class=\"property\">val</span>]) &#123;</span><br><span class=\"line\">      pathMap[node.<span class=\"property\">val</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pathMap[node.<span class=\"property\">val</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">vals</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Object</span>.<span class=\"title function_\">values</span>(pathMap);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> len = vals.<span class=\"property\">length</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">oneArr</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> count = vals[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count % <span class=\"number\">2</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          oneArr.<span class=\"title function_\">push</span>(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        total += count;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oneArr.<span class=\"property\">length</span> === <span class=\"number\">0</span> || (oneArr.<span class=\"property\">length</span> === <span class=\"number\">1</span> &amp;&amp; total % <span class=\"number\">2</span> === <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        res++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, pathMap));</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, pathMap));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root, &#123;&#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 173. 二叉搜索树迭代器\n\n实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n\n- BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。\n\n- boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。\n\n- int next()将指针向右移动，然后返回指针处的数字。\n\n注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。\n\n你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。\n\n[链接](https://leetcode-cn.com/problems/binary-search-tree-iterator)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n  this.first = null\n  this.end = false\n  this.initData(root)\n};\n\nBSTIterator.prototype.initData = function(root) {\n  if (root === null) return\n  root.right && (root.right.parent = root)\n  this.initData(root.right)\n  root.left && (root.left.parent = root)\n  this.first = root\n  this.initData(root.left)\n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  let res = this.first\n  this.first.isReaded = true\n  if (this.first.right) {\n    let right = this.first.right\n    while(right) {\n      this.first = right\n      right = right.left\n    }\n  } else {\n    let parent = this.first.parent\n    if (parent && !this.end) {\n      while(parent.parent && parent.isReaded) {\n        parent = parent.parent\n      }\n      if (parent.isReaded) {\n        this.end = true\n      } else {\n        this.first = parent\n      }\n    }\n  }\n  return res.val\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return !this.first.isReaded\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n```\n\n栈堆解法\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n  this.stack = []\n  this.cur = root\n};\n\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  while(this.cur) {\n    this.stack.push(this.cur)\n    this.cur = this.cur.left\n  }\n  this.cur = this.stack.pop()\n  const ret = this.cur.val\n  this.cur = this.cur.right\n  return ret\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return this.cur !== null || this.stack.length\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n```\n","source":"leetcode/二叉树/173.二叉搜索树迭代器.md","raw":"# 173. 二叉搜索树迭代器\n\n实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n\n- BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。\n\n- boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。\n\n- int next()将指针向右移动，然后返回指针处的数字。\n\n注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。\n\n你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。\n\n[链接](https://leetcode-cn.com/problems/binary-search-tree-iterator)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n  this.first = null\n  this.end = false\n  this.initData(root)\n};\n\nBSTIterator.prototype.initData = function(root) {\n  if (root === null) return\n  root.right && (root.right.parent = root)\n  this.initData(root.right)\n  root.left && (root.left.parent = root)\n  this.first = root\n  this.initData(root.left)\n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  let res = this.first\n  this.first.isReaded = true\n  if (this.first.right) {\n    let right = this.first.right\n    while(right) {\n      this.first = right\n      right = right.left\n    }\n  } else {\n    let parent = this.first.parent\n    if (parent && !this.end) {\n      while(parent.parent && parent.isReaded) {\n        parent = parent.parent\n      }\n      if (parent.isReaded) {\n        this.end = true\n      } else {\n        this.first = parent\n      }\n    }\n  }\n  return res.val\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return !this.first.isReaded\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n```\n\n栈堆解法\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n  this.stack = []\n  this.cur = root\n};\n\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  while(this.cur) {\n    this.stack.push(this.cur)\n    this.cur = this.cur.left\n  }\n  this.cur = this.stack.pop()\n  const ret = this.cur.val\n  this.cur = this.cur.right\n  return ret\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return this.cur !== null || this.stack.length\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.556Z","path":"leetcode/二叉树/173.二叉搜索树迭代器.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001qtnw71lxfhxmf","content":"<h1 id=\"173-二叉搜索树迭代器\"><a href=\"#173-二叉搜索树迭代器\" class=\"headerlink\" title=\"173. 二叉搜索树迭代器\"></a>173. 二叉搜索树迭代器</h1><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>\n<ul>\n<li><p>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</p>\n</li>\n<li><p>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。</p>\n</li>\n<li><p>int next()将指针向右移动，然后返回指针处的数字。</p>\n</li>\n</ul>\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>\n<p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">BSTIterator</span> = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">end</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">initData</span>(root)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">initData</span> = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  root.<span class=\"property\">right</span> &amp;&amp; (root.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = root)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">initData</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> &amp;&amp; (root.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = root)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = root</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">initData</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">next</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"variable language_\">this</span>.<span class=\"property\">first</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">isReaded</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">right</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = right</span><br><span class=\"line\">      right = right.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">parent</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent &amp;&amp; !<span class=\"variable language_\">this</span>.<span class=\"property\">end</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(parent.<span class=\"property\">parent</span> &amp;&amp; parent.<span class=\"property\">isReaded</span>) &#123;</span><br><span class=\"line\">        parent = parent.<span class=\"property\">parent</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parent.<span class=\"property\">isReaded</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">end</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = parent</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.<span class=\"property\">val</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">hasNext</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !<span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">isReaded</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new BSTIterator(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.next()</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.hasNext()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>栈堆解法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">BSTIterator</span> = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span> = []</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = root</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">next</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>.<span class=\"property\">left</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ret = <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>.<span class=\"property\">right</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">hasNext</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> !== <span class=\"literal\">null</span> || <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"property\">length</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new BSTIterator(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.next()</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.hasNext()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"173-二叉搜索树迭代器\"><a href=\"#173-二叉搜索树迭代器\" class=\"headerlink\" title=\"173. 二叉搜索树迭代器\"></a>173. 二叉搜索树迭代器</h1><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>\n<ul>\n<li><p>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</p>\n</li>\n<li><p>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。</p>\n</li>\n<li><p>int next()将指针向右移动，然后返回指针处的数字。</p>\n</li>\n</ul>\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>\n<p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">BSTIterator</span> = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">end</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">initData</span>(root)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">initData</span> = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  root.<span class=\"property\">right</span> &amp;&amp; (root.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = root)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">initData</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> &amp;&amp; (root.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = root)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = root</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">initData</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">next</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"variable language_\">this</span>.<span class=\"property\">first</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">isReaded</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">right</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = right</span><br><span class=\"line\">      right = right.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = <span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">parent</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent &amp;&amp; !<span class=\"variable language_\">this</span>.<span class=\"property\">end</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(parent.<span class=\"property\">parent</span> &amp;&amp; parent.<span class=\"property\">isReaded</span>) &#123;</span><br><span class=\"line\">        parent = parent.<span class=\"property\">parent</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parent.<span class=\"property\">isReaded</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">end</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">first</span> = parent</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.<span class=\"property\">val</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">hasNext</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !<span class=\"variable language_\">this</span>.<span class=\"property\">first</span>.<span class=\"property\">isReaded</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new BSTIterator(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.next()</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.hasNext()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>栈堆解法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">BSTIterator</span> = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span> = []</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = root</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">next</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>.<span class=\"property\">left</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ret = <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span>.<span class=\"property\">right</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">BSTIterator</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">hasNext</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">cur</span> !== <span class=\"literal\">null</span> || <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"property\">length</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new BSTIterator(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.next()</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.hasNext()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 199. 二叉树的右视图\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-right-side-view/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction rightSideView(root: TreeNode | null): number[] {\n  const res: number[] = [];\n  if (root === null) return res;\n  const nodeQues: TreeNode[] = [root];\n  while(nodeQues.length > 0) {\n    const childs = nodeQues.splice(0);\n    const clen = childs.length;\n    res.push(childs[clen - 1].val)\n    for(let i = 0; i < clen; i++) {\n      const node = childs[i];\n      if (node.left) nodeQues.push(node.left)\n      if (node.right) nodeQues.push(node.right)\n    }\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/199.二叉树的右视图.md","raw":"# 199. 二叉树的右视图\n\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-right-side-view/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction rightSideView(root: TreeNode | null): number[] {\n  const res: number[] = [];\n  if (root === null) return res;\n  const nodeQues: TreeNode[] = [root];\n  while(nodeQues.length > 0) {\n    const childs = nodeQues.splice(0);\n    const clen = childs.length;\n    res.push(childs[clen - 1].val)\n    for(let i = 0; i < clen; i++) {\n      const node = childs[i];\n      if (node.left) nodeQues.push(node.left)\n      if (node.right) nodeQues.push(node.right)\n    }\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.556Z","path":"leetcode/二叉树/199.二叉树的右视图.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001rtnw778zcheu8","content":"<h1 id=\"199-二叉树的右视图\"><a href=\"#199-二叉树的右视图\" class=\"headerlink\" title=\"199. 二叉树的右视图\"></a>199. 二叉树的右视图</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rightSideView</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root];</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childs = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> clen = childs.<span class=\"property\">length</span>;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(childs[clen - <span class=\"number\">1</span>].<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; clen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = childs[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"199-二叉树的右视图\"><a href=\"#199-二叉树的右视图\" class=\"headerlink\" title=\"199. 二叉树的右视图\"></a>199. 二叉树的右视图</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rightSideView</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root];</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childs = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> clen = childs.<span class=\"property\">length</span>;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(childs[clen - <span class=\"number\">1</span>].<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; clen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = childs[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 230. 二叉搜索树中第K小的元素\n\n给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n\n[链接](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n```ts\nlet rank = 0\nlet res = 0\nfunction kthSmallest(root: TreeNode | null, k: number): number {\n  rank = 0\n  res = 0\n  traverse(root, k)\n  return res\n};\n\nfunction traverse(root: TreeNode, k: number) {\n  if (root === null) return\n  traverse(root.left, k)\n  rank++\n  if (rank === k) {\n    res = root.val\n    return\n  }\n  traverse(root.right, k)\n}\n```\n","source":"leetcode/二叉树/230.二叉搜索树中第K小的元素.md","raw":"# 230. 二叉搜索树中第K小的元素\n\n给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n\n[链接](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n```ts\nlet rank = 0\nlet res = 0\nfunction kthSmallest(root: TreeNode | null, k: number): number {\n  rank = 0\n  res = 0\n  traverse(root, k)\n  return res\n};\n\nfunction traverse(root: TreeNode, k: number) {\n  if (root === null) return\n  traverse(root.left, k)\n  rank++\n  if (rank === k) {\n    res = root.val\n    return\n  }\n  traverse(root.right, k)\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.557Z","path":"leetcode/二叉树/230.二叉搜索树中第K小的元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001stnw78yty4sae","content":"<h1 id=\"230-二叉搜索树中第K小的元素\"><a href=\"#230-二叉搜索树中第K小的元素\" class=\"headerlink\" title=\"230. 二叉搜索树中第K小的元素\"></a>230. 二叉搜索树中第K小的元素</h1><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rank = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">kthSmallest</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  rank = <span class=\"number\">0</span></span><br><span class=\"line\">  res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, k)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, k: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, k)</span><br><span class=\"line\">  rank++</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rank === k) &#123;</span><br><span class=\"line\">    res = root.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"230-二叉搜索树中第K小的元素\"><a href=\"#230-二叉搜索树中第K小的元素\" class=\"headerlink\" title=\"230. 二叉搜索树中第K小的元素\"></a>230. 二叉搜索树中第K小的元素</h1><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rank = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">kthSmallest</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  rank = <span class=\"number\">0</span></span><br><span class=\"line\">  res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, k)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, k: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, k)</span><br><span class=\"line\">  rank++</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rank === k) &#123;</span><br><span class=\"line\">    res = root.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 236. 二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n  let res = null\n  if (root === null) return res\n  const nodeQues = []\n  nodeQues.push(root)\n  let pNode = null\n  let qNode = null\n  while(nodeQues.length > 0) {\n    const childNodes = nodeQues.splice(0)\n    const childLen = childNodes.length\n    if (pNode !== null && qNode !== null) break\n    for(let i = 0; i < childLen;i++) {\n      const node = childNodes[i]\n      if (node) {\n        if (node.val === p.val) {\n          pNode = node\n        } else if (node.val === q.val) {\n          qNode = node\n        }\n        if (pNode !== null && qNode !== null) break\n        if (node.left) {\n          node.left.parent = node\n          nodeQues.push(node.left)\n        }\n        if (node.right) {\n          node.right.parent = node\n          nodeQues.push(node.right)\n        }\n      }\n    }\n  }\n  if (pNode === null || qNode === null || pNode.val === qNode.val) {\n    return pNode ? pNode.val : qNode.val\n  }\n  const pNodeMap = {}\n  while(pNode) {\n    pNodeMap[pNode.val] = true\n    pNode = pNode.parent\n  }\n  while(qNode) {\n    if (pNodeMap[qNode.val]) {\n      res = qNode\n      console.log(pNodeMap[qNode.val], res)\n      break\n    }\n    qNode = qNode.parent\n  }\n  return res\n}\n```\n","source":"leetcode/二叉树/236.二叉树的最近公共祖先.md","raw":"# 236. 二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n  let res = null\n  if (root === null) return res\n  const nodeQues = []\n  nodeQues.push(root)\n  let pNode = null\n  let qNode = null\n  while(nodeQues.length > 0) {\n    const childNodes = nodeQues.splice(0)\n    const childLen = childNodes.length\n    if (pNode !== null && qNode !== null) break\n    for(let i = 0; i < childLen;i++) {\n      const node = childNodes[i]\n      if (node) {\n        if (node.val === p.val) {\n          pNode = node\n        } else if (node.val === q.val) {\n          qNode = node\n        }\n        if (pNode !== null && qNode !== null) break\n        if (node.left) {\n          node.left.parent = node\n          nodeQues.push(node.left)\n        }\n        if (node.right) {\n          node.right.parent = node\n          nodeQues.push(node.right)\n        }\n      }\n    }\n  }\n  if (pNode === null || qNode === null || pNode.val === qNode.val) {\n    return pNode ? pNode.val : qNode.val\n  }\n  const pNodeMap = {}\n  while(pNode) {\n    pNodeMap[pNode.val] = true\n    pNode = pNode.parent\n  }\n  while(qNode) {\n    if (pNodeMap[qNode.val]) {\n      res = qNode\n      console.log(pNodeMap[qNode.val], res)\n      break\n    }\n    qNode = qNode.parent\n  }\n  return res\n}\n```\n","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.558Z","path":"leetcode/二叉树/236.二叉树的最近公共祖先.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001ttnw7c30dfjep","content":"<h1 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a>236. 二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = this.right = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">p</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">q</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lowestCommonAncestor = <span class=\"keyword\">function</span>(<span class=\"params\">root, p, q</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQues = []</span><br><span class=\"line\">  nodeQues.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pNode = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> qNode = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childNodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childLen = childNodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode !== <span class=\"literal\">null</span> &amp;&amp; qNode !== <span class=\"literal\">null</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childLen;i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = childNodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === p.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          pNode = node</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === q.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          qNode = node</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode !== <span class=\"literal\">null</span> &amp;&amp; qNode !== <span class=\"literal\">null</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pNode === <span class=\"literal\">null</span> || qNode === <span class=\"literal\">null</span> || pNode.<span class=\"property\">val</span> === qNode.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pNode ? pNode.<span class=\"property\">val</span> : qNode.<span class=\"property\">val</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pNodeMap = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(pNode) &#123;</span><br><span class=\"line\">    pNodeMap[pNode.<span class=\"property\">val</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">    pNode = pNode.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(qNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNodeMap[qNode.<span class=\"property\">val</span>]) &#123;</span><br><span class=\"line\">      res = qNode</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pNodeMap[qNode.<span class=\"property\">val</span>], res)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    qNode = qNode.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a>236. 二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree\">链接</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = this.right = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">p</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">q</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">TreeNode</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lowestCommonAncestor = <span class=\"keyword\">function</span>(<span class=\"params\">root, p, q</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQues = []</span><br><span class=\"line\">  nodeQues.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pNode = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> qNode = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childNodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childLen = childNodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode !== <span class=\"literal\">null</span> &amp;&amp; qNode !== <span class=\"literal\">null</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childLen;i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = childNodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === p.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          pNode = node</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === q.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          qNode = node</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode !== <span class=\"literal\">null</span> &amp;&amp; qNode !== <span class=\"literal\">null</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pNode === <span class=\"literal\">null</span> || qNode === <span class=\"literal\">null</span> || pNode.<span class=\"property\">val</span> === qNode.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pNode ? pNode.<span class=\"property\">val</span> : qNode.<span class=\"property\">val</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pNodeMap = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(pNode) &#123;</span><br><span class=\"line\">    pNodeMap[pNode.<span class=\"property\">val</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">    pNode = pNode.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(qNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNodeMap[qNode.<span class=\"property\">val</span>]) &#123;</span><br><span class=\"line\">      res = qNode</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pNodeMap[qNode.<span class=\"property\">val</span>], res)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    qNode = qNode.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 235. 二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree)\n\n```ts\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n  let result = null\n  while(root !== null) {\n    if (root.val > p.val && root.val > q.val) {\n      root = root.left\n    } else if(root.val < p.val && root.val < q.val) {\n      root = root.right\n    } else {\n      result = root\n      break\n    }\n  }\n  return result\n}\n```","source":"leetcode/二叉树/235.二叉搜索树的最近公共祖先.md","raw":"# 235. 二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree)\n\n```ts\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n  let result = null\n  while(root !== null) {\n    if (root.val > p.val && root.val > q.val) {\n      root = root.left\n    } else if(root.val < p.val && root.val < q.val) {\n      root = root.right\n    } else {\n      result = root\n      break\n    }\n  }\n  return result\n}\n```","date":"2023-10-11T15:10:43.206Z","updated":"2023-09-26T14:49:23.557Z","path":"leetcode/二叉树/235.二叉搜索树的最近公共祖先.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxp001utnw7278edhn2","content":"<h1 id=\"235-二叉搜索树的最近公共祖先\"><a href=\"#235-二叉搜索树的最近公共祖先\" class=\"headerlink\" title=\"235. 二叉搜索树的最近公共祖先\"></a>235. 二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lowestCommonAncestor</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, p: TreeNode | <span class=\"literal\">null</span>, q: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &gt; p.<span class=\"property\">val</span> &amp;&amp; root.<span class=\"property\">val</span> &gt; q.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.<span class=\"property\">val</span> &lt; p.<span class=\"property\">val</span> &amp;&amp; root.<span class=\"property\">val</span> &lt; q.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      root = root.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result = root</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"235-二叉搜索树的最近公共祖先\"><a href=\"#235-二叉搜索树的最近公共祖先\" class=\"headerlink\" title=\"235. 二叉搜索树的最近公共祖先\"></a>235. 二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lowestCommonAncestor</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, p: TreeNode | <span class=\"literal\">null</span>, q: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &gt; p.<span class=\"property\">val</span> &amp;&amp; root.<span class=\"property\">val</span> &gt; q.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      root = root.<span class=\"property\">left</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.<span class=\"property\">val</span> &lt; p.<span class=\"property\">val</span> &amp;&amp; root.<span class=\"property\">val</span> &lt; q.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      root = root.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result = root</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"# 257. 二叉树的所有路径\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-paths/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nlet res: string[] = []\n\nfunction binaryTreePaths(root: TreeNode | null): string[] {\n  res = []\n  if (root === null) return res\n  traverse(root, '')\n  return res\n};\n\nfunction traverse(root: TreeNode | null, str: string) {\n  if (root === null) {\n    return\n  }\n  const s = str + `${root.val}->`\n  if (root.left === null && root.right === null) {\n    res.push(s.slice(0, -2))\n    return\n  }\n  traverse(root.left, s)\n  traverse(root.right, s)\n}\n```\n","source":"leetcode/二叉树/257.二叉树的所有路径.md","raw":"# 257. 二叉树的所有路径\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-paths/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nlet res: string[] = []\n\nfunction binaryTreePaths(root: TreeNode | null): string[] {\n  res = []\n  if (root === null) return res\n  traverse(root, '')\n  return res\n};\n\nfunction traverse(root: TreeNode | null, str: string) {\n  if (root === null) {\n    return\n  }\n  const s = str + `${root.val}->`\n  if (root.left === null && root.right === null) {\n    res.push(s.slice(0, -2))\n    return\n  }\n  traverse(root.left, s)\n  traverse(root.right, s)\n}\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.558Z","path":"leetcode/二叉树/257.二叉树的所有路径.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq001vtnw7hqy96pgp","content":"<h1 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a>257. 二叉树的所有路径</h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">binaryTreePaths</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span>[] &#123;</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, str: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> s = str + <span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>-&gt;`</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(s.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, -<span class=\"number\">2</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, s)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a>257. 二叉树的所有路径</h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">binaryTreePaths</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span>[] &#123;</span><br><span class=\"line\">  res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, str: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> s = str + <span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>-&gt;`</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(s.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, -<span class=\"number\">2</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, s)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 297. 二叉树的序列化与反序列化\n\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n[链接](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)\n\n## 前序遍历法\n\n```ts\nfunction serialize(root: TreeNode | null): string {\n  if (root === null) return ''\n  let preorder = []\n  traverse(root, preorder)\n  return preorder.join(',')\n};\n\nfunction traverse(root: TreeNode, preorder: string[]): void {\n  if (root === null) {\n    preorder.push('#')\n    return\n  }\n  preorder.push(`${root.val}`)\n  traverse(root.left, preorder)\n  traverse(root.right, preorder)\n}\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '') return null\n  const preorder = data.split(',')\n  return build(preorder)\n};\n\nfunction build(preorder: string[]) : TreeNode | null {\n  if (preorder.length === 0) {\n    return null\n  }\n  const rootVal = preorder.shift()\n  if (rootVal === '#') return null\n  const root = new TreeNode(Number(rootVal))\n  root.left = build(preorder)\n  root.right = build(preorder)\n  return root\n}\n```\n\n## 后序遍历法\n\n```ts\nfunction serialize(root: TreeNode): string {\n  const serializeList = []\n  sTraverse(root, serializeList)\n  return serializeList.join(',')\n}\n\nfunction sTraverse(root: TreeNode, serializeList: string[]): void {\n  if (root === null) {\n    serializeList.push('#')\n    return\n  }\n  sTraverse(root.left, serializeList)\n  sTraverse(root.right, serializeList)\n  serializeList.push(`${root.val}`)\n}\n\nfunction deserialize(data: string): TreeNode | null {\n  const serializeList = data.split(',')\n  return dTraverse(serializeList)\n}\n\nfunction dTraverse(serializeList: string[]): TreeNode | null {\n  if (serializeList.length === 0) return null\n  const val = serializeList.pop()\n  if (val === '#') return null\n  const root = new TreeNode(Number(val))\n  root.right = dTraverse(serializeList)\n  root.left = dTraverse(serializeList)\n  return root\n}\n```\n\n## 层级遍历法\n\n```ts\nfunction serialize(root: TreeNode): string {\n  if (root === null) return ''\n  const nodeStrList: string[] = []\n  const nodeQueList: TreeNode[] = []\n  nodeQueList.push(root)\n  while(nodeQueList.length > 0) {\n    const cur = nodeQueList.shift()\n    if (cur === null) {\n      nodeStrList.push('#')\n      continue\n    }\n    nodeStrList.push(`${cur.val}`)\n    nodeQueList.push(cur.left)\n    nodeQueList.push(cur.right)\n  }\n  return nodeStrList.join(',')\n}\n\n\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '') return null\n  const nodeStrList = data.split(',')\n  const root = new TreeNode(Number(nodeStrList[0]))\n  const nodeQueList: TreeNode[] = [root]\n  for(let i = 1, len = nodeStrList.length; i < len;) {\n    const parent = nodeQueList.shift()\n    const left = nodeStrList[i++]\n    if (left !== '#') {\n      parent.left = new TreeNode(Number(left))\n      nodeQueList.push(parent.left)\n    } else {\n      parent.left = null\n    }\n    const right = nodeStrList[i++]\n    if (right !== '#') {\n      parent.right = new TreeNode(Number(right))\n      nodeQueList.push(parent.right)\n    } else {\n      parent.right = null\n    }\n  }\n  return root\n}\n```\n","source":"leetcode/二叉树/297.二叉树的序列化与反序列化.md","raw":"# 297. 二叉树的序列化与反序列化\n\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n[链接](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)\n\n## 前序遍历法\n\n```ts\nfunction serialize(root: TreeNode | null): string {\n  if (root === null) return ''\n  let preorder = []\n  traverse(root, preorder)\n  return preorder.join(',')\n};\n\nfunction traverse(root: TreeNode, preorder: string[]): void {\n  if (root === null) {\n    preorder.push('#')\n    return\n  }\n  preorder.push(`${root.val}`)\n  traverse(root.left, preorder)\n  traverse(root.right, preorder)\n}\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '') return null\n  const preorder = data.split(',')\n  return build(preorder)\n};\n\nfunction build(preorder: string[]) : TreeNode | null {\n  if (preorder.length === 0) {\n    return null\n  }\n  const rootVal = preorder.shift()\n  if (rootVal === '#') return null\n  const root = new TreeNode(Number(rootVal))\n  root.left = build(preorder)\n  root.right = build(preorder)\n  return root\n}\n```\n\n## 后序遍历法\n\n```ts\nfunction serialize(root: TreeNode): string {\n  const serializeList = []\n  sTraverse(root, serializeList)\n  return serializeList.join(',')\n}\n\nfunction sTraverse(root: TreeNode, serializeList: string[]): void {\n  if (root === null) {\n    serializeList.push('#')\n    return\n  }\n  sTraverse(root.left, serializeList)\n  sTraverse(root.right, serializeList)\n  serializeList.push(`${root.val}`)\n}\n\nfunction deserialize(data: string): TreeNode | null {\n  const serializeList = data.split(',')\n  return dTraverse(serializeList)\n}\n\nfunction dTraverse(serializeList: string[]): TreeNode | null {\n  if (serializeList.length === 0) return null\n  const val = serializeList.pop()\n  if (val === '#') return null\n  const root = new TreeNode(Number(val))\n  root.right = dTraverse(serializeList)\n  root.left = dTraverse(serializeList)\n  return root\n}\n```\n\n## 层级遍历法\n\n```ts\nfunction serialize(root: TreeNode): string {\n  if (root === null) return ''\n  const nodeStrList: string[] = []\n  const nodeQueList: TreeNode[] = []\n  nodeQueList.push(root)\n  while(nodeQueList.length > 0) {\n    const cur = nodeQueList.shift()\n    if (cur === null) {\n      nodeStrList.push('#')\n      continue\n    }\n    nodeStrList.push(`${cur.val}`)\n    nodeQueList.push(cur.left)\n    nodeQueList.push(cur.right)\n  }\n  return nodeStrList.join(',')\n}\n\n\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '') return null\n  const nodeStrList = data.split(',')\n  const root = new TreeNode(Number(nodeStrList[0]))\n  const nodeQueList: TreeNode[] = [root]\n  for(let i = 1, len = nodeStrList.length; i < len;) {\n    const parent = nodeQueList.shift()\n    const left = nodeStrList[i++]\n    if (left !== '#') {\n      parent.left = new TreeNode(Number(left))\n      nodeQueList.push(parent.left)\n    } else {\n      parent.left = null\n    }\n    const right = nodeStrList[i++]\n    if (right !== '#') {\n      parent.right = new TreeNode(Number(right))\n      nodeQueList.push(parent.right)\n    } else {\n      parent.right = null\n    }\n  }\n  return root\n}\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.558Z","path":"leetcode/二叉树/297.二叉树的序列化与反序列化.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq001wtnw76ndu4yad","content":"<h1 id=\"297-二叉树的序列化与反序列化\"><a href=\"#297-二叉树的序列化与反序列化\" class=\"headerlink\" title=\"297. 二叉树的序列化与反序列化\"></a>297. 二叉树的序列化与反序列化</h1><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n<p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree\">链接</a></p>\n<h2 id=\"前序遍历法\"><a href=\"#前序遍历法\" class=\"headerlink\" title=\"前序遍历法\"></a>前序遍历法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> preorder = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preorder.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, preorder: <span class=\"built_in\">string</span>[]</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    preorder.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  preorder.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, preorder)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, preorder)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Decodes your encoded data to tree.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> preorder = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\">preorder: <span class=\"built_in\">string</span>[]</span>) : <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preorder.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = preorder.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rootVal === <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(rootVal))</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后序遍历法\"><a href=\"#后序遍历法\" class=\"headerlink\" title=\"后序遍历法\"></a>后序遍历法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> serializeList = []</span><br><span class=\"line\">  <span class=\"title function_\">sTraverse</span>(root, serializeList)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> serializeList.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sTraverse</span>(<span class=\"params\">root: TreeNode, serializeList: <span class=\"built_in\">string</span>[]</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    serializeList.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">sTraverse</span>(root.<span class=\"property\">left</span>, serializeList)</span><br><span class=\"line\">  <span class=\"title function_\">sTraverse</span>(root.<span class=\"property\">right</span>, serializeList)</span><br><span class=\"line\">  serializeList.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> serializeList = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dTraverse</span>(serializeList)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dTraverse</span>(<span class=\"params\">serializeList: <span class=\"built_in\">string</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (serializeList.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> val = serializeList.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val === <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(val))</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">dTraverse</span>(serializeList)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">dTraverse</span>(serializeList)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"层级遍历法\"><a href=\"#层级遍历法\" class=\"headerlink\" title=\"层级遍历法\"></a>层级遍历法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeStrList</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQueList</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">  nodeQueList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQueList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = nodeQueList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      nodeStrList.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nodeStrList.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;cur.val&#125;</span>`</span>)</span><br><span class=\"line\">    nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">left</span>)</span><br><span class=\"line\">    nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nodeStrList.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeStrList = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(nodeStrList[<span class=\"number\">0</span>]))</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQueList</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = nodeStrList.<span class=\"property\">length</span>; i &lt; len;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parent = nodeQueList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = nodeStrList[i++]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left !== <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(left))</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = nodeStrList[i++]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right !== <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(right))</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"297-二叉树的序列化与反序列化\"><a href=\"#297-二叉树的序列化与反序列化\" class=\"headerlink\" title=\"297. 二叉树的序列化与反序列化\"></a>297. 二叉树的序列化与反序列化</h1><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n<p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree\">链接</a></p>\n<h2 id=\"前序遍历法\"><a href=\"#前序遍历法\" class=\"headerlink\" title=\"前序遍历法\"></a>前序遍历法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> preorder = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preorder.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, preorder: <span class=\"built_in\">string</span>[]</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    preorder.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  preorder.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, preorder)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, preorder)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Decodes your encoded data to tree.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> preorder = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\">preorder: <span class=\"built_in\">string</span>[]</span>) : <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preorder.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = preorder.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rootVal === <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(rootVal))</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后序遍历法\"><a href=\"#后序遍历法\" class=\"headerlink\" title=\"后序遍历法\"></a>后序遍历法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> serializeList = []</span><br><span class=\"line\">  <span class=\"title function_\">sTraverse</span>(root, serializeList)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> serializeList.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sTraverse</span>(<span class=\"params\">root: TreeNode, serializeList: <span class=\"built_in\">string</span>[]</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    serializeList.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">sTraverse</span>(root.<span class=\"property\">left</span>, serializeList)</span><br><span class=\"line\">  <span class=\"title function_\">sTraverse</span>(root.<span class=\"property\">right</span>, serializeList)</span><br><span class=\"line\">  serializeList.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> serializeList = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dTraverse</span>(serializeList)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dTraverse</span>(<span class=\"params\">serializeList: <span class=\"built_in\">string</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (serializeList.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> val = serializeList.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val === <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(val))</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">dTraverse</span>(serializeList)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">dTraverse</span>(serializeList)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"层级遍历法\"><a href=\"#层级遍历法\" class=\"headerlink\" title=\"层级遍历法\"></a>层级遍历法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeStrList</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQueList</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">  nodeQueList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQueList.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = nodeQueList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      nodeStrList.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nodeStrList.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;cur.val&#125;</span>`</span>)</span><br><span class=\"line\">    nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">left</span>)</span><br><span class=\"line\">    nodeQueList.<span class=\"title function_\">push</span>(cur.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nodeStrList.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeStrList = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(nodeStrList[<span class=\"number\">0</span>]))</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQueList</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, len = nodeStrList.<span class=\"property\">length</span>; i &lt; len;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parent = nodeQueList.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = nodeStrList[i++]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left !== <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(left))</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">left</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = nodeStrList[i++]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right !== <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(right))</span><br><span class=\"line\">      nodeQueList.<span class=\"title function_\">push</span>(parent.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parent.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 331. 验证二叉树的前序序列化\n\n序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n\n[链接](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)\n\n```ts\nfunction isValidSerialization(preorder: string): boolean {\n  const n = preorder.length\n  let i = 0\n  let slots = 1\n  while(i < n) {\n    if (slots === 0) {\n      return false\n    }\n    if (preorder[i] === ',') {\n      ++i\n    } else if (preorder[i] === '#') {\n      --slots\n      ++i\n    } else {\n      // 用while是因为有可能是2位数以上的数字\n      while(i < n && preorder[i] !== ',') {\n        ++i\n      }\n      slots = slots - 1 + 2\n    }\n  }\n  return slots === 0\n};\n```\n","source":"leetcode/二叉树/331.验证二叉树的前序序列化.md","raw":"# 331. 验证二叉树的前序序列化\n\n序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n\n[链接](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)\n\n```ts\nfunction isValidSerialization(preorder: string): boolean {\n  const n = preorder.length\n  let i = 0\n  let slots = 1\n  while(i < n) {\n    if (slots === 0) {\n      return false\n    }\n    if (preorder[i] === ',') {\n      ++i\n    } else if (preorder[i] === '#') {\n      --slots\n      ++i\n    } else {\n      // 用while是因为有可能是2位数以上的数字\n      while(i < n && preorder[i] !== ',') {\n        ++i\n      }\n      slots = slots - 1 + 2\n    }\n  }\n  return slots === 0\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.559Z","path":"leetcode/二叉树/331.验证二叉树的前序序列化.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq001xtnw79k993bqn","content":"<h1 id=\"331-验证二叉树的前序序列化\"><a href=\"#331-验证二叉树的前序序列化\" class=\"headerlink\" title=\"331. 验证二叉树的前序序列化\"></a>331. 验证二叉树的前序序列化</h1><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p>\n<p><a href=\"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isValidSerialization</span>(<span class=\"params\">preorder: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = preorder.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> slots = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slots === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preorder[i] === <span class=\"string\">&#x27;,&#x27;</span>) &#123;</span><br><span class=\"line\">      ++i</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (preorder[i] === <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">      --slots</span><br><span class=\"line\">      ++i</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用while是因为有可能是2位数以上的数字</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i &lt; n &amp;&amp; preorder[i] !== <span class=\"string\">&#x27;,&#x27;</span>) &#123;</span><br><span class=\"line\">        ++i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      slots = slots - <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> slots === <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"331-验证二叉树的前序序列化\"><a href=\"#331-验证二叉树的前序序列化\" class=\"headerlink\" title=\"331. 验证二叉树的前序序列化\"></a>331. 验证二叉树的前序序列化</h1><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p>\n<p><a href=\"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isValidSerialization</span>(<span class=\"params\">preorder: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = preorder.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> slots = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(i &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slots === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (preorder[i] === <span class=\"string\">&#x27;,&#x27;</span>) &#123;</span><br><span class=\"line\">      ++i</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (preorder[i] === <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">      --slots</span><br><span class=\"line\">      ++i</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用while是因为有可能是2位数以上的数字</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i &lt; n &amp;&amp; preorder[i] !== <span class=\"string\">&#x27;,&#x27;</span>) &#123;</span><br><span class=\"line\">        ++i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      slots = slots - <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> slots === <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 337. 打家劫舍 III\n\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n[链接](https://leetcode-cn.com/problems/house-robber-iii)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction rob(root: TreeNode | null): number {\n  let sumMap: Map<TreeNode, number> = new Map()\n  function traverse(node: TreeNode | null): number {\n    if (node === null) return 0\n    if (sumMap.has(node)) return sumMap.get(node)\n    let res1 = 0\n    if (node.left) {\n      res1 += (traverse(node.left.left) + traverse(node.left.right))\n    }\n    if (node.right) {\n      res1 += (traverse(node.right.left) + traverse(node.right.right))\n    }\n    res1 += node.val\n    let res2 = traverse(node.left) + traverse(node.right)\n    sumMap.set(node, Math.max(res1, res2))\n    return sumMap.get(node)\n  }\n  return traverse(root)\n};\n\n```\n","source":"leetcode/二叉树/337.打家劫舍III.md","raw":"# 337. 打家劫舍 III\n\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n[链接](https://leetcode-cn.com/problems/house-robber-iii)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction rob(root: TreeNode | null): number {\n  let sumMap: Map<TreeNode, number> = new Map()\n  function traverse(node: TreeNode | null): number {\n    if (node === null) return 0\n    if (sumMap.has(node)) return sumMap.get(node)\n    let res1 = 0\n    if (node.left) {\n      res1 += (traverse(node.left.left) + traverse(node.left.right))\n    }\n    if (node.right) {\n      res1 += (traverse(node.right.left) + traverse(node.right.right))\n    }\n    res1 += node.val\n    let res2 = traverse(node.left) + traverse(node.right)\n    sumMap.set(node, Math.max(res1, res2))\n    return sumMap.get(node)\n  }\n  return traverse(root)\n};\n\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.559Z","path":"leetcode/二叉树/337.打家劫舍III.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq001ytnw7d6x12oss","content":"<h1 id=\"337-打家劫舍-III\"><a href=\"#337-打家劫舍-III\" class=\"headerlink\" title=\"337. 打家劫舍 III\"></a>337. 打家劫舍 III</h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>\n<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>\n<p><a href=\"https://leetcode-cn.com/problems/house-robber-iii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rob</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">sumMap</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"title class_\">TreeNode</span>, <span class=\"built_in\">number</span>&gt; = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sumMap.<span class=\"title function_\">has</span>(node)) <span class=\"keyword\">return</span> sumMap.<span class=\"title function_\">get</span>(node)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res1 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      res1 += (<span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>.<span class=\"property\">left</span>) + <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>.<span class=\"property\">right</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      res1 += (<span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>.<span class=\"property\">left</span>) + <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>.<span class=\"property\">right</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res1 += node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res2 = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>) + <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    sumMap.<span class=\"title function_\">set</span>(node, <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(res1, res2))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sumMap.<span class=\"title function_\">get</span>(node)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"337-打家劫舍-III\"><a href=\"#337-打家劫舍-III\" class=\"headerlink\" title=\"337. 打家劫舍 III\"></a>337. 打家劫舍 III</h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>\n<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>\n<p><a href=\"https://leetcode-cn.com/problems/house-robber-iii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rob</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">sumMap</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"title class_\">TreeNode</span>, <span class=\"built_in\">number</span>&gt; = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sumMap.<span class=\"title function_\">has</span>(node)) <span class=\"keyword\">return</span> sumMap.<span class=\"title function_\">get</span>(node)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res1 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      res1 += (<span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>.<span class=\"property\">left</span>) + <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>.<span class=\"property\">right</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      res1 += (<span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>.<span class=\"property\">left</span>) + <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>.<span class=\"property\">right</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res1 += node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res2 = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>) + <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    sumMap.<span class=\"title function_\">set</span>(node, <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(res1, res2))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sumMap.<span class=\"title function_\">get</span>(node)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 341. 扁平化嵌套列表迭代器\n\n给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。\n\n列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。\n\n[链接](https://leetcode-cn.com/problems/flatten-nested-list-iterator)\n\n```ts\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     If value is provided, then it holds a single integer\n *     Otherwise it holds an empty nested list\n *     constructor(value?: number) {\n *         ...\n *     };\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     isInteger(): boolean {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     getInteger(): number | null {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     setInteger(value: number) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     add(elem: NestedInteger) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds,\n *     or an empty list if this NestedInteger holds a single integer\n *     getList(): NestedInteger[] {\n *         ...\n *     };\n * };\n */\n\nclass NestedIterator {\n  stack: NestedInteger[]\n  constructor(nestedList: NestedInteger[]) {\n    this.stack = nestedList;\n  }\n\n  hasNext(): boolean {\n    if (this.stack.length > 0) {\n      if (this.stack[0].isInteger()) {\n        return true\n      } else {\n        const cur = this.stack[0].getList()\n        this.stack.shift()\n        this.stack.unshift(...cur)\n        return this.hasNext()\n      }\n    } else {\n      return false\n    }\n  }\n  \n  next(): number {\n    return this.stack.shift().getInteger()\n  }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new NestedIterator(nestedList)\n * var a: number[] = []\n * while (obj.hasNext()) a.push(obj.next());\n */\n```\n","source":"leetcode/二叉树/341.扁平化嵌套列表迭代器.md","raw":"# 341. 扁平化嵌套列表迭代器\n\n给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。\n\n列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。\n\n[链接](https://leetcode-cn.com/problems/flatten-nested-list-iterator)\n\n```ts\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     If value is provided, then it holds a single integer\n *     Otherwise it holds an empty nested list\n *     constructor(value?: number) {\n *         ...\n *     };\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     isInteger(): boolean {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     getInteger(): number | null {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     setInteger(value: number) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     add(elem: NestedInteger) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds,\n *     or an empty list if this NestedInteger holds a single integer\n *     getList(): NestedInteger[] {\n *         ...\n *     };\n * };\n */\n\nclass NestedIterator {\n  stack: NestedInteger[]\n  constructor(nestedList: NestedInteger[]) {\n    this.stack = nestedList;\n  }\n\n  hasNext(): boolean {\n    if (this.stack.length > 0) {\n      if (this.stack[0].isInteger()) {\n        return true\n      } else {\n        const cur = this.stack[0].getList()\n        this.stack.shift()\n        this.stack.unshift(...cur)\n        return this.hasNext()\n      }\n    } else {\n      return false\n    }\n  }\n  \n  next(): number {\n    return this.stack.shift().getInteger()\n  }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new NestedIterator(nestedList)\n * var a: number[] = []\n * while (obj.hasNext()) a.push(obj.next());\n */\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.559Z","path":"leetcode/二叉树/341.扁平化嵌套列表迭代器.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq001ztnw78mooawap","content":"<h1 id=\"341-扁平化嵌套列表迭代器\"><a href=\"#341-扁平化嵌套列表迭代器\" class=\"headerlink\" title=\"341. 扁平化嵌套列表迭代器\"></a>341. 扁平化嵌套列表迭代器</h1><p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>\n<p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // This is the interface that allows for creating nested lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * // You should not implement it, or speculate about its implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * class NestedInteger &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     If value is provided, then it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     Otherwise it holds an empty nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(value?: number) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class=\"line\"><span class=\"comment\"> *     isInteger(): boolean &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return null if this NestedInteger holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     getInteger(): number | null &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Set this NestedInteger to hold a single integer equal to value.</span></span><br><span class=\"line\"><span class=\"comment\"> *     setInteger(value: number) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.</span></span><br><span class=\"line\"><span class=\"comment\"> *     add(elem: NestedInteger) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return the nested list that this NestedInteger holds,</span></span><br><span class=\"line\"><span class=\"comment\"> *     or an empty list if this NestedInteger holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     getList(): NestedInteger[] &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NestedIterator</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">stack</span>: <span class=\"title class_\">NestedInteger</span>[]</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">nestedList: NestedInteger[]</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span> = nestedList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">hasNext</span>(): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>[<span class=\"number\">0</span>].<span class=\"title function_\">isInteger</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> cur = <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>[<span class=\"number\">0</span>].<span class=\"title function_\">getList</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">unshift</span>(...cur)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">hasNext</span>()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">next</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">shift</span>().<span class=\"title function_\">getInteger</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new NestedIterator(nestedList)</span></span><br><span class=\"line\"><span class=\"comment\"> * var a: number[] = []</span></span><br><span class=\"line\"><span class=\"comment\"> * while (obj.hasNext()) a.push(obj.next());</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"341-扁平化嵌套列表迭代器\"><a href=\"#341-扁平化嵌套列表迭代器\" class=\"headerlink\" title=\"341. 扁平化嵌套列表迭代器\"></a>341. 扁平化嵌套列表迭代器</h1><p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>\n<p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>\n<p><a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // This is the interface that allows for creating nested lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * // You should not implement it, or speculate about its implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * class NestedInteger &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     If value is provided, then it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     Otherwise it holds an empty nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(value?: number) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class=\"line\"><span class=\"comment\"> *     isInteger(): boolean &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return null if this NestedInteger holds a nested list</span></span><br><span class=\"line\"><span class=\"comment\"> *     getInteger(): number | null &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Set this NestedInteger to hold a single integer equal to value.</span></span><br><span class=\"line\"><span class=\"comment\"> *     setInteger(value: number) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.</span></span><br><span class=\"line\"><span class=\"comment\"> *     add(elem: NestedInteger) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *     Return the nested list that this NestedInteger holds,</span></span><br><span class=\"line\"><span class=\"comment\"> *     or an empty list if this NestedInteger holds a single integer</span></span><br><span class=\"line\"><span class=\"comment\"> *     getList(): NestedInteger[] &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         ...</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NestedIterator</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">stack</span>: <span class=\"title class_\">NestedInteger</span>[]</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">nestedList: NestedInteger[]</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span> = nestedList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">hasNext</span>(): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>[<span class=\"number\">0</span>].<span class=\"title function_\">isInteger</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> cur = <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>[<span class=\"number\">0</span>].<span class=\"title function_\">getList</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">unshift</span>(...cur)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">hasNext</span>()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">next</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">stack</span>.<span class=\"title function_\">shift</span>().<span class=\"title function_\">getInteger</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new NestedIterator(nestedList)</span></span><br><span class=\"line\"><span class=\"comment\"> * var a: number[] = []</span></span><br><span class=\"line\"><span class=\"comment\"> * while (obj.hasNext()) a.push(obj.next());</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 404. 左叶子之和\n\n计算给定二叉树的所有左叶子之和。\n\n[链接](https://leetcode-cn.com/problems/sum-of-left-leaves/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nlet sum = 0\n\nfunction sumOfLeftLeaves(root: TreeNode | null): number {\n  sum = 0\n  traverse(root)\n  return sum\n};\n\nfunction traverse(root: TreeNode | null) {\n  if (root === null) return\n  const left = root.left\n  if (left !== null && left.left === null && left.right === null) {\n    sum += left.val\n  }\n  traverse(left)\n  traverse(root.right)\n}\n```\n","source":"leetcode/二叉树/404.左叶子之和.md","raw":"# 404. 左叶子之和\n\n计算给定二叉树的所有左叶子之和。\n\n[链接](https://leetcode-cn.com/problems/sum-of-left-leaves/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nlet sum = 0\n\nfunction sumOfLeftLeaves(root: TreeNode | null): number {\n  sum = 0\n  traverse(root)\n  return sum\n};\n\nfunction traverse(root: TreeNode | null) {\n  if (root === null) return\n  const left = root.left\n  if (left !== null && left.left === null && left.right === null) {\n    sum += left.val\n  }\n  traverse(left)\n  traverse(root.right)\n}\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.559Z","path":"leetcode/二叉树/404.左叶子之和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0020tnw72hxicyuz","content":"<h1 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404. 左叶子之和\"></a>404. 左叶子之和</h1><p>计算给定二叉树的所有左叶子之和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumOfLeftLeaves</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = root.<span class=\"property\">left</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left !== <span class=\"literal\">null</span> &amp;&amp; left.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; left.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    sum += left.<span class=\"property\">val</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(left)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404. 左叶子之和\"></a>404. 左叶子之和</h1><p>计算给定二叉树的所有左叶子之和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumOfLeftLeaves</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = root.<span class=\"property\">left</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left !== <span class=\"literal\">null</span> &amp;&amp; left.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; left.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    sum += left.<span class=\"property\">val</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(left)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 437. 路径总和 III\n\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n[链接](https://leetcode-cn.com/problems/path-sum-iii)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pathSum(root: TreeNode | null, targetSum: number): number {\n  \n  const pathMap: Map<number, number> = new Map()\n  pathMap.set(0, 1)\n  return traverse(root, pathMap, targetSum, 0)\n};\n\nfunction traverse(node: TreeNode, pathMap: Map<number, number>, target: number, curr: number): number {\n    if (node === null) return 0\n    let res = 0\n    curr += node.val\n    res += pathMap.get(curr - target) || 0\n    pathMap.set(curr, (pathMap.get(curr) || 0) + 1)\n    res += traverse(node.left, pathMap, target, curr)\n    res += traverse(node.right, pathMap, target, curr)\n    pathMap.set(curr, pathMap.get(curr) - 1)\n    return res\n  }\n```\n","source":"leetcode/二叉树/437.路径总和III.md","raw":"# 437. 路径总和 III\n\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n[链接](https://leetcode-cn.com/problems/path-sum-iii)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pathSum(root: TreeNode | null, targetSum: number): number {\n  \n  const pathMap: Map<number, number> = new Map()\n  pathMap.set(0, 1)\n  return traverse(root, pathMap, targetSum, 0)\n};\n\nfunction traverse(node: TreeNode, pathMap: Map<number, number>, target: number, curr: number): number {\n    if (node === null) return 0\n    let res = 0\n    curr += node.val\n    res += pathMap.get(curr - target) || 0\n    pathMap.set(curr, (pathMap.get(curr) || 0) + 1)\n    res += traverse(node.left, pathMap, target, curr)\n    res += traverse(node.right, pathMap, target, curr)\n    pathMap.set(curr, pathMap.get(curr) - 1)\n    return res\n  }\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.560Z","path":"leetcode/二叉树/437.路径总和III.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0021tnw77jvxbow9","content":"<h1 id=\"437-路径总和-III\"><a href=\"#437-路径总和-III\" class=\"headerlink\" title=\"437. 路径总和 III\"></a>437. 路径总和 III</h1><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>\n<p>找出路径和等于给定数值的路径总数。</p>\n<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, targetSum: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">pathMap</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  pathMap.<span class=\"title function_\">set</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root, pathMap, targetSum, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode, pathMap: <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt;, target: <span class=\"built_in\">number</span>, curr: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">    curr += node.<span class=\"property\">val</span></span><br><span class=\"line\">    res += pathMap.<span class=\"title function_\">get</span>(curr - target) || <span class=\"number\">0</span></span><br><span class=\"line\">    pathMap.<span class=\"title function_\">set</span>(curr, (pathMap.<span class=\"title function_\">get</span>(curr) || <span class=\"number\">0</span>) + <span class=\"number\">1</span>)</span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>, pathMap, target, curr)</span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>, pathMap, target, curr)</span><br><span class=\"line\">    pathMap.<span class=\"title function_\">set</span>(curr, pathMap.<span class=\"title function_\">get</span>(curr) - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"437-路径总和-III\"><a href=\"#437-路径总和-III\" class=\"headerlink\" title=\"437. 路径总和 III\"></a>437. 路径总和 III</h1><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>\n<p>找出路径和等于给定数值的路径总数。</p>\n<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pathSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, targetSum: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">pathMap</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  pathMap.<span class=\"title function_\">set</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root, pathMap, targetSum, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode, pathMap: <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt;, target: <span class=\"built_in\">number</span>, curr: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">    curr += node.<span class=\"property\">val</span></span><br><span class=\"line\">    res += pathMap.<span class=\"title function_\">get</span>(curr - target) || <span class=\"number\">0</span></span><br><span class=\"line\">    pathMap.<span class=\"title function_\">set</span>(curr, (pathMap.<span class=\"title function_\">get</span>(curr) || <span class=\"number\">0</span>) + <span class=\"number\">1</span>)</span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>, pathMap, target, curr)</span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>, pathMap, target, curr)</span><br><span class=\"line\">    pathMap.<span class=\"title function_\">set</span>(curr, pathMap.<span class=\"title function_\">get</span>(curr) - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 429. N 叉树的层序遍历\n\n给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\n\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n\n[链接](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)\n\n```ts\n/**\n * Definition for node.\n * class Node {\n *     val: number\n *     children: Node[]\n *     constructor(val?: number) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.children = []\n *     }\n * }\n */\n\nfunction levelOrder(root: Node | null): number[][] {\n  const res: number[][] = []\n  if (root === null) return res\n  const nodeQues: Node[] = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    const levelRes = []\n    for(let i = 0;i < len; i++) {\n      const node = nodes[i]\n      if (node) {\n        const { val, children } = node\n        levelRes.push(val)\n        const clen = children.length\n        for(let j = 0; j < clen; j++) {\n          const node = children[j]\n          node && nodeQues.push(node)\n        }\n      }\n    }\n    levelRes.length > 0 && res.push(levelRes)\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/429.N叉树的层序遍历.md","raw":"# 429. N 叉树的层序遍历\n\n给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\n\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n\n[链接](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)\n\n```ts\n/**\n * Definition for node.\n * class Node {\n *     val: number\n *     children: Node[]\n *     constructor(val?: number) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.children = []\n *     }\n * }\n */\n\nfunction levelOrder(root: Node | null): number[][] {\n  const res: number[][] = []\n  if (root === null) return res\n  const nodeQues: Node[] = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    const levelRes = []\n    for(let i = 0;i < len; i++) {\n      const node = nodes[i]\n      if (node) {\n        const { val, children } = node\n        levelRes.push(val)\n        const clen = children.length\n        for(let j = 0; j < clen; j++) {\n          const node = children[j]\n          node && nodeQues.push(node)\n        }\n      }\n    }\n    levelRes.length > 0 && res.push(levelRes)\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.560Z","path":"leetcode/二叉树/429.N叉树的层序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0022tnw7hzboblx1","content":"<h1 id=\"429-N-叉树的层序遍历\"><a href=\"#429-N-叉树的层序遍历\" class=\"headerlink\" title=\"429. N 叉树的层序遍历\"></a>429. N 叉树的层序遍历</h1><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p>\n<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     children: Node[]</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.children = []</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">levelOrder</span>(<span class=\"params\">root: Node | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[][] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">Node</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> levelRes = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; val, children &#125; = node</span><br><span class=\"line\">        levelRes.<span class=\"title function_\">push</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> clen = children.<span class=\"property\">length</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; clen; j++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> node = children[j]</span><br><span class=\"line\">          node &amp;&amp; nodeQues.<span class=\"title function_\">push</span>(node)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    levelRes.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">push</span>(levelRes)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"429-N-叉树的层序遍历\"><a href=\"#429-N-叉树的层序遍历\" class=\"headerlink\" title=\"429. N 叉树的层序遍历\"></a>429. N 叉树的层序遍历</h1><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p>\n<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     children: Node[]</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.children = []</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">levelOrder</span>(<span class=\"params\">root: Node | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[][] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">Node</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> levelRes = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; val, children &#125; = node</span><br><span class=\"line\">        levelRes.<span class=\"title function_\">push</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> clen = children.<span class=\"property\">length</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; clen; j++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> node = children[j]</span><br><span class=\"line\">          node &amp;&amp; nodeQues.<span class=\"title function_\">push</span>(node)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    levelRes.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; res.<span class=\"title function_\">push</span>(levelRes)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 449. 序列化和反序列化二叉搜索树\n\n序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。\n\n设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。\n\n编码的字符串应尽可能紧凑。\n\n[链接](https://leetcode-cn.com/problems/serialize-and-deserialize-bst)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction traverse(root: TreeNode, preorder: string[]) {\n  if (root === null) {\n    preorder.push('#')\n    return\n  }\n  preorder.push(`${root.val}`)\n  traverse(root.left, preorder)\n  traverse(root.right, preorder)\n}\n\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n  if (root === null) return ''\n  const preorder = []\n  traverse(root, preorder)\n  return preorder.join(',')\n};\n\nfunction build(preorder: string[]): TreeNode | null {\n  if (preorder.length === 0) return null\n  const rootVal = preorder.shift()\n  if (rootVal === '#') return null\n  const root = new TreeNode(Number(rootVal))\n  root.left = build(preorder)\n  root.right = build(preorder)\n  return root\n}\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '') return null\n  const preorder = data.split(',')\n  return build(preorder)\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n","source":"leetcode/二叉树/449.序列化和反序列化二叉搜索树.md","raw":"# 449. 序列化和反序列化二叉搜索树\n\n序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。\n\n设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。\n\n编码的字符串应尽可能紧凑。\n\n[链接](https://leetcode-cn.com/problems/serialize-and-deserialize-bst)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction traverse(root: TreeNode, preorder: string[]) {\n  if (root === null) {\n    preorder.push('#')\n    return\n  }\n  preorder.push(`${root.val}`)\n  traverse(root.left, preorder)\n  traverse(root.right, preorder)\n}\n\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n  if (root === null) return ''\n  const preorder = []\n  traverse(root, preorder)\n  return preorder.join(',')\n};\n\nfunction build(preorder: string[]): TreeNode | null {\n  if (preorder.length === 0) return null\n  const rootVal = preorder.shift()\n  if (rootVal === '#') return null\n  const root = new TreeNode(Number(rootVal))\n  root.left = build(preorder)\n  root.right = build(preorder)\n  return root\n}\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '') return null\n  const preorder = data.split(',')\n  return build(preorder)\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.560Z","path":"leetcode/二叉树/449.序列化和反序列化二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0023tnw706fx8rg4","content":"<h1 id=\"449-序列化和反序列化二叉搜索树\"><a href=\"#449-序列化和反序列化二叉搜索树\" class=\"headerlink\" title=\"449. 序列化和反序列化二叉搜索树\"></a>449. 序列化和反序列化二叉搜索树</h1><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>\n<p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>\n<p>编码的字符串应尽可能紧凑。</p>\n<p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-bst\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, preorder: <span class=\"built_in\">string</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    preorder.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  preorder.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, preorder)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, preorder)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Encodes a tree to a single string.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> preorder = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preorder.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\">preorder: <span class=\"built_in\">string</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preorder.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = preorder.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rootVal === <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(rootVal))</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Decodes your encoded data to tree.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> preorder = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your functions will be called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * deserialize(serialize(root));</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"449-序列化和反序列化二叉搜索树\"><a href=\"#449-序列化和反序列化二叉搜索树\" class=\"headerlink\" title=\"449. 序列化和反序列化二叉搜索树\"></a>449. 序列化和反序列化二叉搜索树</h1><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>\n<p>设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>\n<p>编码的字符串应尽可能紧凑。</p>\n<p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-bst\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode, preorder: <span class=\"built_in\">string</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    preorder.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  preorder.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, preorder)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, preorder)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Encodes a tree to a single string.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">serialize</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> preorder = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preorder.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">build</span>(<span class=\"params\">preorder: <span class=\"built_in\">string</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (preorder.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rootVal = preorder.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rootVal === <span class=\"string\">&#x27;#&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"title class_\">Number</span>(rootVal))</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Decodes your encoded data to tree.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deserialize</span>(<span class=\"params\">data: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> preorder = data.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">build</span>(preorder)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your functions will be called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * deserialize(serialize(root));</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 450. 删除二叉搜索树中的节点\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n首先找到需要删除的节点；\n如果找到了，删除它。\n说明： 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n[链接](https://leetcode-cn.com/problems/delete-node-in-a-bst)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n  if (root === null) return null;\n  if (key > root.val) root.right = deleteNode(root.right, key);\n  else if (key < root.val) root.left = deleteNode(root.left, key)\n  else if (root.left !== null && root.right !== null) {\n    // 通过右子树的右子树来替换\n    if (root.right.left === null) {\n      root.val = root.right.val\n      root.right = root.right.right\n    } else {\n      // 找出右子树最小的值（即最左子树），用它来替换此时的节点，并把最小值的右子树接到最小值的父节点上\n      let min = root.right\n      let minParent = root\n      while(min.left !== null) {\n        minParent = min\n        min = min.left\n      }\n      root.val = min.val\n      minParent.left = min.right\n    }\n  } else {\n    root = root.left ? root.left : root.right\n  }\n  return root\n};\n```\n","source":"leetcode/二叉树/450.删除二叉搜索树中的节点.md","raw":"# 450. 删除二叉搜索树中的节点\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n首先找到需要删除的节点；\n如果找到了，删除它。\n说明： 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n[链接](https://leetcode-cn.com/problems/delete-node-in-a-bst)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n  if (root === null) return null;\n  if (key > root.val) root.right = deleteNode(root.right, key);\n  else if (key < root.val) root.left = deleteNode(root.left, key)\n  else if (root.left !== null && root.right !== null) {\n    // 通过右子树的右子树来替换\n    if (root.right.left === null) {\n      root.val = root.right.val\n      root.right = root.right.right\n    } else {\n      // 找出右子树最小的值（即最左子树），用它来替换此时的节点，并把最小值的右子树接到最小值的父节点上\n      let min = root.right\n      let minParent = root\n      while(min.left !== null) {\n        minParent = min\n        min = min.left\n      }\n      root.val = min.val\n      minParent.left = min.right\n    }\n  } else {\n    root = root.left ? root.left : root.right\n  }\n  return root\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.560Z","path":"leetcode/二叉树/450.删除二叉搜索树中的节点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0024tnw7368q7rne","content":"<h1 id=\"450-删除二叉搜索树中的节点\"><a href=\"#450-删除二叉搜索树中的节点\" class=\"headerlink\" title=\"450. 删除二叉搜索树中的节点\"></a>450. 删除二叉搜索树中的节点</h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p>一般来说，删除节点可分为两个步骤：</p>\n<p>首先找到需要删除的节点；<br>如果找到了，删除它。<br>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>\n<p><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-bst\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deleteNode</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, key: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (key &gt; root.<span class=\"property\">val</span>) root.<span class=\"property\">right</span> = <span class=\"title function_\">deleteNode</span>(root.<span class=\"property\">right</span>, key);</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; root.<span class=\"property\">val</span>) root.<span class=\"property\">left</span> = <span class=\"title function_\">deleteNode</span>(root.<span class=\"property\">left</span>, key)</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> !== <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过右子树的右子树来替换</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span>.<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      root.<span class=\"property\">val</span> = root.<span class=\"property\">right</span>.<span class=\"property\">val</span></span><br><span class=\"line\">      root.<span class=\"property\">right</span> = root.<span class=\"property\">right</span>.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找出右子树最小的值（即最左子树），用它来替换此时的节点，并把最小值的右子树接到最小值的父节点上</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> min = root.<span class=\"property\">right</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> minParent = root</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(min.<span class=\"property\">left</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        minParent = min</span><br><span class=\"line\">        min = min.<span class=\"property\">left</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      root.<span class=\"property\">val</span> = min.<span class=\"property\">val</span></span><br><span class=\"line\">      minParent.<span class=\"property\">left</span> = min.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    root = root.<span class=\"property\">left</span> ? root.<span class=\"property\">left</span> : root.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"450-删除二叉搜索树中的节点\"><a href=\"#450-删除二叉搜索树中的节点\" class=\"headerlink\" title=\"450. 删除二叉搜索树中的节点\"></a>450. 删除二叉搜索树中的节点</h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p>一般来说，删除节点可分为两个步骤：</p>\n<p>首先找到需要删除的节点；<br>如果找到了，删除它。<br>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>\n<p><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-bst\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deleteNode</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, key: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (key &gt; root.<span class=\"property\">val</span>) root.<span class=\"property\">right</span> = <span class=\"title function_\">deleteNode</span>(root.<span class=\"property\">right</span>, key);</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; root.<span class=\"property\">val</span>) root.<span class=\"property\">left</span> = <span class=\"title function_\">deleteNode</span>(root.<span class=\"property\">left</span>, key)</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> !== <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过右子树的右子树来替换</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span>.<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      root.<span class=\"property\">val</span> = root.<span class=\"property\">right</span>.<span class=\"property\">val</span></span><br><span class=\"line\">      root.<span class=\"property\">right</span> = root.<span class=\"property\">right</span>.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找出右子树最小的值（即最左子树），用它来替换此时的节点，并把最小值的右子树接到最小值的父节点上</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> min = root.<span class=\"property\">right</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> minParent = root</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(min.<span class=\"property\">left</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        minParent = min</span><br><span class=\"line\">        min = min.<span class=\"property\">left</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      root.<span class=\"property\">val</span> = min.<span class=\"property\">val</span></span><br><span class=\"line\">      minParent.<span class=\"property\">left</span> = min.<span class=\"property\">right</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    root = root.<span class=\"property\">left</span> ? root.<span class=\"property\">left</span> : root.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 501. 二叉搜索树中的众数\n\n给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。\n\n假定 BST 有如下定义：\n\n- 结点左子树中所含结点的值小于等于当前结点的值\n- 结点右子树中所含结点的值大于等于当前结点的值\n- 左子树和右子树都是二叉搜索树\n\n[链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findMode(root: TreeNode | null): number[] {\n  let res: number[] = []\n  let sum = 1\n  let pre = null\n  let maxSum = sum\n  function traverse(root: TreeNode | null) {\n    if (root === null) return\n    traverse(root.left)\n    if (pre === root.val) {\n      sum += 1\n    } else {\n      pre = root.val\n      sum = 1\n    }\n    if (maxSum < sum) {\n      res = []\n      res.push(root.val)\n      maxSum = sum\n    } else if (maxSum === sum) {\n      res.push(root.val)\n    }\n    traverse(root.right)\n  }\n  traverse(root)\n  return res\n};\n\n```\n","source":"leetcode/二叉树/501.二叉搜索树中的众数.md","raw":"# 501. 二叉搜索树中的众数\n\n给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。\n\n假定 BST 有如下定义：\n\n- 结点左子树中所含结点的值小于等于当前结点的值\n- 结点右子树中所含结点的值大于等于当前结点的值\n- 左子树和右子树都是二叉搜索树\n\n[链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findMode(root: TreeNode | null): number[] {\n  let res: number[] = []\n  let sum = 1\n  let pre = null\n  let maxSum = sum\n  function traverse(root: TreeNode | null) {\n    if (root === null) return\n    traverse(root.left)\n    if (pre === root.val) {\n      sum += 1\n    } else {\n      pre = root.val\n      sum = 1\n    }\n    if (maxSum < sum) {\n      res = []\n      res.push(root.val)\n      maxSum = sum\n    } else if (maxSum === sum) {\n      res.push(root.val)\n    }\n    traverse(root.right)\n  }\n  traverse(root)\n  return res\n};\n\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.561Z","path":"leetcode/二叉树/501.二叉搜索树中的众数.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0025tnw7goxhgtu4","content":"<h1 id=\"501-二叉搜索树中的众数\"><a href=\"#501-二叉搜索树中的众数\" class=\"headerlink\" title=\"501. 二叉搜索树中的众数\"></a>501. 二叉搜索树中的众数</h1><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>\n<p>假定 BST 有如下定义：</p>\n<ul>\n<li>结点左子树中所含结点的值小于等于当前结点的值</li>\n<li>结点右子树中所含结点的值大于等于当前结点的值</li>\n<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/find-mode-in-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMode</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxSum = sum</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre === root.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      sum += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pre = root.<span class=\"property\">val</span></span><br><span class=\"line\">      sum = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxSum &lt; sum) &#123;</span><br><span class=\"line\">      res = []</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">      maxSum = sum</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (maxSum === sum) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"501-二叉搜索树中的众数\"><a href=\"#501-二叉搜索树中的众数\" class=\"headerlink\" title=\"501. 二叉搜索树中的众数\"></a>501. 二叉搜索树中的众数</h1><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>\n<p>假定 BST 有如下定义：</p>\n<ul>\n<li>结点左子树中所含结点的值小于等于当前结点的值</li>\n<li>结点右子树中所含结点的值大于等于当前结点的值</li>\n<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/find-mode-in-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMode</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxSum = sum</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre === root.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      sum += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pre = root.<span class=\"property\">val</span></span><br><span class=\"line\">      sum = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxSum &lt; sum) &#123;</span><br><span class=\"line\">      res = []</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">      maxSum = sum</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (maxSum === sum) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 508. 出现次数最多的子树元素和\n\n给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。\n\n你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。\n\n[链接](https://leetcode-cn.com/problems/most-frequent-subtree-sum)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\n\nfunction findFrequentTreeSum(root: TreeNode | null): number[] {\n  const dataMap: Map<number, number> = new Map()\n  let max = 1\n  function traverse(node: TreeNode | null): number {\n    if (node === null) return 0\n    let res = node.val\n    res += traverse(node.left)\n    res += traverse(node.right)\n    let resNum = (dataMap.get(res) || 0) + 1\n    dataMap.set(res, resNum)\n    max = Math.max(max, resNum)\n    return res\n  }\n  traverse(root)\n  const resList = []\n  for (const [key, value] of dataMap) {\n    if (value === max) {\n      resList.push(key)\n    }\n  }\n  return resList\n};\n```\n","source":"leetcode/二叉树/508.出现次数最多的子树元素和.md","raw":"# 508. 出现次数最多的子树元素和\n\n给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。\n\n你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。\n\n[链接](https://leetcode-cn.com/problems/most-frequent-subtree-sum)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\n\nfunction findFrequentTreeSum(root: TreeNode | null): number[] {\n  const dataMap: Map<number, number> = new Map()\n  let max = 1\n  function traverse(node: TreeNode | null): number {\n    if (node === null) return 0\n    let res = node.val\n    res += traverse(node.left)\n    res += traverse(node.right)\n    let resNum = (dataMap.get(res) || 0) + 1\n    dataMap.set(res, resNum)\n    max = Math.max(max, resNum)\n    return res\n  }\n  traverse(root)\n  const resList = []\n  for (const [key, value] of dataMap) {\n    if (value === max) {\n      resList.push(key)\n    }\n  }\n  return resList\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.561Z","path":"leetcode/二叉树/508.出现次数最多的子树元素和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0026tnw7fuqeabn6","content":"<h1 id=\"508-出现次数最多的子树元素和\"><a href=\"#508-出现次数最多的子树元素和\" class=\"headerlink\" title=\"508. 出现次数最多的子树元素和\"></a>508. 出现次数最多的子树元素和</h1><p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\n<p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/most-frequent-subtree-sum\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findFrequentTreeSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dataMap</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = node.<span class=\"property\">val</span></span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> resNum = (dataMap.<span class=\"title function_\">get</span>(res) || <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    dataMap.<span class=\"title function_\">set</span>(res, resNum)</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, resNum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> resList = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [key, value] <span class=\"keyword\">of</span> dataMap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === max) &#123;</span><br><span class=\"line\">      resList.<span class=\"title function_\">push</span>(key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resList</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"508-出现次数最多的子树元素和\"><a href=\"#508-出现次数最多的子树元素和\" class=\"headerlink\" title=\"508. 出现次数最多的子树元素和\"></a>508. 出现次数最多的子树元素和</h1><p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\n<p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/most-frequent-subtree-sum\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findFrequentTreeSum</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dataMap</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>&gt; = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = node.<span class=\"property\">val</span></span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    res += <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> resNum = (dataMap.<span class=\"title function_\">get</span>(res) || <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">    dataMap.<span class=\"title function_\">set</span>(res, resNum)</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, resNum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> resList = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [key, value] <span class=\"keyword\">of</span> dataMap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === max) &#123;</span><br><span class=\"line\">      resList.<span class=\"title function_\">push</span>(key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resList</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 513. 找树左下角的值\n\n给定一个二叉树，在树的最后一行找到最左边的值。\n\n[链接](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findBottomLeftValue(root: TreeNode | null): number {\n  const nodeQues: TreeNode[] = [root]\n  let res = 0\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node) {\n        if (node.left) {\n          nodeQues.push(node.left)\n        }\n        if (node.right) {\n          nodeQues.push(node.right)\n        }\n      }\n    }\n    if (nodeQues.length === 0) {\n      res = nodes[0].val\n    }\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/513.找树左下角的值.md","raw":"# 513. 找树左下角的值\n\n给定一个二叉树，在树的最后一行找到最左边的值。\n\n[链接](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findBottomLeftValue(root: TreeNode | null): number {\n  const nodeQues: TreeNode[] = [root]\n  let res = 0\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node) {\n        if (node.left) {\n          nodeQues.push(node.left)\n        }\n        if (node.right) {\n          nodeQues.push(node.right)\n        }\n      }\n    }\n    if (nodeQues.length === 0) {\n      res = nodes[0].val\n    }\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.561Z","path":"leetcode/二叉树/513.找树左下角的值.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0027tnw748og0gw4","content":"<h1 id=\"513-找树左下角的值\"><a href=\"#513-找树左下角的值\" class=\"headerlink\" title=\"513. 找树左下角的值\"></a>513. 找树左下角的值</h1><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findBottomLeftValue</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeQues.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res = nodes[<span class=\"number\">0</span>].<span class=\"property\">val</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"513-找树左下角的值\"><a href=\"#513-找树左下角的值\" class=\"headerlink\" title=\"513. 找树左下角的值\"></a>513. 找树左下角的值</h1><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findBottomLeftValue</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nodeQues.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res = nodes[<span class=\"number\">0</span>].<span class=\"property\">val</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 515. 在每个树行中找最大值\n\n您需要在二叉树的每一行中找到最大的值。\n\n[链接](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction largestValues(root: TreeNode | null): number[] {\n  let res: number[] = []\n  if (root === null) return res\n  const nodeQues: TreeNode[] = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    let max = -Infinity\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      max = Math.max(max, node.val)\n      if (node.left) {\n        nodeQues.push(node.left)\n      }\n      if (node.right) {\n        nodeQues.push(node.right)\n      }\n    }\n    res.push(max)\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/515.在每个树行中找最大值.md","raw":"# 515. 在每个树行中找最大值\n\n您需要在二叉树的每一行中找到最大的值。\n\n[链接](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction largestValues(root: TreeNode | null): number[] {\n  let res: number[] = []\n  if (root === null) return res\n  const nodeQues: TreeNode[] = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    let max = -Infinity\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      max = Math.max(max, node.val)\n      if (node.left) {\n        nodeQues.push(node.left)\n      }\n      if (node.right) {\n        nodeQues.push(node.right)\n      }\n    }\n    res.push(max)\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.561Z","path":"leetcode/二叉树/515.在每个树行中找最大值.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0028tnw7f2ji2ruj","content":"<h1 id=\"515-在每个树行中找最大值\"><a href=\"#515-在每个树行中找最大值\" class=\"headerlink\" title=\"515. 在每个树行中找最大值\"></a>515. 在每个树行中找最大值</h1><p>您需要在二叉树的每一行中找到最大的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">largestValues</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> max = -<span class=\"title class_\">Infinity</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, node.<span class=\"property\">val</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">        nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">        nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(max)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"515-在每个树行中找最大值\"><a href=\"#515-在每个树行中找最大值\" class=\"headerlink\" title=\"515. 在每个树行中找最大值\"></a>515. 在每个树行中找最大值</h1><p>您需要在二叉树的每一行中找到最大的值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">largestValues</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> max = -<span class=\"title class_\">Infinity</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, node.<span class=\"property\">val</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">        nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">        nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(max)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 530. 二叉搜索树的最小绝对差\n\n给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\nfunction getMinimumDifference(root: TreeNode | null): number {\n  let min = Infinity\n  let pre = -1\n  function findDistanceMin(node: TreeNode) {\n    if (node === null) return\n    findDistanceMin(node.left)\n    if (pre !== -1) {\n      const dis = node.val - pre\n      min = Math.min(dis, min)\n    }\n    pre = node.val\n    findDistanceMin(node.right)\n  }\n  findDistanceMin(root)\n  return min\n};\n```\n","source":"leetcode/二叉树/530.二叉搜索树的最小绝对差.md","raw":"# 530. 二叉搜索树的最小绝对差\n\n给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\nfunction getMinimumDifference(root: TreeNode | null): number {\n  let min = Infinity\n  let pre = -1\n  function findDistanceMin(node: TreeNode) {\n    if (node === null) return\n    findDistanceMin(node.left)\n    if (pre !== -1) {\n      const dis = node.val - pre\n      min = Math.min(dis, min)\n    }\n    pre = node.val\n    findDistanceMin(node.right)\n  }\n  findDistanceMin(root)\n  return min\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.562Z","path":"leetcode/二叉树/530.二叉搜索树的最小绝对差.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxq0029tnw7h3akau6a","content":"<h1 id=\"530-二叉搜索树的最小绝对差\"><a href=\"#530-二叉搜索树的最小绝对差\" class=\"headerlink\" title=\"530. 二叉搜索树的最小绝对差\"></a>530. 二叉搜索树的最小绝对差</h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getMinimumDifference</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = <span class=\"title class_\">Infinity</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = -<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">findDistanceMin</span>(<span class=\"params\">node: TreeNode</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">findDistanceMin</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> dis = node.<span class=\"property\">val</span> - pre</span><br><span class=\"line\">      min = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dis, min)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"title function_\">findDistanceMin</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findDistanceMin</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"530-二叉搜索树的最小绝对差\"><a href=\"#530-二叉搜索树的最小绝对差\" class=\"headerlink\" title=\"530. 二叉搜索树的最小绝对差\"></a>530. 二叉搜索树的最小绝对差</h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getMinimumDifference</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> min = <span class=\"title class_\">Infinity</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = -<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">findDistanceMin</span>(<span class=\"params\">node: TreeNode</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">findDistanceMin</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> dis = node.<span class=\"property\">val</span> - pre</span><br><span class=\"line\">      min = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(dis, min)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"title function_\">findDistanceMin</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">findDistanceMin</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 559. N 叉树的最大深度\n\n给定一个 N 叉树，找到其最大深度。\n\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\nN 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n\n[链接](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree)\n\n```ts\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node|null} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  let depth = 0\n  if (root === null) return depth\n  const nodeQues = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const nodeLen = nodes.length\n    depth++\n    for(let i = 0; i < nodeLen; i++) {\n      const node = nodes[i]\n      const { children = [] } = node\n      nodeQues.push(...children.filter(data => data !== null))\n    }\n  }\n  return depth\n};\n```\n","source":"leetcode/二叉树/559.N叉树的最大深度.md","raw":"# 559. N 叉树的最大深度\n\n给定一个 N 叉树，找到其最大深度。\n\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\nN 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n\n[链接](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree)\n\n```ts\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node|null} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  let depth = 0\n  if (root === null) return depth\n  const nodeQues = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const nodeLen = nodes.length\n    depth++\n    for(let i = 0; i < nodeLen; i++) {\n      const node = nodes[i]\n      const { children = [] } = node\n      nodeQues.push(...children.filter(data => data !== null))\n    }\n  }\n  return depth\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.562Z","path":"leetcode/二叉树/559.N叉树的最大深度.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002atnw76ody0pu1","content":"<h1 id=\"559-N-叉树的最大深度\"><a href=\"#559-N-叉树的最大深度\" class=\"headerlink\" title=\"559. N 叉树的最大深度\"></a>559. N 叉树的最大深度</h1><p>给定一个 N 叉树，找到其最大深度。</p>\n<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function Node(val,children) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.children = children;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">Node|null</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxDepth = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> depth</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQues = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodeLen = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nodeLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; children = [] &#125; = node</span><br><span class=\"line\">      nodeQues.<span class=\"title function_\">push</span>(...children.<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> data !== <span class=\"literal\">null</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> depth</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"559-N-叉树的最大深度\"><a href=\"#559-N-叉树的最大深度\" class=\"headerlink\" title=\"559. N 叉树的最大深度\"></a>559. N 叉树的最大深度</h1><p>给定一个 N 叉树，找到其最大深度。</p>\n<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function Node(val,children) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.children = children;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">Node|null</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxDepth = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> depth</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQues = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodeLen = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nodeLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; children = [] &#125; = node</span><br><span class=\"line\">      nodeQues.<span class=\"title function_\">push</span>(...children.<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> data !== <span class=\"literal\">null</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> depth</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 543. 二叉树的直径\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\nfunction diameterOfBinaryTree(root: TreeNode | null): number {\n  if (root === null) return 0\n  let ans = 1\n  function traverse(node: TreeNode | null) {\n    if (node === null) return 0\n    const l = traverse(node.left)\n    const r = traverse(node.right)\n    const path = l + r + 1\n    ans = Math.max(path, ans)\n    return Math.max(l, r) + 1\n  }\n  traverse(root)\n  return ans - 1\n};\n```\n","source":"leetcode/二叉树/543.二叉树的直径.md","raw":"# 543. 二叉树的直径\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\nfunction diameterOfBinaryTree(root: TreeNode | null): number {\n  if (root === null) return 0\n  let ans = 1\n  function traverse(node: TreeNode | null) {\n    if (node === null) return 0\n    const l = traverse(node.left)\n    const r = traverse(node.right)\n    const path = l + r + 1\n    ans = Math.max(path, ans)\n    return Math.max(l, r) + 1\n  }\n  traverse(root)\n  return ans - 1\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.562Z","path":"leetcode/二叉树/543.二叉树的直径.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002btnw7grpe7h0l","content":"<h1 id=\"543-二叉树的直径\"><a href=\"#543-二叉树的直径\" class=\"headerlink\" title=\"543. 二叉树的直径\"></a>543. 二叉树的直径</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">diameterOfBinaryTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = l + r + <span class=\"number\">1</span></span><br><span class=\"line\">    ans = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(path, ans)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(l, r) + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"543-二叉树的直径\"><a href=\"#543-二叉树的直径\" class=\"headerlink\" title=\"543. 二叉树的直径\"></a>543. 二叉树的直径</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">diameterOfBinaryTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = l + r + <span class=\"number\">1</span></span><br><span class=\"line\">    ans = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(path, ans)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(l, r) + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 563. 二叉树的坡度\n\n给定一个二叉树，计算 整个树 的坡度 。\n\n一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。\n\n整个树 的坡度就是其所有节点的坡度之和。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-tilt)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findTilt(root: TreeNode | null): number {\n  let res = 0\n  function traverse(root: TreeNode | null): number {\n    if (root === null) return 0\n    let leftRes = traverse(root.left)\n    let rightRes = traverse(root.right)\n    res += Math.abs(leftRes - rightRes)\n    return leftRes + rightRes + root.val\n  }\n  traverse(root)\n  return res\n};\n\n```\n","source":"leetcode/二叉树/563.二叉树的坡度.md","raw":"# 563. 二叉树的坡度\n\n给定一个二叉树，计算 整个树 的坡度 。\n\n一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。\n\n整个树 的坡度就是其所有节点的坡度之和。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-tilt)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findTilt(root: TreeNode | null): number {\n  let res = 0\n  function traverse(root: TreeNode | null): number {\n    if (root === null) return 0\n    let leftRes = traverse(root.left)\n    let rightRes = traverse(root.right)\n    res += Math.abs(leftRes - rightRes)\n    return leftRes + rightRes + root.val\n  }\n  traverse(root)\n  return res\n};\n\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.563Z","path":"leetcode/二叉树/563.二叉树的坡度.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002ctnw7fsieg58g","content":"<h1 id=\"563-二叉树的坡度\"><a href=\"#563-二叉树的坡度\" class=\"headerlink\" title=\"563. 二叉树的坡度\"></a>563. 二叉树的坡度</h1><p>给定一个二叉树，计算 整个树 的坡度 。</p>\n<p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n<p>整个树 的坡度就是其所有节点的坡度之和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-tilt\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findTilt</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> leftRes = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rightRes = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">    res += <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(leftRes - rightRes)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leftRes + rightRes + root.<span class=\"property\">val</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"563-二叉树的坡度\"><a href=\"#563-二叉树的坡度\" class=\"headerlink\" title=\"563. 二叉树的坡度\"></a>563. 二叉树的坡度</h1><p>给定一个二叉树，计算 整个树 的坡度 。</p>\n<p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n<p>整个树 的坡度就是其所有节点的坡度之和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-tilt\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findTilt</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> leftRes = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rightRes = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">    res += <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>(leftRes - rightRes)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> leftRes + rightRes + root.<span class=\"property\">val</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 538. 把二叉搜索树转换为累加树\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n[链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree)\n\n```ts\nlet total = 0\n\nfunction convertBST(root: TreeNode | null): TreeNode | null {\n  total = 0\n  traverse(root)\n  return root\n};\n\nfunction traverse(root): TreeNode | null {\n  if (root === null) return null\n  traverse(root.right)\n  total += root.val\n  root.val = total\n  traverse(root.left)\n}\n```\n","source":"leetcode/二叉树/538.把二叉搜索树转换为累加树.md","raw":"# 538. 把二叉搜索树转换为累加树\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n[链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree)\n\n```ts\nlet total = 0\n\nfunction convertBST(root: TreeNode | null): TreeNode | null {\n  total = 0\n  traverse(root)\n  return root\n};\n\nfunction traverse(root): TreeNode | null {\n  if (root === null) return null\n  traverse(root.right)\n  total += root.val\n  root.val = total\n  traverse(root.left)\n}\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.562Z","path":"leetcode/二叉树/538.把二叉搜索树转换为累加树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002dtnw7dmoc87fl","content":"<h1 id=\"538-把二叉搜索树转换为累加树\"><a href=\"#538-把二叉搜索树转换为累加树\" class=\"headerlink\" title=\"538. 把二叉搜索树转换为累加树\"></a>538. 把二叉搜索树转换为累加树</h1><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">convertBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  total += root.<span class=\"property\">val</span></span><br><span class=\"line\">  root.<span class=\"property\">val</span> = total</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"538-把二叉搜索树转换为累加树\"><a href=\"#538-把二叉搜索树转换为累加树\" class=\"headerlink\" title=\"538. 把二叉搜索树转换为累加树\"></a>538. 把二叉搜索树转换为累加树</h1><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">convertBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  total += root.<span class=\"property\">val</span></span><br><span class=\"line\">  root.<span class=\"property\">val</span> = total</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 572. 另一个树的子树\n\n给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。\n\n[链接](https://leetcode-cn.com/problems/subtree-of-another-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSame(treeA: TreeNode | null, treeB: TreeNode | null): boolean {\n  if (treeA === null && treeB === null) return true\n  if (\n    (treeA === null && treeB !== null) ||\n    (treeA !== null && treeB === null)\n  ) return false\n  return treeA.val === treeB.val && isSame(treeA.left, treeB.left) && isSame(treeA.right, treeB.right)\n}\n\nfunction isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {\n  let res = false\n  function traverse(node: TreeNode | null) {\n    if (node === null) return\n    if (node.val === subRoot.val && !res) {\n      res = isSame(node, subRoot)\n      if (res) {\n        return\n      }\n    }\n    traverse(node.left)\n    traverse(node.right)\n  }\n  traverse(root)\n  return res\n};\n```\n","source":"leetcode/二叉树/572.另一个树的子树.md","raw":"# 572. 另一个树的子树\n\n给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。\n\n[链接](https://leetcode-cn.com/problems/subtree-of-another-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isSame(treeA: TreeNode | null, treeB: TreeNode | null): boolean {\n  if (treeA === null && treeB === null) return true\n  if (\n    (treeA === null && treeB !== null) ||\n    (treeA !== null && treeB === null)\n  ) return false\n  return treeA.val === treeB.val && isSame(treeA.left, treeB.left) && isSame(treeA.right, treeB.right)\n}\n\nfunction isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {\n  let res = false\n  function traverse(node: TreeNode | null) {\n    if (node === null) return\n    if (node.val === subRoot.val && !res) {\n      res = isSame(node, subRoot)\n      if (res) {\n        return\n      }\n    }\n    traverse(node.left)\n    traverse(node.right)\n  }\n  traverse(root)\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.563Z","path":"leetcode/二叉树/572.另一个树的子树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002etnw7gjgv49uf","content":"<h1 id=\"572-另一个树的子树\"><a href=\"#572-另一个树的子树\" class=\"headerlink\" title=\"572. 另一个树的子树\"></a>572. 另一个树的子树</h1><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/subtree-of-another-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSame</span>(<span class=\"params\">treeA: TreeNode | <span class=\"literal\">null</span>, treeB: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (treeA === <span class=\"literal\">null</span> &amp;&amp; treeB === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (treeA === <span class=\"literal\">null</span> &amp;&amp; treeB !== <span class=\"literal\">null</span>) ||</span><br><span class=\"line\">    (treeA !== <span class=\"literal\">null</span> &amp;&amp; treeB === <span class=\"literal\">null</span>)</span><br><span class=\"line\">  ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> treeA.<span class=\"property\">val</span> === treeB.<span class=\"property\">val</span> &amp;&amp; <span class=\"title function_\">isSame</span>(treeA.<span class=\"property\">left</span>, treeB.<span class=\"property\">left</span>) &amp;&amp; <span class=\"title function_\">isSame</span>(treeA.<span class=\"property\">right</span>, treeB.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSubtree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, subRoot: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === subRoot.<span class=\"property\">val</span> &amp;&amp; !res) &#123;</span><br><span class=\"line\">      res = <span class=\"title function_\">isSame</span>(node, subRoot)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"572-另一个树的子树\"><a href=\"#572-另一个树的子树\" class=\"headerlink\" title=\"572. 另一个树的子树\"></a>572. 另一个树的子树</h1><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/subtree-of-another-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSame</span>(<span class=\"params\">treeA: TreeNode | <span class=\"literal\">null</span>, treeB: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (treeA === <span class=\"literal\">null</span> &amp;&amp; treeB === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (treeA === <span class=\"literal\">null</span> &amp;&amp; treeB !== <span class=\"literal\">null</span>) ||</span><br><span class=\"line\">    (treeA !== <span class=\"literal\">null</span> &amp;&amp; treeB === <span class=\"literal\">null</span>)</span><br><span class=\"line\">  ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> treeA.<span class=\"property\">val</span> === treeB.<span class=\"property\">val</span> &amp;&amp; <span class=\"title function_\">isSame</span>(treeA.<span class=\"property\">left</span>, treeB.<span class=\"property\">left</span>) &amp;&amp; <span class=\"title function_\">isSame</span>(treeA.<span class=\"property\">right</span>, treeB.<span class=\"property\">right</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSubtree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, subRoot: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> === subRoot.<span class=\"property\">val</span> &amp;&amp; !res) &#123;</span><br><span class=\"line\">      res = <span class=\"title function_\">isSame</span>(node, subRoot)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 589. N 叉树的前序遍历\n\n给定一个 N 叉树，返回其节点值的 前序遍历 。\n\nN 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。\n\n```ts\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {number[]}\n */\nvar preorder = function(root) {\n  let node = root\n  let res = []\n  if (root === null) return res\n  let nodeStack = [node]\n  while(nodeStack.length) {\n    const node = nodeStack.pop()\n    res.push(node.val)\n    const { children = [] } = node\n    nodeStack = nodeStack.concat(children.reverse())\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/589.N叉树的前序遍历.md","raw":"# 589. N 叉树的前序遍历\n\n给定一个 N 叉树，返回其节点值的 前序遍历 。\n\nN 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。\n\n```ts\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {number[]}\n */\nvar preorder = function(root) {\n  let node = root\n  let res = []\n  if (root === null) return res\n  let nodeStack = [node]\n  while(nodeStack.length) {\n    const node = nodeStack.pop()\n    res.push(node.val)\n    const { children = [] } = node\n    nodeStack = nodeStack.concat(children.reverse())\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.207Z","updated":"2023-09-26T14:49:23.563Z","path":"leetcode/二叉树/589.N叉树的前序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002ftnw745hchj9d","content":"<h1 id=\"589-N-叉树的前序遍历\"><a href=\"#589-N-叉树的前序遍历\" class=\"headerlink\" title=\"589. N 叉树的前序遍历\"></a>589. N 叉树的前序遍历</h1><p>给定一个 N 叉树，返回其节点值的 前序遍历 。</p>\n<p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function Node(val, children) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.children = children;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">Node</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> preorder = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = root</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nodeStack = [node]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeStack.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = nodeStack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; children = [] &#125; = node</span><br><span class=\"line\">    nodeStack = nodeStack.<span class=\"title function_\">concat</span>(children.<span class=\"title function_\">reverse</span>())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"589-N-叉树的前序遍历\"><a href=\"#589-N-叉树的前序遍历\" class=\"headerlink\" title=\"589. N 叉树的前序遍历\"></a>589. N 叉树的前序遍历</h1><p>给定一个 N 叉树，返回其节点值的 前序遍历 。</p>\n<p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function Node(val, children) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.children = children;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">Node</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> preorder = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = root</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nodeStack = [node]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeStack.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = nodeStack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; children = [] &#125; = node</span><br><span class=\"line\">    nodeStack = nodeStack.<span class=\"title function_\">concat</span>(children.<span class=\"title function_\">reverse</span>())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 590. N 叉树的后序遍历\n\n给定一个 N 叉树，返回其节点值的 后序遍历 。\n\nN 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。\n\n[链接](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n```ts\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {number[]}\n */\nvar postorder = function(root) {\n  let node = root\n  let res = []\n  if (root === null) return res\n  let nodeStack = [node]\n  while(nodeStack.length) {\n    const node = nodeStack.pop()\n    res.unshift(node.val)\n    const { children = [] } = node\n    nodeStack = nodeStack.concat(children)\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/590.N叉树的后序遍历.md","raw":"# 590. N 叉树的后序遍历\n\n给定一个 N 叉树，返回其节点值的 后序遍历 。\n\nN 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。\n\n[链接](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n```ts\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {number[]}\n */\nvar postorder = function(root) {\n  let node = root\n  let res = []\n  if (root === null) return res\n  let nodeStack = [node]\n  while(nodeStack.length) {\n    const node = nodeStack.pop()\n    res.unshift(node.val)\n    const { children = [] } = node\n    nodeStack = nodeStack.concat(children)\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.563Z","path":"leetcode/二叉树/590.N叉树的后序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002gtnw767b95hu2","content":"<h1 id=\"590-N-叉树的后序遍历\"><a href=\"#590-N-叉树的后序遍历\" class=\"headerlink\" title=\"590. N 叉树的后序遍历\"></a>590. N 叉树的后序遍历</h1><p>给定一个 N 叉树，返回其节点值的 后序遍历 。</p>\n<p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function Node(val,children) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.children = children;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">Node</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> postorder = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = root</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nodeStack = [node]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeStack.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = nodeStack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    res.<span class=\"title function_\">unshift</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; children = [] &#125; = node</span><br><span class=\"line\">    nodeStack = nodeStack.<span class=\"title function_\">concat</span>(children)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"590-N-叉树的后序遍历\"><a href=\"#590-N-叉树的后序遍历\" class=\"headerlink\" title=\"590. N 叉树的后序遍历\"></a>590. N 叉树的后序遍历</h1><p>给定一个 N 叉树，返回其节点值的 后序遍历 。</p>\n<p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>\n<p><a href=\"https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * // Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function Node(val,children) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *    this.children = children;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">Node</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> postorder = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = root</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nodeStack = [node]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeStack.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = nodeStack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    res.<span class=\"title function_\">unshift</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; children = [] &#125; = node</span><br><span class=\"line\">    nodeStack = nodeStack.<span class=\"title function_\">concat</span>(children)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 617. 合并二叉树\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n[链接](https://leetcode-cn.com/problems/merge-two-binary-trees)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {\n  if (root1 === null) return root2\n  if (root2 === null) return root1\n  const node = new TreeNode(root1.val + root2.val)\n  node.left = mergeTrees(root1.left, root2.left)\n  node.right = mergeTrees(root1.right, root2.right)\n  return node\n};\n```\n","source":"leetcode/二叉树/617.合并二叉树.md","raw":"# 617. 合并二叉树\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n[链接](https://leetcode-cn.com/problems/merge-two-binary-trees)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {\n  if (root1 === null) return root2\n  if (root2 === null) return root1\n  const node = new TreeNode(root1.val + root2.val)\n  node.left = mergeTrees(root1.left, root2.left)\n  node.right = mergeTrees(root1.right, root2.right)\n  return node\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.564Z","path":"leetcode/二叉树/617.合并二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002htnw79tusdng6","content":"<h1 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a>617. 合并二叉树</h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>\n<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mergeTrees</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root1 === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root2</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root2 === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root1</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(root1.<span class=\"property\">val</span> + root2.<span class=\"property\">val</span>)</span><br><span class=\"line\">  node.<span class=\"property\">left</span> = <span class=\"title function_\">mergeTrees</span>(root1.<span class=\"property\">left</span>, root2.<span class=\"property\">left</span>)</span><br><span class=\"line\">  node.<span class=\"property\">right</span> = <span class=\"title function_\">mergeTrees</span>(root1.<span class=\"property\">right</span>, root2.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a>617. 合并二叉树</h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>\n<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mergeTrees</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root1 === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root2</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root2 === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root1</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(root1.<span class=\"property\">val</span> + root2.<span class=\"property\">val</span>)</span><br><span class=\"line\">  node.<span class=\"property\">left</span> = <span class=\"title function_\">mergeTrees</span>(root1.<span class=\"property\">left</span>, root2.<span class=\"property\">left</span>)</span><br><span class=\"line\">  node.<span class=\"property\">right</span> = <span class=\"title function_\">mergeTrees</span>(root1.<span class=\"property\">right</span>, root2.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 606. 根据二叉树创建字符串\n\n你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\n\n空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\n\n[链接](https://leetcode-cn.com/problems/construct-string-from-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction tree2str(root: TreeNode | null): string {\n  if (root === null) return ''\n  let str = `${root.val}`\n  if (root.left === null && root.right === null) return str + ''\n  if (root.right === null) return str + `(${tree2str(root.left)})`\n  return `${str}(${tree2str(root.left)})(${tree2str(root.right)})` \n};\n```\n","source":"leetcode/二叉树/606.根据二叉树创建字符串.md","raw":"# 606. 根据二叉树创建字符串\n\n你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\n\n空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\n\n[链接](https://leetcode-cn.com/problems/construct-string-from-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction tree2str(root: TreeNode | null): string {\n  if (root === null) return ''\n  let str = `${root.val}`\n  if (root.left === null && root.right === null) return str + ''\n  if (root.right === null) return str + `(${tree2str(root.left)})`\n  return `${str}(${tree2str(root.left)})(${tree2str(root.right)})` \n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.563Z","path":"leetcode/二叉树/606.根据二叉树创建字符串.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002itnw7628q8dcq","content":"<h1 id=\"606-根据二叉树创建字符串\"><a href=\"#606-根据二叉树创建字符串\" class=\"headerlink\" title=\"606. 根据二叉树创建字符串\"></a>606. 根据二叉树创建字符串</h1><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>\n<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-string-from-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">tree2str</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> str = <span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> str + <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> str + <span class=\"string\">`(<span class=\"subst\">$&#123;tree2str(root.left)&#125;</span>)`</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span>(<span class=\"subst\">$&#123;tree2str(root.left)&#125;</span>)(<span class=\"subst\">$&#123;tree2str(root.right)&#125;</span>)`</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"606-根据二叉树创建字符串\"><a href=\"#606-根据二叉树创建字符串\" class=\"headerlink\" title=\"606. 根据二叉树创建字符串\"></a>606. 根据二叉树创建字符串</h1><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>\n<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-string-from-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">tree2str</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> str = <span class=\"string\">`<span class=\"subst\">$&#123;root.val&#125;</span>`</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> str + <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> str + <span class=\"string\">`(<span class=\"subst\">$&#123;tree2str(root.left)&#125;</span>)`</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span>(<span class=\"subst\">$&#123;tree2str(root.left)&#125;</span>)(<span class=\"subst\">$&#123;tree2str(root.right)&#125;</span>)`</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 623. 在二叉树中增加一行\n\n给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。\n\n添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。\n\n将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。\n\n如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。\n\n[链接](https://leetcode-cn.com/problems/add-one-row-to-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\nfunction addOneRow(root: TreeNode | null, val: number, depth: number): TreeNode | null {\n  if (depth === 1) {\n    const r = new TreeNode(val)\n    r.left = root\n    return r\n  }\n  if (root === null) {\n    return null\n  }\n  let nodeQues: (TreeNode | null)[] = [root]\n  while(nodeQues.length > 0) {\n    depth--\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    if (depth === 1) {\n      for(let i = 0; i < len; i++) {\n        const parent = nodes[i]\n        const newLNode = new TreeNode(val)\n        if (parent.left) {\n          newLNode.left = parent.left\n        }\n        parent.left = newLNode\n        const newRNode = new TreeNode(val)\n        if (parent.right) {\n          newRNode.right = parent.right\n        }\n        parent.right = newRNode\n      }\n      break\n    } else {\n      nodeQues = nodes.reduce((pre: TreeNode[], n: TreeNode) => {\n        n.left && pre.push(n.left)\n        n.right && pre.push(n.right)\n        return pre\n      }, [])\n    }\n  }\n  return root\n};\n```\n","source":"leetcode/二叉树/623.在二叉树中增加一行.md","raw":"# 623. 在二叉树中增加一行\n\n给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。\n\n添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。\n\n将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。\n\n如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。\n\n[链接](https://leetcode-cn.com/problems/add-one-row-to-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n\nfunction addOneRow(root: TreeNode | null, val: number, depth: number): TreeNode | null {\n  if (depth === 1) {\n    const r = new TreeNode(val)\n    r.left = root\n    return r\n  }\n  if (root === null) {\n    return null\n  }\n  let nodeQues: (TreeNode | null)[] = [root]\n  while(nodeQues.length > 0) {\n    depth--\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    if (depth === 1) {\n      for(let i = 0; i < len; i++) {\n        const parent = nodes[i]\n        const newLNode = new TreeNode(val)\n        if (parent.left) {\n          newLNode.left = parent.left\n        }\n        parent.left = newLNode\n        const newRNode = new TreeNode(val)\n        if (parent.right) {\n          newRNode.right = parent.right\n        }\n        parent.right = newRNode\n      }\n      break\n    } else {\n      nodeQues = nodes.reduce((pre: TreeNode[], n: TreeNode) => {\n        n.left && pre.push(n.left)\n        n.right && pre.push(n.right)\n        return pre\n      }, [])\n    }\n  }\n  return root\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.564Z","path":"leetcode/二叉树/623.在二叉树中增加一行.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002jtnw7f8v65vxk","content":"<h1 id=\"623-在二叉树中增加一行\"><a href=\"#623-在二叉树中增加一行\" class=\"headerlink\" title=\"623. 在二叉树中增加一行\"></a>623. 在二叉树中增加一行</h1><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。</p>\n<p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p>\n<p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p>\n<p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/add-one-row-to-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">addOneRow</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span>, depth: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (depth === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">    r.<span class=\"property\">left</span> = root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">nodeQues</span>: (<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>)[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    depth--</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> parent = nodes[i]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newLNode = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          newLNode.<span class=\"property\">left</span> = parent.<span class=\"property\">left</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent.<span class=\"property\">left</span> = newLNode</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newRNode = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          newRNode.<span class=\"property\">right</span> = parent.<span class=\"property\">right</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent.<span class=\"property\">right</span> = newRNode</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      nodeQues = nodes.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre: TreeNode[], n: TreeNode</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        n.<span class=\"property\">left</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(n.<span class=\"property\">left</span>)</span><br><span class=\"line\">        n.<span class=\"property\">right</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(n.<span class=\"property\">right</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">      &#125;, [])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"623-在二叉树中增加一行\"><a href=\"#623-在二叉树中增加一行\" class=\"headerlink\" title=\"623. 在二叉树中增加一行\"></a>623. 在二叉树中增加一行</h1><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。</p>\n<p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p>\n<p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p>\n<p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/add-one-row-to-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">addOneRow</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span>, depth: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (depth === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">    r.<span class=\"property\">left</span> = root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">nodeQues</span>: (<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>)[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    depth--</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> parent = nodes[i]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newLNode = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          newLNode.<span class=\"property\">left</span> = parent.<span class=\"property\">left</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent.<span class=\"property\">left</span> = newLNode</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newRNode = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          newRNode.<span class=\"property\">right</span> = parent.<span class=\"property\">right</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent.<span class=\"property\">right</span> = newRNode</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      nodeQues = nodes.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre: TreeNode[], n: TreeNode</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        n.<span class=\"property\">left</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(n.<span class=\"property\">left</span>)</span><br><span class=\"line\">        n.<span class=\"property\">right</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(n.<span class=\"property\">right</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">      &#125;, [])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 637. 二叉树的层平均值\n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction averageOfLevels(root: TreeNode | null): number[] {\n  const res: number[] = []\n  if (root === null) return res\n  const nodeQues: TreeNode[] = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    let sum = 0\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      sum += node.val\n      node.left && nodeQues.push(node.left)\n      node.right && nodeQues.push(node.right)\n    }\n    res.push(sum / len)\n  }\n  return res\n};\n```\n","source":"leetcode/二叉树/637.二叉树的层平均值.md","raw":"# 637. 二叉树的层平均值\n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction averageOfLevels(root: TreeNode | null): number[] {\n  const res: number[] = []\n  if (root === null) return res\n  const nodeQues: TreeNode[] = [root]\n  while(nodeQues.length > 0) {\n    const nodes = nodeQues.splice(0)\n    const len = nodes.length\n    let sum = 0\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      sum += node.val\n      node.left && nodeQues.push(node.left)\n      node.right && nodeQues.push(node.right)\n    }\n    res.push(sum / len)\n  }\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.565Z","path":"leetcode/二叉树/637.二叉树的层平均值.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002ktnw7cl75butf","content":"<h1 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637. 二叉树的层平均值\"></a>637. 二叉树的层平均值</h1><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">averageOfLevels</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      sum += node.<span class=\"property\">val</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> &amp;&amp; nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      node.<span class=\"property\">right</span> &amp;&amp; nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(sum / len)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637. 二叉树的层平均值\"></a>637. 二叉树的层平均值</h1><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">averageOfLevels</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQues.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      sum += node.<span class=\"property\">val</span></span><br><span class=\"line\">      node.<span class=\"property\">left</span> &amp;&amp; nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      node.<span class=\"property\">right</span> &amp;&amp; nodeQues.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.<span class=\"title function_\">push</span>(sum / len)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 652. 寻找重复的子树\n\n给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。\n\n两棵树重复是指它们具有相同的结构以及相同的结点值。\n\n[链接](https://leetcode-cn.com/problems/find-duplicate-subtrees/)\n\n```ts\nlet treeMap = {}\nlet treeList: Array<TreeNode | null> = []\nfunction findDuplicateSubtrees(root: TreeNode | null): Array<TreeNode | null> {\n  treeMap = {}\n  treeList = []\n  traverse(root)\n  return treeList\n};\nfunction traverse(root: TreeNode) : String {\n  if (root === null) {\n    return '#'\n  }\n  const left = traverse(root.left)\n  const right = traverse(root.right)\n  const res = left + ',' + right + ',' + root.val\n  if (!treeMap[res]) {\n    treeMap[res] = 'first'\n  } else if (treeMap[res] === 'first') {\n    treeMap[res] = 'no-first'\n    treeList.push(root)\n  }\n  return res\n}\n```\n","source":"leetcode/二叉树/652.寻找重复的子树.md","raw":"# 652. 寻找重复的子树\n\n给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。\n\n两棵树重复是指它们具有相同的结构以及相同的结点值。\n\n[链接](https://leetcode-cn.com/problems/find-duplicate-subtrees/)\n\n```ts\nlet treeMap = {}\nlet treeList: Array<TreeNode | null> = []\nfunction findDuplicateSubtrees(root: TreeNode | null): Array<TreeNode | null> {\n  treeMap = {}\n  treeList = []\n  traverse(root)\n  return treeList\n};\nfunction traverse(root: TreeNode) : String {\n  if (root === null) {\n    return '#'\n  }\n  const left = traverse(root.left)\n  const right = traverse(root.right)\n  const res = left + ',' + right + ',' + root.val\n  if (!treeMap[res]) {\n    treeMap[res] = 'first'\n  } else if (treeMap[res] === 'first') {\n    treeMap[res] = 'no-first'\n    treeList.push(root)\n  }\n  return res\n}\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.565Z","path":"leetcode/二叉树/652.寻找重复的子树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002ltnw78gemhcx7","content":"<h1 id=\"652-寻找重复的子树\"><a href=\"#652-寻找重复的子树\" class=\"headerlink\" title=\"652. 寻找重复的子树\"></a>652. 寻找重复的子树</h1><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>\n<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-duplicate-subtrees/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> treeMap = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">treeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = []</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findDuplicateSubtrees</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">  treeMap = &#123;&#125;</span><br><span class=\"line\">  treeList = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> treeList</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>) : <span class=\"title class_\">String</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = left + <span class=\"string\">&#x27;,&#x27;</span> + right + <span class=\"string\">&#x27;,&#x27;</span> + root.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!treeMap[res]) &#123;</span><br><span class=\"line\">    treeMap[res] = <span class=\"string\">&#x27;first&#x27;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (treeMap[res] === <span class=\"string\">&#x27;first&#x27;</span>) &#123;</span><br><span class=\"line\">    treeMap[res] = <span class=\"string\">&#x27;no-first&#x27;</span></span><br><span class=\"line\">    treeList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"652-寻找重复的子树\"><a href=\"#652-寻找重复的子树\" class=\"headerlink\" title=\"652. 寻找重复的子树\"></a>652. 寻找重复的子树</h1><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>\n<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-duplicate-subtrees/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> treeMap = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">treeList</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; = []</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findDuplicateSubtrees</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">  treeMap = &#123;&#125;</span><br><span class=\"line\">  treeList = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> treeList</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode</span>) : <span class=\"title class_\">String</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = left + <span class=\"string\">&#x27;,&#x27;</span> + right + <span class=\"string\">&#x27;,&#x27;</span> + root.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!treeMap[res]) &#123;</span><br><span class=\"line\">    treeMap[res] = <span class=\"string\">&#x27;first&#x27;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (treeMap[res] === <span class=\"string\">&#x27;first&#x27;</span>) &#123;</span><br><span class=\"line\">    treeMap[res] = <span class=\"string\">&#x27;no-first&#x27;</span></span><br><span class=\"line\">    treeList.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 653. 两数之和 IV - 输入 BST\n\n给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findTarget(root: TreeNode | null, k: number): boolean {\n  const targetMap = {}\n  let isFind = false\n  function traverse(node: TreeNode) {\n    if (node === null) return\n    traverse(node.left)\n    if (targetMap[k - node.val]) {\n      isFind = true\n      return\n    }\n    targetMap[node.val] = true\n\n    traverse(node.right)\n  }\n  traverse(root)\n  return isFind\n};\n```\n","source":"leetcode/二叉树/653.两数之和IV-输入BST.md","raw":"# 653. 两数之和 IV - 输入 BST\n\n给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction findTarget(root: TreeNode | null, k: number): boolean {\n  const targetMap = {}\n  let isFind = false\n  function traverse(node: TreeNode) {\n    if (node === null) return\n    traverse(node.left)\n    if (targetMap[k - node.val]) {\n      isFind = true\n      return\n    }\n    targetMap[node.val] = true\n\n    traverse(node.right)\n  }\n  traverse(root)\n  return isFind\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.565Z","path":"leetcode/二叉树/653.两数之和IV-输入BST.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002mtnw76hdz4ga1","content":"<h1 id=\"653-两数之和-IV-输入-BST\"><a href=\"#653-两数之和-IV-输入-BST\" class=\"headerlink\" title=\"653. 两数之和 IV - 输入 BST\"></a>653. 两数之和 IV - 输入 BST</h1><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findTarget</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetMap = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isFind = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetMap[k - node.<span class=\"property\">val</span>]) &#123;</span><br><span class=\"line\">      isFind = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    targetMap[node.<span class=\"property\">val</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isFind</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"653-两数之和-IV-输入-BST\"><a href=\"#653-两数之和-IV-输入-BST\" class=\"headerlink\" title=\"653. 两数之和 IV - 输入 BST\"></a>653. 两数之和 IV - 输入 BST</h1><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findTarget</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetMap = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> isFind = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetMap[k - node.<span class=\"property\">val</span>]) &#123;</span><br><span class=\"line\">      isFind = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    targetMap[node.<span class=\"property\">val</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isFind</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 655. 输出二叉树\n\n在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：\n\n1.行数 m 应当等于给定二叉树的高度。\n\n2.列数 n 应当总是奇数。\n\n3.根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。\n\n4.每个未使用的空间应包含一个空的字符串\"\"。\n\n5.使用相同的规则输出子树。\n\n[链接](https://leetcode-cn.com/problems/print-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getTreeDepth(root: TreeNode | null): number {\n  if (root === null) return 0\n  return 1 + Math.max(getTreeDepth(root.left), getTreeDepth(root.right))\n}\n\nfunction fill(root: TreeNode | null, res: string[][], depth: number, left: number, right: number) {\n  if (root === null) return\n  const middle = Math.floor((left + right) / 2)\n  res[depth][middle] = \"\" + root.val\n  fill(root.left, res, depth + 1, left, middle - 1)\n  fill(root.right, res, depth + 1, middle + 1, right)\n}\n\nfunction printTree(root: TreeNode | null): string[][] {\n  let res: string[][] = []\n  if (root === null) return res\n  const depth = getTreeDepth(root)\n  const n = (1 << depth) - 1\n  res = Array.from(Array(depth), () => Array(n).fill(\"\"))\n  fill(root, res, 0, 0, n)\n  return res\n};\n```\n","source":"leetcode/二叉树/655.输出二叉树.md","raw":"# 655. 输出二叉树\n\n在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：\n\n1.行数 m 应当等于给定二叉树的高度。\n\n2.列数 n 应当总是奇数。\n\n3.根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。\n\n4.每个未使用的空间应包含一个空的字符串\"\"。\n\n5.使用相同的规则输出子树。\n\n[链接](https://leetcode-cn.com/problems/print-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction getTreeDepth(root: TreeNode | null): number {\n  if (root === null) return 0\n  return 1 + Math.max(getTreeDepth(root.left), getTreeDepth(root.right))\n}\n\nfunction fill(root: TreeNode | null, res: string[][], depth: number, left: number, right: number) {\n  if (root === null) return\n  const middle = Math.floor((left + right) / 2)\n  res[depth][middle] = \"\" + root.val\n  fill(root.left, res, depth + 1, left, middle - 1)\n  fill(root.right, res, depth + 1, middle + 1, right)\n}\n\nfunction printTree(root: TreeNode | null): string[][] {\n  let res: string[][] = []\n  if (root === null) return res\n  const depth = getTreeDepth(root)\n  const n = (1 << depth) - 1\n  res = Array.from(Array(depth), () => Array(n).fill(\"\"))\n  fill(root, res, 0, 0, n)\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.566Z","path":"leetcode/二叉树/655.输出二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002ntnw73s5l6quz","content":"<h1 id=\"655-输出二叉树\"><a href=\"#655-输出二叉树\" class=\"headerlink\" title=\"655. 输出二叉树\"></a>655. 输出二叉树</h1><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>\n<p>1.行数 m 应当等于给定二叉树的高度。</p>\n<p>2.列数 n 应当总是奇数。</p>\n<p>3.根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</p>\n<p>4.每个未使用的空间应包含一个空的字符串””。</p>\n<p>5.使用相同的规则输出子树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/print-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTreeDepth</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"title function_\">getTreeDepth</span>(root.<span class=\"property\">left</span>), <span class=\"title function_\">getTreeDepth</span>(root.<span class=\"property\">right</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fill</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, res: <span class=\"built_in\">string</span>[][], depth: <span class=\"built_in\">number</span>, left: <span class=\"built_in\">number</span>, right: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> middle = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>((left + right) / <span class=\"number\">2</span>)</span><br><span class=\"line\">  res[depth][middle] = <span class=\"string\">&quot;&quot;</span> + root.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"title function_\">fill</span>(root.<span class=\"property\">left</span>, res, depth + <span class=\"number\">1</span>, left, middle - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"title function_\">fill</span>(root.<span class=\"property\">right</span>, res, depth + <span class=\"number\">1</span>, middle + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">string</span>[][] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> depth = <span class=\"title function_\">getTreeDepth</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = (<span class=\"number\">1</span> &lt;&lt; depth) - <span class=\"number\">1</span></span><br><span class=\"line\">  res = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(depth), <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">  <span class=\"title function_\">fill</span>(root, res, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"655-输出二叉树\"><a href=\"#655-输出二叉树\" class=\"headerlink\" title=\"655. 输出二叉树\"></a>655. 输出二叉树</h1><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>\n<p>1.行数 m 应当等于给定二叉树的高度。</p>\n<p>2.列数 n 应当总是奇数。</p>\n<p>3.根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</p>\n<p>4.每个未使用的空间应包含一个空的字符串””。</p>\n<p>5.使用相同的规则输出子树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/print-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getTreeDepth</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"title function_\">getTreeDepth</span>(root.<span class=\"property\">left</span>), <span class=\"title function_\">getTreeDepth</span>(root.<span class=\"property\">right</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fill</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, res: <span class=\"built_in\">string</span>[][], depth: <span class=\"built_in\">number</span>, left: <span class=\"built_in\">number</span>, right: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> middle = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>((left + right) / <span class=\"number\">2</span>)</span><br><span class=\"line\">  res[depth][middle] = <span class=\"string\">&quot;&quot;</span> + root.<span class=\"property\">val</span></span><br><span class=\"line\">  <span class=\"title function_\">fill</span>(root.<span class=\"property\">left</span>, res, depth + <span class=\"number\">1</span>, left, middle - <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"title function_\">fill</span>(root.<span class=\"property\">right</span>, res, depth + <span class=\"number\">1</span>, middle + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span>[][] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">res</span>: <span class=\"built_in\">string</span>[][] = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  <span class=\"keyword\">const</span> depth = <span class=\"title function_\">getTreeDepth</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = (<span class=\"number\">1</span> &lt;&lt; depth) - <span class=\"number\">1</span></span><br><span class=\"line\">  res = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(depth), <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Array</span>(n).<span class=\"title function_\">fill</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">  <span class=\"title function_\">fill</span>(root, res, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 662. 二叉树最大宽度\n\n给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n[链接](https://leetcode-cn.com/problems/maximum-width-of-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\ntype Que = {\n  depth: number;\n  pos: bigint;\n  node: TreeNode | null;\n}\n\nfunction widthOfBinaryTree(root: TreeNode | null): bigint {\n  let ans = 0n\n  if (root === null) return ans\n  const nodeQues: Que[] = [{\n    depth: 0,\n    pos: 0n,\n    node: root\n  }]\n  let curDepth = 0\n  let left = 0n\n  while(nodeQues.length) {\n    const { depth, pos, node } = nodeQues.shift()\n    if (node) {\n      nodeQues.push({ node: node.left, depth: depth + 1, pos: pos * 2n })\n      nodeQues.push({ node: node.right, depth: depth + 1, pos: pos * 2n + 1n })\n      if (curDepth !== depth) {\n        curDepth = depth\n        left = pos\n      }\n      let res = pos - left + 1n\n      ans = res > ans ? res : ans\n    }\n  }\n  return ans\n};\n```\n","source":"leetcode/二叉树/662.二叉树最大宽度.md","raw":"# 662. 二叉树最大宽度\n\n给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n[链接](https://leetcode-cn.com/problems/maximum-width-of-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\ntype Que = {\n  depth: number;\n  pos: bigint;\n  node: TreeNode | null;\n}\n\nfunction widthOfBinaryTree(root: TreeNode | null): bigint {\n  let ans = 0n\n  if (root === null) return ans\n  const nodeQues: Que[] = [{\n    depth: 0,\n    pos: 0n,\n    node: root\n  }]\n  let curDepth = 0\n  let left = 0n\n  while(nodeQues.length) {\n    const { depth, pos, node } = nodeQues.shift()\n    if (node) {\n      nodeQues.push({ node: node.left, depth: depth + 1, pos: pos * 2n })\n      nodeQues.push({ node: node.right, depth: depth + 1, pos: pos * 2n + 1n })\n      if (curDepth !== depth) {\n        curDepth = depth\n        left = pos\n      }\n      let res = pos - left + 1n\n      ans = res > ans ? res : ans\n    }\n  }\n  return ans\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.566Z","path":"leetcode/二叉树/662.二叉树最大宽度.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxr002otnw7a917dogm","content":"<h1 id=\"662-二叉树最大宽度\"><a href=\"#662-二叉树最大宽度\" class=\"headerlink\" title=\"662. 二叉树最大宽度\"></a>662. 二叉树最大宽度</h1><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>\n<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-width-of-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Que</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">depth</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">pos</span>: <span class=\"built_in\">bigint</span>;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">widthOfBinaryTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">bigint</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">0n</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">Que</span>[] = [&#123;</span><br><span class=\"line\">    <span class=\"attr\">depth</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">pos</span>: <span class=\"number\">0n</span>,</span><br><span class=\"line\">    <span class=\"attr\">node</span>: root</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curDepth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0n</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; depth, pos, node &#125; = nodeQues.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">      nodeQues.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">node</span>: node.<span class=\"property\">left</span>, <span class=\"attr\">depth</span>: depth + <span class=\"number\">1</span>, <span class=\"attr\">pos</span>: pos * <span class=\"number\">2n</span> &#125;)</span><br><span class=\"line\">      nodeQues.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">node</span>: node.<span class=\"property\">right</span>, <span class=\"attr\">depth</span>: depth + <span class=\"number\">1</span>, <span class=\"attr\">pos</span>: pos * <span class=\"number\">2n</span> + <span class=\"number\">1n</span> &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curDepth !== depth) &#123;</span><br><span class=\"line\">        curDepth = depth</span><br><span class=\"line\">        left = pos</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = pos - left + <span class=\"number\">1n</span></span><br><span class=\"line\">      ans = res &gt; ans ? res : ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"662-二叉树最大宽度\"><a href=\"#662-二叉树最大宽度\" class=\"headerlink\" title=\"662. 二叉树最大宽度\"></a>662. 二叉树最大宽度</h1><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>\n<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-width-of-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Que</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">depth</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">pos</span>: <span class=\"built_in\">bigint</span>;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">widthOfBinaryTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">bigint</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">0n</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQues</span>: <span class=\"title class_\">Que</span>[] = [&#123;</span><br><span class=\"line\">    <span class=\"attr\">depth</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">pos</span>: <span class=\"number\">0n</span>,</span><br><span class=\"line\">    <span class=\"attr\">node</span>: root</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> curDepth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0n</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQues.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; depth, pos, node &#125; = nodeQues.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">      nodeQues.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">node</span>: node.<span class=\"property\">left</span>, <span class=\"attr\">depth</span>: depth + <span class=\"number\">1</span>, <span class=\"attr\">pos</span>: pos * <span class=\"number\">2n</span> &#125;)</span><br><span class=\"line\">      nodeQues.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">node</span>: node.<span class=\"property\">right</span>, <span class=\"attr\">depth</span>: depth + <span class=\"number\">1</span>, <span class=\"attr\">pos</span>: pos * <span class=\"number\">2n</span> + <span class=\"number\">1n</span> &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curDepth !== depth) &#123;</span><br><span class=\"line\">        curDepth = depth</span><br><span class=\"line\">        left = pos</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = pos - left + <span class=\"number\">1n</span></span><br><span class=\"line\">      ans = res &gt; ans ? res : ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 669. 修剪二叉搜索树\n\n给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。\n\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n\n[链接](https://leetcode-cn.com/problems/trim-a-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction trimBST(root: TreeNode | null, low: number, high: number): TreeNode | null {\n  if (root === null) return null\n  if (root.val > high) return trimBST(root.left, low, high)\n  if (root.val < low) return trimBST(root.right, low, high)\n  root.left = trimBST(root.left, low, high)\n  root.right = trimBST(root.right, low, high)\n  return root\n};\n```\n","source":"leetcode/二叉树/669.修剪二叉搜索树.md","raw":"# 669. 修剪二叉搜索树\n\n给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。\n\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n\n[链接](https://leetcode-cn.com/problems/trim-a-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction trimBST(root: TreeNode | null, low: number, high: number): TreeNode | null {\n  if (root === null) return null\n  if (root.val > high) return trimBST(root.left, low, high)\n  if (root.val < low) return trimBST(root.right, low, high)\n  root.left = trimBST(root.left, low, high)\n  root.right = trimBST(root.right, low, high)\n  return root\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.566Z","path":"leetcode/二叉树/669.修剪二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002ptnw747kzg493","content":"<h1 id=\"669-修剪二叉搜索树\"><a href=\"#669-修剪二叉搜索树\" class=\"headerlink\" title=\"669. 修剪二叉搜索树\"></a>669. 修剪二叉搜索树</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</p>\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n<p><a href=\"https://leetcode-cn.com/problems/trim-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">trimBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, low: <span class=\"built_in\">number</span>, high: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &gt; high) <span class=\"keyword\">return</span> <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">left</span>, low, high)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &lt; low) <span class=\"keyword\">return</span> <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">right</span>, low, high)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">left</span>, low, high)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">right</span>, low, high)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"669-修剪二叉搜索树\"><a href=\"#669-修剪二叉搜索树\" class=\"headerlink\" title=\"669. 修剪二叉搜索树\"></a>669. 修剪二叉搜索树</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</p>\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n<p><a href=\"https://leetcode-cn.com/problems/trim-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">trimBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, low: <span class=\"built_in\">number</span>, high: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &gt; high) <span class=\"keyword\">return</span> <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">left</span>, low, high)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &lt; low) <span class=\"keyword\">return</span> <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">right</span>, low, high)</span><br><span class=\"line\">  root.<span class=\"property\">left</span> = <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">left</span>, low, high)</span><br><span class=\"line\">  root.<span class=\"property\">right</span> = <span class=\"title function_\">trimBST</span>(root.<span class=\"property\">right</span>, low, high)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 684. 冗余连接\n\n在本问题中, 树指的是一个连通且无环的无向图。\n\n输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。\n\n返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。\n\n[链接](https://leetcode-cn.com/problems/redundant-connection)\n\n## 解法思路\n\n按照查并集的思路去解题就好了\n\n```ts\n\nfunction findRedundantConnection(edges: number[][]): number[] {\n  const len = edges.length\n  const parent = Array.from(Array(len + 1), (val, index) => index)\n  for(let i = 0; i < len; i++) {\n    const [ node1, node2 ] = edges[i]\n    if (find(parent, node1) !== find(parent, node2)) {\n      union(parent, node1, node2)\n    } else {\n      return edges[i]\n    }\n  }\n};\n\nfunction find(parent, node): number {\n  return parent[node] === node ? node : parent[node] = find(parent, parent[node])\n}\n\nfunction union(parent, node1, node2) {\n  parent[find(parent, node1)] = find(parent, node2)\n}\n\n```\n","source":"leetcode/二叉树/684.冗余连接.md","raw":"# 684. 冗余连接\n\n在本问题中, 树指的是一个连通且无环的无向图。\n\n输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。\n\n返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。\n\n[链接](https://leetcode-cn.com/problems/redundant-connection)\n\n## 解法思路\n\n按照查并集的思路去解题就好了\n\n```ts\n\nfunction findRedundantConnection(edges: number[][]): number[] {\n  const len = edges.length\n  const parent = Array.from(Array(len + 1), (val, index) => index)\n  for(let i = 0; i < len; i++) {\n    const [ node1, node2 ] = edges[i]\n    if (find(parent, node1) !== find(parent, node2)) {\n      union(parent, node1, node2)\n    } else {\n      return edges[i]\n    }\n  }\n};\n\nfunction find(parent, node): number {\n  return parent[node] === node ? node : parent[node] = find(parent, parent[node])\n}\n\nfunction union(parent, node1, node2) {\n  parent[find(parent, node1)] = find(parent, node2)\n}\n\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.567Z","path":"leetcode/二叉树/684.冗余连接.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002qtnw77na83ww0","content":"<h1 id=\"684-冗余连接\"><a href=\"#684-冗余连接\" class=\"headerlink\" title=\"684. 冗余连接\"></a>684. 冗余连接</h1><p>在本问题中, 树指的是一个连通且无环的无向图。</p>\n<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>\n<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>\n<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>\n<p><a href=\"https://leetcode-cn.com/problems/redundant-connection\">链接</a></p>\n<h2 id=\"解法思路\"><a href=\"#解法思路\" class=\"headerlink\" title=\"解法思路\"></a>解法思路</h2><p>按照查并集的思路去解题就好了</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findRedundantConnection</span>(<span class=\"params\">edges: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = edges.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(len + <span class=\"number\">1</span>), <span class=\"function\">(<span class=\"params\">val, index</span>) =&gt;</span> index)</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ node1, node2 ] = edges[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">find</span>(parent, node1) !== <span class=\"title function_\">find</span>(parent, node2)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">union</span>(parent, node1, node2)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> edges[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">find</span>(<span class=\"params\">parent, node</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent[node] === node ? node : parent[node] = <span class=\"title function_\">find</span>(parent, parent[node])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">union</span>(<span class=\"params\">parent, node1, node2</span>) &#123;</span><br><span class=\"line\">  parent[<span class=\"title function_\">find</span>(parent, node1)] = <span class=\"title function_\">find</span>(parent, node2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"684-冗余连接\"><a href=\"#684-冗余连接\" class=\"headerlink\" title=\"684. 冗余连接\"></a>684. 冗余连接</h1><p>在本问题中, 树指的是一个连通且无环的无向图。</p>\n<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>\n<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>\n<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>\n<p><a href=\"https://leetcode-cn.com/problems/redundant-connection\">链接</a></p>\n<h2 id=\"解法思路\"><a href=\"#解法思路\" class=\"headerlink\" title=\"解法思路\"></a>解法思路</h2><p>按照查并集的思路去解题就好了</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findRedundantConnection</span>(<span class=\"params\">edges: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = edges.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(len + <span class=\"number\">1</span>), <span class=\"function\">(<span class=\"params\">val, index</span>) =&gt;</span> index)</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ node1, node2 ] = edges[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">find</span>(parent, node1) !== <span class=\"title function_\">find</span>(parent, node2)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">union</span>(parent, node1, node2)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> edges[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">find</span>(<span class=\"params\">parent, node</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent[node] === node ? node : parent[node] = <span class=\"title function_\">find</span>(parent, parent[node])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">union</span>(<span class=\"params\">parent, node1, node2</span>) &#123;</span><br><span class=\"line\">  parent[<span class=\"title function_\">find</span>(parent, node1)] = <span class=\"title function_\">find</span>(parent, node2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 671. 二叉树中第二小的节点\n\n给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。\n\n更正式地说，root.val = min(root.left.val, root.right.val) 总成立。\n\n给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。\n\n[链接](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction findSecondMinimumValue(root: TreeNode | null): number {\n  function traverse(node: TreeNode | null, min: number): number {\n    if (node === null) return -1\n    if (node.val > min) return node.val\n    let l = traverse(node.left, min)\n    let r = traverse(node.right, min)\n    if (l === -1) return r\n    if (r === -1) return l\n    return Math.min(l, r)\n  }\n  return traverse(root, root.val)\n};\n```\n","source":"leetcode/二叉树/671.二叉树中第二小的节点.md","raw":"# 671. 二叉树中第二小的节点\n\n给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。\n\n更正式地说，root.val = min(root.left.val, root.right.val) 总成立。\n\n给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。\n\n[链接](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction findSecondMinimumValue(root: TreeNode | null): number {\n  function traverse(node: TreeNode | null, min: number): number {\n    if (node === null) return -1\n    if (node.val > min) return node.val\n    let l = traverse(node.left, min)\n    let r = traverse(node.right, min)\n    if (l === -1) return r\n    if (r === -1) return l\n    return Math.min(l, r)\n  }\n  return traverse(root, root.val)\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.567Z","path":"leetcode/二叉树/671.二叉树中第二小的节点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002rtnw7cx76gorb","content":"<h1 id=\"671-二叉树中第二小的节点\"><a href=\"#671-二叉树中第二小的节点\" class=\"headerlink\" title=\"671. 二叉树中第二小的节点\"></a>671. 二叉树中第二小的节点</h1><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>\n<p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p>\n<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findSecondMinimumValue</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, min: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt; min) <span class=\"keyword\">return</span> node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>, min)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>, min)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l === -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> r</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r === -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> l</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(l, r)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root, root.<span class=\"property\">val</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"671-二叉树中第二小的节点\"><a href=\"#671-二叉树中第二小的节点\" class=\"headerlink\" title=\"671. 二叉树中第二小的节点\"></a>671. 二叉树中第二小的节点</h1><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>\n<p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p>\n<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findSecondMinimumValue</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, min: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt; min) <span class=\"keyword\">return</span> node.<span class=\"property\">val</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">left</span>, min)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = <span class=\"title function_\">traverse</span>(node.<span class=\"property\">right</span>, min)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l === -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> r</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r === -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> l</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(l, r)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root, root.<span class=\"property\">val</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 685. 冗余连接 II\n\n在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。\n\n输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。\n\n返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n[链接](https://leetcode-cn.com/problems/redundant-connection-ii)\n\n```ts\nfunction findRedundantDirectedConnection(edges: number[][]): number[] {\n  if (edges.length === 0) return []\n  const len = edges.length\n  const parent = Array(len + 1).fill(0)\n  console.log(parent)\n  // 旧边存放处\n  const candidate1 = []\n  // 新边存放处\n  const candidate2 = []\n  for (let i = 0; i < len; i++) {\n    const [ u, v ] = edges[i]\n    console.log(`${u}->${v}`)\n    if (parent[v] === 0) {\n      parent[v] = u\n      console.log(\"yeah\")\n    } else {\n      candidate1.push(parent[v])\n      candidate1.push(v)\n      candidate2.push(u)\n      candidate2.push(v)\n      edges[i][1] = 0\n    }\n  }\n  console.log(parent)\n  // 开始和上一道题一样查并集\n  for(let i = 0; i < len; i++) {\n    parent[i] = i\n  }\n  \n  for(let i = 0; i < len; i++) {\n    const [ u, v ] = edges[i]\n    if (v === 0) continue\n    const root = find(parent, u)\n    // 如果通过u找到的根节点与v相同，则表明形成了环\n    if (root === v) {\n      // 没有入度为2的情况，即叶结点直接连在根节点上，所以直接删除就好了\n      if (candidate1.length === 0) {\n        return edges[i]\n      }\n      // 旧边有环，把旧边输出\n      return candidate1\n    }\n    // 合并\n    parent[v] = root\n  }\n\n  // 旧边形成的树没有形成环，那就是新的边有问题\n  return candidate2\n};\n\nfunction find(parent: number[], index: number): number {\n  if (parent[index] !== index) {\n    parent[index] = find(parent, parent[index])\n  }\n  return parent[index]\n}\n```\n","source":"leetcode/二叉树/685.冗余连接II.md","raw":"# 685. 冗余连接 II\n\n在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。\n\n输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。\n\n返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n[链接](https://leetcode-cn.com/problems/redundant-connection-ii)\n\n```ts\nfunction findRedundantDirectedConnection(edges: number[][]): number[] {\n  if (edges.length === 0) return []\n  const len = edges.length\n  const parent = Array(len + 1).fill(0)\n  console.log(parent)\n  // 旧边存放处\n  const candidate1 = []\n  // 新边存放处\n  const candidate2 = []\n  for (let i = 0; i < len; i++) {\n    const [ u, v ] = edges[i]\n    console.log(`${u}->${v}`)\n    if (parent[v] === 0) {\n      parent[v] = u\n      console.log(\"yeah\")\n    } else {\n      candidate1.push(parent[v])\n      candidate1.push(v)\n      candidate2.push(u)\n      candidate2.push(v)\n      edges[i][1] = 0\n    }\n  }\n  console.log(parent)\n  // 开始和上一道题一样查并集\n  for(let i = 0; i < len; i++) {\n    parent[i] = i\n  }\n  \n  for(let i = 0; i < len; i++) {\n    const [ u, v ] = edges[i]\n    if (v === 0) continue\n    const root = find(parent, u)\n    // 如果通过u找到的根节点与v相同，则表明形成了环\n    if (root === v) {\n      // 没有入度为2的情况，即叶结点直接连在根节点上，所以直接删除就好了\n      if (candidate1.length === 0) {\n        return edges[i]\n      }\n      // 旧边有环，把旧边输出\n      return candidate1\n    }\n    // 合并\n    parent[v] = root\n  }\n\n  // 旧边形成的树没有形成环，那就是新的边有问题\n  return candidate2\n};\n\nfunction find(parent: number[], index: number): number {\n  if (parent[index] !== index) {\n    parent[index] = find(parent, parent[index])\n  }\n  return parent[index]\n}\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.567Z","path":"leetcode/二叉树/685.冗余连接II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002stnw7101x5en7","content":"<h1 id=\"685-冗余连接-II\"><a href=\"#685-冗余连接-II\" class=\"headerlink\" title=\"685. 冗余连接 II\"></a>685. 冗余连接 II</h1><p>在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>\n<p>输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>\n<p>结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。</p>\n<p>返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>\n<p><a href=\"https://leetcode-cn.com/problems/redundant-connection-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findRedundantDirectedConnection</span>(<span class=\"params\">edges: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (edges.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = edges.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = <span class=\"title class_\">Array</span>(len + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(parent)</span><br><span class=\"line\">  <span class=\"comment\">// 旧边存放处</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> candidate1 = []</span><br><span class=\"line\">  <span class=\"comment\">// 新边存放处</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> candidate2 = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ u, v ] = edges[i]</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;u&#125;</span>-&gt;<span class=\"subst\">$&#123;v&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[v] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      parent[v] = u</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;yeah&quot;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      candidate1.<span class=\"title function_\">push</span>(parent[v])</span><br><span class=\"line\">      candidate1.<span class=\"title function_\">push</span>(v)</span><br><span class=\"line\">      candidate2.<span class=\"title function_\">push</span>(u)</span><br><span class=\"line\">      candidate2.<span class=\"title function_\">push</span>(v)</span><br><span class=\"line\">      edges[i][<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(parent)</span><br><span class=\"line\">  <span class=\"comment\">// 开始和上一道题一样查并集</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    parent[i] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ u, v ] = edges[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v === <span class=\"number\">0</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"title function_\">find</span>(parent, u)</span><br><span class=\"line\">    <span class=\"comment\">// 如果通过u找到的根节点与v相同，则表明形成了环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === v) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 没有入度为2的情况，即叶结点直接连在根节点上，所以直接删除就好了</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (candidate1.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> edges[i]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 旧边有环，把旧边输出</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> candidate1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 合并</span></span><br><span class=\"line\">    parent[v] = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 旧边形成的树没有形成环，那就是新的边有问题</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> candidate2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">find</span>(<span class=\"params\">parent: <span class=\"built_in\">number</span>[], index: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent[index] !== index) &#123;</span><br><span class=\"line\">    parent[index] = <span class=\"title function_\">find</span>(parent, parent[index])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent[index]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"685-冗余连接-II\"><a href=\"#685-冗余连接-II\" class=\"headerlink\" title=\"685. 冗余连接 II\"></a>685. 冗余连接 II</h1><p>在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>\n<p>输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>\n<p>结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。</p>\n<p>返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>\n<p><a href=\"https://leetcode-cn.com/problems/redundant-connection-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findRedundantDirectedConnection</span>(<span class=\"params\">edges: <span class=\"built_in\">number</span>[][]</span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (edges.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = edges.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> parent = <span class=\"title class_\">Array</span>(len + <span class=\"number\">1</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(parent)</span><br><span class=\"line\">  <span class=\"comment\">// 旧边存放处</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> candidate1 = []</span><br><span class=\"line\">  <span class=\"comment\">// 新边存放处</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> candidate2 = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ u, v ] = edges[i]</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;u&#125;</span>-&gt;<span class=\"subst\">$&#123;v&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[v] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      parent[v] = u</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;yeah&quot;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      candidate1.<span class=\"title function_\">push</span>(parent[v])</span><br><span class=\"line\">      candidate1.<span class=\"title function_\">push</span>(v)</span><br><span class=\"line\">      candidate2.<span class=\"title function_\">push</span>(u)</span><br><span class=\"line\">      candidate2.<span class=\"title function_\">push</span>(v)</span><br><span class=\"line\">      edges[i][<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(parent)</span><br><span class=\"line\">  <span class=\"comment\">// 开始和上一道题一样查并集</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    parent[i] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [ u, v ] = edges[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v === <span class=\"number\">0</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"title function_\">find</span>(parent, u)</span><br><span class=\"line\">    <span class=\"comment\">// 如果通过u找到的根节点与v相同，则表明形成了环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === v) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 没有入度为2的情况，即叶结点直接连在根节点上，所以直接删除就好了</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (candidate1.<span class=\"property\">length</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> edges[i]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 旧边有环，把旧边输出</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> candidate1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 合并</span></span><br><span class=\"line\">    parent[v] = root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 旧边形成的树没有形成环，那就是新的边有问题</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> candidate2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">find</span>(<span class=\"params\">parent: <span class=\"built_in\">number</span>[], index: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent[index] !== index) &#123;</span><br><span class=\"line\">    parent[index] = <span class=\"title function_\">find</span>(parent, parent[index])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent[index]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 687. 最长同值路径\n\n给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。\n\n注意：两个节点之间的路径长度由它们之间的边数表示。\n\n[链接](https://leetcode-cn.com/problems/longest-univalue-path/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction longestUnivaluePath(root: TreeNode | null): number {\n let res = 0\n if (root === null) return res\n function dfs(node: TreeNode | null) {\n  if (node === null) return 0\n  const l = dfs(node.left)\n  const r = dfs(node.right)\n  let lRes = 0, rRes = 0\n  if(node.left && node.left.val === node.val) {\n    lRes = l + 1\n  }\n  if (node.right && node.right.val == node.val) {\n    rRes = r + 1\n  }\n  res = Math.max(res, rRes + lRes)\n  return Math.max(rRes, lRes)\n }\n dfs(root)\n return res\n};\n```\n","source":"leetcode/二叉树/687.最长同值路径.md","raw":"# 687. 最长同值路径\n\n给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。\n\n注意：两个节点之间的路径长度由它们之间的边数表示。\n\n[链接](https://leetcode-cn.com/problems/longest-univalue-path/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction longestUnivaluePath(root: TreeNode | null): number {\n let res = 0\n if (root === null) return res\n function dfs(node: TreeNode | null) {\n  if (node === null) return 0\n  const l = dfs(node.left)\n  const r = dfs(node.right)\n  let lRes = 0, rRes = 0\n  if(node.left && node.left.val === node.val) {\n    lRes = l + 1\n  }\n  if (node.right && node.right.val == node.val) {\n    rRes = r + 1\n  }\n  res = Math.max(res, rRes + lRes)\n  return Math.max(rRes, lRes)\n }\n dfs(root)\n return res\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.567Z","path":"leetcode/二叉树/687.最长同值路径.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002ttnw702yt54wd","content":"<h1 id=\"687-最长同值路径\"><a href=\"#687-最长同值路径\" class=\"headerlink\" title=\"687. 最长同值路径\"></a>687. 最长同值路径</h1><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>\n<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-univalue-path/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">longestUnivaluePath</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\"> <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lRes = <span class=\"number\">0</span>, rRes = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(node.<span class=\"property\">left</span> &amp;&amp; node.<span class=\"property\">left</span>.<span class=\"property\">val</span> === node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    lRes = l + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span> &amp;&amp; node.<span class=\"property\">right</span>.<span class=\"property\">val</span> == node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    rRes = r + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(res, rRes + lRes)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rRes, lRes)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"687-最长同值路径\"><a href=\"#687-最长同值路径\" class=\"headerlink\" title=\"687. 最长同值路径\"></a>687. 最长同值路径</h1><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>\n<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-univalue-path/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">longestUnivaluePath</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res</span><br><span class=\"line\"> <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lRes = <span class=\"number\">0</span>, rRes = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(node.<span class=\"property\">left</span> &amp;&amp; node.<span class=\"property\">left</span>.<span class=\"property\">val</span> === node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    lRes = l + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span> &amp;&amp; node.<span class=\"property\">right</span>.<span class=\"property\">val</span> == node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">    rRes = r + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(res, rRes + lRes)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rRes, lRes)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 701. 二叉搜索树中的插入操作\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n\n[链接](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction insertIntoBST(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) {\n    return new TreeNode(val);\n  }\n  let p = root\n  while(p !== null) {\n    if(p.val > val) {\n      if (p.left === null) {\n        p.left = new TreeNode(val)\n        break\n      } else {\n        p = p.left\n      }\n    } else {\n      if (p.right === null) {\n        p.right = new TreeNode(val)\n        break\n      } else {\n        p = p.right\n      }\n    }\n  }\n  return root\n};\n```\n","source":"leetcode/二叉树/701.二叉搜索树中的插入操作.md","raw":"# 701. 二叉搜索树中的插入操作\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n\n[链接](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction insertIntoBST(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) {\n    return new TreeNode(val);\n  }\n  let p = root\n  while(p !== null) {\n    if(p.val > val) {\n      if (p.left === null) {\n        p.left = new TreeNode(val)\n        break\n      } else {\n        p = p.left\n      }\n    } else {\n      if (p.right === null) {\n        p.right = new TreeNode(val)\n        break\n      } else {\n        p = p.right\n      }\n    }\n  }\n  return root\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.568Z","path":"leetcode/二叉树/701.二叉搜索树中的插入操作.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002utnw77eyg37p8","content":"<h1 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701. 二叉搜索树中的插入操作\"></a>701. 二叉搜索树中的插入操作</h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">insertIntoBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = root</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p.<span class=\"property\">val</span> &gt; val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p.<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p = p.<span class=\"property\">left</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p = p.<span class=\"property\">right</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701. 二叉搜索树中的插入操作\"></a>701. 二叉搜索树中的插入操作</h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">insertIntoBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = root</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p.<span class=\"property\">val</span> &gt; val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p.<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p = p.<span class=\"property\">left</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p = p.<span class=\"property\">right</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 863. 二叉树中所有距离为 K 的结点\n\n给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。\n\n返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。\n\n[链接](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree)\n\n## tips\n\n用图来解就好了\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} k\n * @return {number[]}\n */\nvar distanceK = function(root, target, k) {\n  const res = []\n  if (root === null) return root\n  const nodeQue = [root]\n  let findTarget = null\n  while(nodeQue.length > 0) {\n    const node = nodeQue.shift()\n    if (node === target) {\n      findTarget = node\n      break\n    }\n    if (node.left) {\n      node.left.parent = node\n      nodeQue.push(node.left)\n    }\n    if (node.right) {\n      node.right.parent = node\n      nodeQue.push(node.right)\n    }\n  }\n  function dfs(node, depth) {\n    if (node === null || node.isRead) return\n    node.isRead = true\n    if (depth === k) {\n      res.push(node.val)\n      return\n    }\n    node.parent && dfs(node.parent, depth + 1)\n    dfs(node.left, depth + 1)\n    dfs(node.right, depth + 1)\n  }\n  dfs(findTarget, 0)\n  return res\n};\n```\n","source":"leetcode/二叉树/863.二叉树中所有距离为K的结点.md","raw":"# 863. 二叉树中所有距离为 K 的结点\n\n给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。\n\n返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。\n\n[链接](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree)\n\n## tips\n\n用图来解就好了\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} k\n * @return {number[]}\n */\nvar distanceK = function(root, target, k) {\n  const res = []\n  if (root === null) return root\n  const nodeQue = [root]\n  let findTarget = null\n  while(nodeQue.length > 0) {\n    const node = nodeQue.shift()\n    if (node === target) {\n      findTarget = node\n      break\n    }\n    if (node.left) {\n      node.left.parent = node\n      nodeQue.push(node.left)\n    }\n    if (node.right) {\n      node.right.parent = node\n      nodeQue.push(node.right)\n    }\n  }\n  function dfs(node, depth) {\n    if (node === null || node.isRead) return\n    node.isRead = true\n    if (depth === k) {\n      res.push(node.val)\n      return\n    }\n    node.parent && dfs(node.parent, depth + 1)\n    dfs(node.left, depth + 1)\n    dfs(node.right, depth + 1)\n  }\n  dfs(findTarget, 0)\n  return res\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.568Z","path":"leetcode/二叉树/863.二叉树中所有距离为K的结点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002vtnw7438oesb4","content":"<h1 id=\"863-二叉树中所有距离为-K-的结点\"><a href=\"#863-二叉树中所有距离为-K-的结点\" class=\"headerlink\" title=\"863. 二叉树中所有距离为 K 的结点\"></a>863. 二叉树中所有距离为 K 的结点</h1><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>\n<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>\n<p><a href=\"https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree\">链接</a></p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><p>用图来解就好了</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = this.right = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">target</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">k</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> distanceK = <span class=\"keyword\">function</span>(<span class=\"params\">root, target, k</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQue = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> findTarget = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = nodeQue.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === target) &#123;</span><br><span class=\"line\">      findTarget = node</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">      nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">      nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node, depth</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span> || node.<span class=\"property\">isRead</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    node.<span class=\"property\">isRead</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth === k) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node.<span class=\"property\">parent</span> &amp;&amp; <span class=\"title function_\">dfs</span>(node.<span class=\"property\">parent</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(findTarget, <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"863-二叉树中所有距离为-K-的结点\"><a href=\"#863-二叉树中所有距离为-K-的结点\" class=\"headerlink\" title=\"863. 二叉树中所有距离为 K 的结点\"></a>863. 二叉树中所有距离为 K 的结点</h1><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>\n<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>\n<p><a href=\"https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree\">链接</a></p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><p>用图来解就好了</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = this.right = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">target</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">k</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> distanceK = <span class=\"keyword\">function</span>(<span class=\"params\">root, target, k</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQue = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> findTarget = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = nodeQue.<span class=\"title function_\">shift</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === target) &#123;</span><br><span class=\"line\">      findTarget = node</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">      nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">      nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node, depth</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span> || node.<span class=\"property\">isRead</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    node.<span class=\"property\">isRead</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth === k) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node.<span class=\"property\">parent</span> &amp;&amp; <span class=\"title function_\">dfs</span>(node.<span class=\"property\">parent</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(findTarget, <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 700. 二叉搜索树中的搜索\n\n给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。\n\n[链接](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction searchBST(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) return null\n  return (root.val === val ? root : null) || searchBST(root.left, val) || searchBST(root.right, val)\n};\n```\n","source":"leetcode/二叉树/700.二叉搜索树中的搜索.md","raw":"# 700. 二叉搜索树中的搜索\n\n给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。\n\n[链接](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction searchBST(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) return null\n  return (root.val === val ? root : null) || searchBST(root.left, val) || searchBST(root.right, val)\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.567Z","path":"leetcode/二叉树/700.二叉搜索树中的搜索.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002wtnw744vgc06d","content":"<h1 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700. 二叉搜索树中的搜索\"></a>700. 二叉搜索树中的搜索</h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>\n<p><a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">searchBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (root.<span class=\"property\">val</span> === val ? root : <span class=\"literal\">null</span>) || <span class=\"title function_\">searchBST</span>(root.<span class=\"property\">left</span>, val) || <span class=\"title function_\">searchBST</span>(root.<span class=\"property\">right</span>, val)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700. 二叉搜索树中的搜索\"></a>700. 二叉搜索树中的搜索</h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>\n<p><a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">searchBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (root.<span class=\"property\">val</span> === val ? root : <span class=\"literal\">null</span>) || <span class=\"title function_\">searchBST</span>(root.<span class=\"property\">left</span>, val) || <span class=\"title function_\">searchBST</span>(root.<span class=\"property\">right</span>, val)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 814. 二叉树剪枝\n\n给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。\n\n返回移除了所有不包含 1 的子树的原二叉树。\n\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n\n[链接](https://leetcode-cn.com/problems/binary-tree-pruning)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pruneTree(root: TreeNode | null): TreeNode | null {\n  function dfs(node: TreeNode | null): boolean {\n    if (node === null) return false\n    const l = dfs(node.left)\n    const r = dfs(node.right)\n    if (!l) node.left = null\n    if (!r) node.right = null\n    return node.val === 1 || l || r\n  }\n  const res = dfs(root)\n  return res ? root : null\n};\n```\n","source":"leetcode/二叉树/814.二叉树剪枝.md","raw":"# 814. 二叉树剪枝\n\n给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。\n\n返回移除了所有不包含 1 的子树的原二叉树。\n\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n\n[链接](https://leetcode-cn.com/problems/binary-tree-pruning)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pruneTree(root: TreeNode | null): TreeNode | null {\n  function dfs(node: TreeNode | null): boolean {\n    if (node === null) return false\n    const l = dfs(node.left)\n    const r = dfs(node.right)\n    if (!l) node.left = null\n    if (!r) node.right = null\n    return node.val === 1 || l || r\n  }\n  const res = dfs(root)\n  return res ? root : null\n};\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.568Z","path":"leetcode/二叉树/814.二叉树剪枝.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002xtnw7flea09cb","content":"<h1 id=\"814-二叉树剪枝\"><a href=\"#814-二叉树剪枝\" class=\"headerlink\" title=\"814. 二叉树剪枝\"></a>814. 二叉树剪枝</h1><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p>\n<p>返回移除了所有不包含 1 的子树的原二叉树。</p>\n<p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-pruning\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pruneTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!l) node.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!r) node.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.<span class=\"property\">val</span> === <span class=\"number\">1</span> || l || r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? root : <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"814-二叉树剪枝\"><a href=\"#814-二叉树剪枝\" class=\"headerlink\" title=\"814. 二叉树剪枝\"></a>814. 二叉树剪枝</h1><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p>\n<p>返回移除了所有不包含 1 的子树的原二叉树。</p>\n<p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-pruning\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pruneTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!l) node.<span class=\"property\">left</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!r) node.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.<span class=\"property\">val</span> === <span class=\"number\">1</span> || l || r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? root : <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 703. 数据流中的第 K 大元素\n\n设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。\n\n请实现 KthLargest 类：\n\n- KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。\n- int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。\n\n[链接](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream)\n\n## Tips\n\n求TopK的问题可以用大堆根或者小堆根来解决问题\n\n[最小堆](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372?fr=aladdin)\n\n- 题目中要求求出第K个大的元素，那么用小堆根就可以一直保持数组的第一个值为第K大个数\n\n- 数组index与树位置的对应关系可以用一下以下公式来计算\n\n  - 父节点：(index - 1) / 2\n  \n  - 左子点：index * 2 + 1\n\n  - 右子点：index * 2 + 2\n\n```ts\nclass KthLargest {\n  k: number = -1;\n  heap = new minHeap();\n  constructor(k: number, nums: number[]) {\n    this.k = k;\n    for (const x of nums) {\n      this.add(x);\n    }\n  }\n\n  add(val: number): number {\n    this.heap.offer(val)\n    if (this.heap.size() > this.k) {\n      this.heap.poll()\n    }\n    console.log(this.heap.data)\n    return this.heap.peek()\n  }\n}\n\nclass minHeap {\n  data: number[] = [];\n  constructor(data = []) {\n    this.data = data;\n    this.heapify();\n  }\n  comparator(a: number, b: number): number {\n    return a - b;\n  }\n\n  heapify() {\n    if (this.size() < 2) return;\n    for(let i = 1; i < this.size(); i++) {\n      this.bubbleUp(i);\n    }\n    console.log(this.data)\n  }\n\n  peek() {\n    if (this.size() === 0) return null\n    return this.data[0]\n  }\n\n  offer(value) {\n    this.data.push(value)\n    this.bubbleUp(this.size() - 1)\n  }\n\n  poll() {\n    if (this.size() === 0) {\n      return null\n    }\n    const result = this.data[0]\n    const last = this.data.pop()\n    if (this.size() !== 0) {\n      this.data[0] = last\n      this.bubbleDown(0)\n    }\n    return result\n  }\n\n  swap(index1: number, index2: number) {\n    [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]]\n  }\n\n  bubbleUp(index: number) {\n    while(index > 0) {\n      const parentIndex = (index - 1) >> 1\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\n        this.swap(index, parentIndex)\n        index = parentIndex\n      } else {\n        break\n      }\n    }\n  }\n\n  bubbleDown(index: number) {\n    const lastIndex = this.size() - 1\n    while(true) {\n      const leftIndex = index * 2 + 1\n      const rightIndex = index * 2 + 2\n      let findIndex = index\n      if (leftIndex <= lastIndex && this.comparator(this.data[leftIndex], this.data[findIndex]) < 0) {\n        findIndex = leftIndex\n      }\n      if (rightIndex <= lastIndex && this.comparator(this.data[rightIndex], this.data[findIndex]) < 0) {\n        findIndex = rightIndex\n      }\n      if (index !== findIndex) {\n        this.swap(index, findIndex)\n        index = findIndex\n      } else {\n        break\n      }\n    }\n  }\n\n  size() {\n    return this.data.length\n  }\n}\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * var obj = new KthLargest(k, nums)\n * var param_1 = obj.add(val)\n */\n```\n","source":"leetcode/二叉树/703.数据流中的第K大元素.md","raw":"# 703. 数据流中的第 K 大元素\n\n设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。\n\n请实现 KthLargest 类：\n\n- KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。\n- int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。\n\n[链接](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream)\n\n## Tips\n\n求TopK的问题可以用大堆根或者小堆根来解决问题\n\n[最小堆](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372?fr=aladdin)\n\n- 题目中要求求出第K个大的元素，那么用小堆根就可以一直保持数组的第一个值为第K大个数\n\n- 数组index与树位置的对应关系可以用一下以下公式来计算\n\n  - 父节点：(index - 1) / 2\n  \n  - 左子点：index * 2 + 1\n\n  - 右子点：index * 2 + 2\n\n```ts\nclass KthLargest {\n  k: number = -1;\n  heap = new minHeap();\n  constructor(k: number, nums: number[]) {\n    this.k = k;\n    for (const x of nums) {\n      this.add(x);\n    }\n  }\n\n  add(val: number): number {\n    this.heap.offer(val)\n    if (this.heap.size() > this.k) {\n      this.heap.poll()\n    }\n    console.log(this.heap.data)\n    return this.heap.peek()\n  }\n}\n\nclass minHeap {\n  data: number[] = [];\n  constructor(data = []) {\n    this.data = data;\n    this.heapify();\n  }\n  comparator(a: number, b: number): number {\n    return a - b;\n  }\n\n  heapify() {\n    if (this.size() < 2) return;\n    for(let i = 1; i < this.size(); i++) {\n      this.bubbleUp(i);\n    }\n    console.log(this.data)\n  }\n\n  peek() {\n    if (this.size() === 0) return null\n    return this.data[0]\n  }\n\n  offer(value) {\n    this.data.push(value)\n    this.bubbleUp(this.size() - 1)\n  }\n\n  poll() {\n    if (this.size() === 0) {\n      return null\n    }\n    const result = this.data[0]\n    const last = this.data.pop()\n    if (this.size() !== 0) {\n      this.data[0] = last\n      this.bubbleDown(0)\n    }\n    return result\n  }\n\n  swap(index1: number, index2: number) {\n    [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]]\n  }\n\n  bubbleUp(index: number) {\n    while(index > 0) {\n      const parentIndex = (index - 1) >> 1\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\n        this.swap(index, parentIndex)\n        index = parentIndex\n      } else {\n        break\n      }\n    }\n  }\n\n  bubbleDown(index: number) {\n    const lastIndex = this.size() - 1\n    while(true) {\n      const leftIndex = index * 2 + 1\n      const rightIndex = index * 2 + 2\n      let findIndex = index\n      if (leftIndex <= lastIndex && this.comparator(this.data[leftIndex], this.data[findIndex]) < 0) {\n        findIndex = leftIndex\n      }\n      if (rightIndex <= lastIndex && this.comparator(this.data[rightIndex], this.data[findIndex]) < 0) {\n        findIndex = rightIndex\n      }\n      if (index !== findIndex) {\n        this.swap(index, findIndex)\n        index = findIndex\n      } else {\n        break\n      }\n    }\n  }\n\n  size() {\n    return this.data.length\n  }\n}\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * var obj = new KthLargest(k, nums)\n * var param_1 = obj.add(val)\n */\n```\n","date":"2023-10-11T15:10:43.208Z","updated":"2023-09-26T14:49:23.568Z","path":"leetcode/二叉树/703.数据流中的第K大元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002ytnw7f6j2fhv2","content":"<h1 id=\"703-数据流中的第-K-大元素\"><a href=\"#703-数据流中的第-K-大元素\" class=\"headerlink\" title=\"703. 数据流中的第 K 大元素\"></a>703. 数据流中的第 K 大元素</h1><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>\n<p>请实现 KthLargest 类：</p>\n<ul>\n<li>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。</li>\n<li>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-a-stream\">链接</a></p>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><p>求TopK的问题可以用大堆根或者小堆根来解决问题</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372?fr=aladdin\">最小堆</a></p>\n<ul>\n<li><p>题目中要求求出第K个大的元素，那么用小堆根就可以一直保持数组的第一个值为第K大个数</p>\n</li>\n<li><p>数组index与树位置的对应关系可以用一下以下公式来计算</p>\n<ul>\n<li><p>父节点：(index - 1) / 2</p>\n</li>\n<li><p>左子点：index * 2 + 1</p>\n</li>\n<li><p>右子点：index * 2 + 2</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KthLargest</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">k</span>: <span class=\"built_in\">number</span> = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  heap = <span class=\"keyword\">new</span> <span class=\"title function_\">minHeap</span>();</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">k: <span class=\"built_in\">number</span>, nums: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">k</span> = k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">add</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">add</span>(<span class=\"attr\">val</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">offer</span>(val)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">size</span>() &gt; <span class=\"variable language_\">this</span>.<span class=\"property\">k</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">poll</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">data</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">peek</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">minHeap</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">data = []</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = data;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">heapify</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">comparator</span>(<span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">heapify</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>(); i++) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">bubbleUp</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">peek</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">offer</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"title function_\">push</span>(value)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">bubbleUp</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">poll</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> last = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[<span class=\"number\">0</span>] = last</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">bubbleDown</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">swap</span>(<span class=\"params\">index1: <span class=\"built_in\">number</span>, index2: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index1], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index2]] = [<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index2], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index1]]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">bubbleUp</span>(<span class=\"params\">index: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(index &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parentIndex = (index - <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">comparator</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[parentIndex]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">swap</span>(index, parentIndex)</span><br><span class=\"line\">        index = parentIndex</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">bubbleDown</span>(<span class=\"params\">index: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lastIndex = <span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> leftIndex = index * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> rightIndex = index * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> findIndex = index</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (leftIndex &lt;= lastIndex &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"title function_\">comparator</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[leftIndex], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[findIndex]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        findIndex = leftIndex</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightIndex &lt;= lastIndex &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"title function_\">comparator</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[rightIndex], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[findIndex]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        findIndex = rightIndex</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index !== findIndex) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">swap</span>(index, findIndex)</span><br><span class=\"line\">        index = findIndex</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">size</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">length</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new KthLargest(k, nums)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.add(val)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"703-数据流中的第-K-大元素\"><a href=\"#703-数据流中的第-K-大元素\" class=\"headerlink\" title=\"703. 数据流中的第 K 大元素\"></a>703. 数据流中的第 K 大元素</h1><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>\n<p>请实现 KthLargest 类：</p>\n<ul>\n<li>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。</li>\n<li>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-a-stream\">链接</a></p>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><p>求TopK的问题可以用大堆根或者小堆根来解决问题</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86/9139372?fr=aladdin\">最小堆</a></p>\n<ul>\n<li><p>题目中要求求出第K个大的元素，那么用小堆根就可以一直保持数组的第一个值为第K大个数</p>\n</li>\n<li><p>数组index与树位置的对应关系可以用一下以下公式来计算</p>\n<ul>\n<li><p>父节点：(index - 1) / 2</p>\n</li>\n<li><p>左子点：index * 2 + 1</p>\n</li>\n<li><p>右子点：index * 2 + 2</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KthLargest</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">k</span>: <span class=\"built_in\">number</span> = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  heap = <span class=\"keyword\">new</span> <span class=\"title function_\">minHeap</span>();</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">k: <span class=\"built_in\">number</span>, nums: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">k</span> = k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">add</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">add</span>(<span class=\"attr\">val</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">offer</span>(val)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">size</span>() &gt; <span class=\"variable language_\">this</span>.<span class=\"property\">k</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">poll</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">data</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">peek</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">minHeap</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"built_in\">number</span>[] = [];</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">data = []</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = data;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">heapify</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">comparator</span>(<span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">heapify</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>(); i++) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">bubbleUp</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">peek</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">offer</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"title function_\">push</span>(value)</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">bubbleUp</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">poll</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> last = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[<span class=\"number\">0</span>] = last</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">bubbleDown</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">swap</span>(<span class=\"params\">index1: <span class=\"built_in\">number</span>, index2: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index1], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index2]] = [<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index2], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index1]]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">bubbleUp</span>(<span class=\"params\">index: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(index &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parentIndex = (index - <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">comparator</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[index], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[parentIndex]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">swap</span>(index, parentIndex)</span><br><span class=\"line\">        index = parentIndex</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">bubbleDown</span>(<span class=\"params\">index: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lastIndex = <span class=\"variable language_\">this</span>.<span class=\"title function_\">size</span>() - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> leftIndex = index * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> rightIndex = index * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> findIndex = index</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (leftIndex &lt;= lastIndex &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"title function_\">comparator</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[leftIndex], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[findIndex]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        findIndex = leftIndex</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightIndex &lt;= lastIndex &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"title function_\">comparator</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[rightIndex], <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[findIndex]) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        findIndex = rightIndex</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index !== findIndex) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">swap</span>(index, findIndex)</span><br><span class=\"line\">        index = findIndex</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">size</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">length</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new KthLargest(k, nums)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.add(val)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 865. 具有所有最深节点的最小子树\n\n给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。\n\n如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。\n\n一个节点的 子树 是该节点加上它的所有后代的集合。\n\n返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。\n\n[链接](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\ntype Smallest = {\n  node: TreeNode | null;\n  depth: number\n}\n\n\nfunction subtreeWithAllDeepest(root: TreeNode | null): TreeNode | null {\n  function dfs(node: TreeNode | null): Smallest {\n    if (node === null) return { node: null, depth: 0 }\n    const l = dfs(node.left)\n    const r = dfs(node.right)\n    if (l.depth > r.depth) return { node: l.node, depth: l.depth + 1 }\n    if (l.depth < r.depth) return { node: r.node, depth: r.depth + 1 }\n    return { node: node, depth: l.depth + 1 }\n  }\n  return dfs(root).node\n};\n```\n","source":"leetcode/二叉树/865.具有所有最深节点的最小子树.md","raw":"# 865. 具有所有最深节点的最小子树\n\n给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。\n\n如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。\n\n一个节点的 子树 是该节点加上它的所有后代的集合。\n\n返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。\n\n[链接](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\ntype Smallest = {\n  node: TreeNode | null;\n  depth: number\n}\n\n\nfunction subtreeWithAllDeepest(root: TreeNode | null): TreeNode | null {\n  function dfs(node: TreeNode | null): Smallest {\n    if (node === null) return { node: null, depth: 0 }\n    const l = dfs(node.left)\n    const r = dfs(node.right)\n    if (l.depth > r.depth) return { node: l.node, depth: l.depth + 1 }\n    if (l.depth < r.depth) return { node: r.node, depth: r.depth + 1 }\n    return { node: node, depth: l.depth + 1 }\n  }\n  return dfs(root).node\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.569Z","path":"leetcode/二叉树/865.具有所有最深节点的最小子树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs002ztnw7fkcjcjaf","content":"<h1 id=\"865-具有所有最深节点的最小子树\"><a href=\"#865-具有所有最深节点的最小子树\" class=\"headerlink\" title=\"865. 具有所有最深节点的最小子树\"></a>865. 具有所有最深节点的最小子树</h1><p>给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。</p>\n<p>如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。</p>\n<p>一个节点的 子树 是该节点加上它的所有后代的集合。</p>\n<p>返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Smallest</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"attr\">depth</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">subtreeWithAllDeepest</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">Smallest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: <span class=\"literal\">null</span>, <span class=\"attr\">depth</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &gt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: l.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &lt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: r.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: r.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: node, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(root).<span class=\"property\">node</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"865-具有所有最深节点的最小子树\"><a href=\"#865-具有所有最深节点的最小子树\" class=\"headerlink\" title=\"865. 具有所有最深节点的最小子树\"></a>865. 具有所有最深节点的最小子树</h1><p>给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。</p>\n<p>如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。</p>\n<p>一个节点的 子树 是该节点加上它的所有后代的集合。</p>\n<p>返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Smallest</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">node</span>: <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"attr\">depth</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">subtreeWithAllDeepest</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">Smallest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: <span class=\"literal\">null</span>, <span class=\"attr\">depth</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &gt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: l.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l.<span class=\"property\">depth</span> &lt; r.<span class=\"property\">depth</span>) <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: r.<span class=\"property\">node</span>, <span class=\"attr\">depth</span>: r.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">node</span>: node, <span class=\"attr\">depth</span>: l.<span class=\"property\">depth</span> + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(root).<span class=\"property\">node</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 889. 根据前序和后序遍历构造二叉树\n\n返回与给定的前序和后序遍历匹配的任何二叉树。\n\n pre 和 post 遍历中的值是不同的正整数。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction constructFromPrePost(pre: number[], post: number[]): TreeNode | null {\n  function travese(preIndex: number, postIndex: number, N: number) {\n    if (N === 0) return null\n    const root = new TreeNode(pre[preIndex])\n    if (N === 1) return root\n\n    let L = 1\n    const leftRootIndex = preIndex + 1\n    for(; L < N; ++L) {\n      if (post[postIndex + L - 1] === pre[leftRootIndex]) break\n    }\n\n    root.left = travese(leftRootIndex, postIndex, L)\n    root.right = travese(leftRootIndex + L, L + postIndex, N - L - 1)\n    return root\n  }\n  return travese(0, 0, pre.length)\n};\n```\n","source":"leetcode/二叉树/889.根据前序和后序遍历构造二叉树.md","raw":"# 889. 根据前序和后序遍历构造二叉树\n\n返回与给定的前序和后序遍历匹配的任何二叉树。\n\n pre 和 post 遍历中的值是不同的正整数。\n\n[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction constructFromPrePost(pre: number[], post: number[]): TreeNode | null {\n  function travese(preIndex: number, postIndex: number, N: number) {\n    if (N === 0) return null\n    const root = new TreeNode(pre[preIndex])\n    if (N === 1) return root\n\n    let L = 1\n    const leftRootIndex = preIndex + 1\n    for(; L < N; ++L) {\n      if (post[postIndex + L - 1] === pre[leftRootIndex]) break\n    }\n\n    root.left = travese(leftRootIndex, postIndex, L)\n    root.right = travese(leftRootIndex + L, L + postIndex, N - L - 1)\n    return root\n  }\n  return travese(0, 0, pre.length)\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.569Z","path":"leetcode/二叉树/889.根据前序和后序遍历构造二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs0030tnw7ensmeh2y","content":"<h1 id=\"889-根据前序和后序遍历构造二叉树\"><a href=\"#889-根据前序和后序遍历构造二叉树\" class=\"headerlink\" title=\"889. 根据前序和后序遍历构造二叉树\"></a>889. 根据前序和后序遍历构造二叉树</h1><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p>\n<p> pre 和 post 遍历中的值是不同的正整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">constructFromPrePost</span>(<span class=\"params\">pre: <span class=\"built_in\">number</span>[], post: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">travese</span>(<span class=\"params\">preIndex: <span class=\"built_in\">number</span>, postIndex: <span class=\"built_in\">number</span>, N: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(pre[preIndex])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> L = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> leftRootIndex = preIndex + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; L &lt; N; ++L) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (post[postIndex + L - <span class=\"number\">1</span>] === pre[leftRootIndex]) <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root.<span class=\"property\">left</span> = <span class=\"title function_\">travese</span>(leftRootIndex, postIndex, L)</span><br><span class=\"line\">    root.<span class=\"property\">right</span> = <span class=\"title function_\">travese</span>(leftRootIndex + L, L + postIndex, N - L - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">travese</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, pre.<span class=\"property\">length</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"889-根据前序和后序遍历构造二叉树\"><a href=\"#889-根据前序和后序遍历构造二叉树\" class=\"headerlink\" title=\"889. 根据前序和后序遍历构造二叉树\"></a>889. 根据前序和后序遍历构造二叉树</h1><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p>\n<p> pre 和 post 遍历中的值是不同的正整数。</p>\n<p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">constructFromPrePost</span>(<span class=\"params\">pre: <span class=\"built_in\">number</span>[], post: <span class=\"built_in\">number</span>[]</span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">travese</span>(<span class=\"params\">preIndex: <span class=\"built_in\">number</span>, postIndex: <span class=\"built_in\">number</span>, N: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(pre[preIndex])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> L = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> leftRootIndex = preIndex + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; L &lt; N; ++L) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (post[postIndex + L - <span class=\"number\">1</span>] === pre[leftRootIndex]) <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root.<span class=\"property\">left</span> = <span class=\"title function_\">travese</span>(leftRootIndex, postIndex, L)</span><br><span class=\"line\">    root.<span class=\"property\">right</span> = <span class=\"title function_\">travese</span>(leftRootIndex + L, L + postIndex, N - L - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">travese</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, pre.<span class=\"property\">length</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 872. 叶子相似的树\n\n请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。\n\n[链接](https://leetcode-cn.com/problems/leaf-similar-trees/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction leafSimilar(root1: TreeNode | null, root2: TreeNode | null): boolean {\n  const res1: number[] = []\n  const res2: number[] = []\n  function dfs(node: TreeNode | null, res: number[]){\n    if (node === null) return\n    if (node.left === null && node.right === null) {\n      res.push(node.val)\n    }\n    dfs(node.left, res)\n    dfs(node.right, res)\n  }\n  dfs(root1, res1)\n  dfs(root2, res2)\n  return res2.length === res1.length && res2.every((data, index) => data === res1[index])\n};\n```\n","source":"leetcode/二叉树/872.叶子相似的树.md","raw":"# 872. 叶子相似的树\n\n请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。\n\n[链接](https://leetcode-cn.com/problems/leaf-similar-trees/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction leafSimilar(root1: TreeNode | null, root2: TreeNode | null): boolean {\n  const res1: number[] = []\n  const res2: number[] = []\n  function dfs(node: TreeNode | null, res: number[]){\n    if (node === null) return\n    if (node.left === null && node.right === null) {\n      res.push(node.val)\n    }\n    dfs(node.left, res)\n    dfs(node.right, res)\n  }\n  dfs(root1, res1)\n  dfs(root2, res2)\n  return res2.length === res1.length && res2.every((data, index) => data === res1[index])\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.569Z","path":"leetcode/二叉树/872.叶子相似的树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs0031tnw70ggfhbwe","content":"<h1 id=\"872-叶子相似的树\"><a href=\"#872-叶子相似的树\" class=\"headerlink\" title=\"872. 叶子相似的树\"></a>872. 叶子相似的树</h1><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/leaf-similar-trees/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">leafSimilar</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res1</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res2</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, res: <span class=\"built_in\">number</span>[]</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, res)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root1, res1)</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root2, res2)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res2.<span class=\"property\">length</span> === res1.<span class=\"property\">length</span> &amp;&amp; res2.<span class=\"title function_\">every</span>(<span class=\"function\">(<span class=\"params\">data, index</span>) =&gt;</span> data === res1[index])</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"872-叶子相似的树\"><a href=\"#872-叶子相似的树\" class=\"headerlink\" title=\"872. 叶子相似的树\"></a>872. 叶子相似的树</h1><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/leaf-similar-trees/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">leafSimilar</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res1</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">res2</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, res: <span class=\"built_in\">number</span>[]</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span> &amp;&amp; node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">push</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, res)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root1, res1)</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root2, res2)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res2.<span class=\"property\">length</span> === res1.<span class=\"property\">length</span> &amp;&amp; res2.<span class=\"title function_\">every</span>(<span class=\"function\">(<span class=\"params\">data, index</span>) =&gt;</span> data === res1[index])</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 894. 所有可能的满二叉树\n\n满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。\n\n返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。\n\n答案中每个树的每个结点都必须有 node.val=0。\n\n你可以按任何顺序返回树的最终列表。\n\n[链接](https://leetcode-cn.com/problems/all-possible-full-binary-trees)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction allPossibleFBT(n: number): Array<TreeNode | null> {\n  const memoMap: Record<number, TreeNode[]> = {}\n  function dfs(N: number) {\n    const ans: TreeNode[] = []\n    if (!memoMap[N]) {\n      if (N === 1) {\n        ans.push(new TreeNode(0))\n      } else if (N % 2 === 1) {\n        for(let i = 0; i < N; i++) {\n          let y = N - 1 - i\n          for (const left of dfs(i)) {\n            for (const right of dfs(y)) {\n              const b = new TreeNode(0)\n              b.left = left\n              b.right = right\n              ans.push(b)\n            }\n          }\n        }\n      }\n      memoMap[N] = ans\n    }\n    return memoMap[N]\n  }\n  return dfs(n)\n};\n```\n","source":"leetcode/二叉树/894.所有可能的满二叉树.md","raw":"# 894. 所有可能的满二叉树\n\n满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。\n\n返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。\n\n答案中每个树的每个结点都必须有 node.val=0。\n\n你可以按任何顺序返回树的最终列表。\n\n[链接](https://leetcode-cn.com/problems/all-possible-full-binary-trees)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction allPossibleFBT(n: number): Array<TreeNode | null> {\n  const memoMap: Record<number, TreeNode[]> = {}\n  function dfs(N: number) {\n    const ans: TreeNode[] = []\n    if (!memoMap[N]) {\n      if (N === 1) {\n        ans.push(new TreeNode(0))\n      } else if (N % 2 === 1) {\n        for(let i = 0; i < N; i++) {\n          let y = N - 1 - i\n          for (const left of dfs(i)) {\n            for (const right of dfs(y)) {\n              const b = new TreeNode(0)\n              b.left = left\n              b.right = right\n              ans.push(b)\n            }\n          }\n        }\n      }\n      memoMap[N] = ans\n    }\n    return memoMap[N]\n  }\n  return dfs(n)\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.569Z","path":"leetcode/二叉树/894.所有可能的满二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxs0032tnw7198p4arh","content":"<h1 id=\"894-所有可能的满二叉树\"><a href=\"#894-所有可能的满二叉树\" class=\"headerlink\" title=\"894. 所有可能的满二叉树\"></a>894. 所有可能的满二叉树</h1><p>满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。</p>\n<p>返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。</p>\n<p>答案中每个树的每个结点都必须有 node.val=0。</p>\n<p>你可以按任何顺序返回树的最终列表。</p>\n<p><a href=\"https://leetcode-cn.com/problems/all-possible-full-binary-trees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">allPossibleFBT</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">memoMap</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"title class_\">TreeNode</span>[]&gt; = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">N: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">ans</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!memoMap[N]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (N === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ans.<span class=\"title function_\">push</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> y = N - <span class=\"number\">1</span> - i</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> left <span class=\"keyword\">of</span> <span class=\"title function_\">dfs</span>(i)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> right <span class=\"keyword\">of</span> <span class=\"title function_\">dfs</span>(y)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">              b.<span class=\"property\">left</span> = left</span><br><span class=\"line\">              b.<span class=\"property\">right</span> = right</span><br><span class=\"line\">              ans.<span class=\"title function_\">push</span>(b)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      memoMap[N] = ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memoMap[N]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(n)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"894-所有可能的满二叉树\"><a href=\"#894-所有可能的满二叉树\" class=\"headerlink\" title=\"894. 所有可能的满二叉树\"></a>894. 所有可能的满二叉树</h1><p>满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。</p>\n<p>返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。</p>\n<p>答案中每个树的每个结点都必须有 node.val=0。</p>\n<p>你可以按任何顺序返回树的最终列表。</p>\n<p><a href=\"https://leetcode-cn.com/problems/all-possible-full-binary-trees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">allPossibleFBT</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">memoMap</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">number</span>, <span class=\"title class_\">TreeNode</span>[]&gt; = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">N: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">ans</span>: <span class=\"title class_\">TreeNode</span>[] = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!memoMap[N]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (N === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ans.<span class=\"title function_\">push</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (N % <span class=\"number\">2</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> y = N - <span class=\"number\">1</span> - i</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> left <span class=\"keyword\">of</span> <span class=\"title function_\">dfs</span>(i)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> right <span class=\"keyword\">of</span> <span class=\"title function_\">dfs</span>(y)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">              b.<span class=\"property\">left</span> = left</span><br><span class=\"line\">              b.<span class=\"property\">right</span> = right</span><br><span class=\"line\">              ans.<span class=\"title function_\">push</span>(b)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      memoMap[N] = ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memoMap[N]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">dfs</span>(n)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 897. 递增顺序搜索树\n\n给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。\n\n[链接](https://leetcode-cn.com/problems/increasing-order-search-tree/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\n  if (root === null) return null\n  const head = new TreeNode(0)\n  let n = head\n  function travese(node: TreeNode | null) {\n    if (node === null) return\n    travese(node.left)\n    n.right = new TreeNode(node.val)\n    n = n.right\n    travese(node.right)\n  }\n  travese(root)\n  return head.right\n};\n```\n","source":"leetcode/二叉树/897.递增顺序搜索树.md","raw":"# 897. 递增顺序搜索树\n\n给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。\n\n[链接](https://leetcode-cn.com/problems/increasing-order-search-tree/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\n  if (root === null) return null\n  const head = new TreeNode(0)\n  let n = head\n  function travese(node: TreeNode | null) {\n    if (node === null) return\n    travese(node.left)\n    n.right = new TreeNode(node.val)\n    n = n.right\n    travese(node.right)\n  }\n  travese(root)\n  return head.right\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.569Z","path":"leetcode/二叉树/897.递增顺序搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0033tnw7ffp92wbg","content":"<h1 id=\"897-递增顺序搜索树\"><a href=\"#897-递增顺序搜索树\" class=\"headerlink\" title=\"897. 递增顺序搜索树\"></a>897. 递增顺序搜索树</h1><p>给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/increasing-order-search-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">increasingBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> head = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = head</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">travese</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">travese</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    n.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    n = n.<span class=\"property\">right</span></span><br><span class=\"line\">    <span class=\"title function_\">travese</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">travese</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head.<span class=\"property\">right</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"897-递增顺序搜索树\"><a href=\"#897-递增顺序搜索树\" class=\"headerlink\" title=\"897. 递增顺序搜索树\"></a>897. 递增顺序搜索树</h1><p>给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n<p><a href=\"https://leetcode-cn.com/problems/increasing-order-search-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">increasingBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> head = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = head</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">travese</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">travese</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    n.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    n = n.<span class=\"property\">right</span></span><br><span class=\"line\">    <span class=\"title function_\">travese</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">travese</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> head.<span class=\"property\">right</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 919. 完全二叉树插入器\n\n完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。\n\n设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：\n\n- CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；\n- CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；\n- CBTInserter.get_root() 将返回树的头节点。\n\n[链接](https://leetcode-cn.com/problems/complete-binary-tree-inserter)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass CBTInserter {\n    head: TreeNode\n    parents: TreeNode[]\n    i: number\n    constructor(root: TreeNode | null) {\n      this.head = root\n      this.i = 0\n      const nodeQue = [this.head]\n      let depth = 0\n      while(nodeQue.length) {\n        depth++\n        const nodes = nodeQue.splice(0)\n        const len = nodes.length\n        let lastIndex = -1\n        for(let i = 0;i < len; i++) {\n          const node = nodes[i]\n          if (node.left && node.right) {\n            lastIndex = i\n          }\n          if (node.left) {\n            nodeQue.push(node.left)\n          }\n          if (node.right) {\n            nodeQue.push(node.right)\n          }\n        }\n        // 如果下一层不满足完成二叉树叶子结点数量，则父节点列表为nodes\n        if (nodeQue.length !== 2 ** depth) {\n          this.parents = nodes\n          this.i = lastIndex === -1 ? 0 : lastIndex + 1\n          break\n        }\n      }\n    }\n\n    insert(v: number): number {\n      \n      if (this.parents.length === this.i) {\n        this.parents = this.parents.reduce((pre, node) => {\n          node.left && pre.push(node.left)\n          node.right && pre.push(node.right)\n          return pre\n        }, [])\n        this.i = 0\n      }\n      \n      if (this.parents[this.i].left === null) {\n        this.parents[this.i].left = new TreeNode(v)\n        return this.parents[this.i].val\n      }\n      if (this.parents[this.i].right === null) {\n        this.parents[this.i].right = new TreeNode(v)\n        return this.parents[this.i++].val\n      }\n\n    }\n\n    get_root(): TreeNode | null {\n      return this.head\n    }\n}\n\n/**\n * Your CBTInserter object will be instantiated and called as such:\n * var obj = new CBTInserter(root)\n * var param_1 = obj.insert(v)\n * var param_2 = obj.get_root()\n */\n```\n","source":"leetcode/二叉树/919.完全二叉树插入器.md","raw":"# 919. 完全二叉树插入器\n\n完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。\n\n设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：\n\n- CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；\n- CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；\n- CBTInserter.get_root() 将返回树的头节点。\n\n[链接](https://leetcode-cn.com/problems/complete-binary-tree-inserter)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass CBTInserter {\n    head: TreeNode\n    parents: TreeNode[]\n    i: number\n    constructor(root: TreeNode | null) {\n      this.head = root\n      this.i = 0\n      const nodeQue = [this.head]\n      let depth = 0\n      while(nodeQue.length) {\n        depth++\n        const nodes = nodeQue.splice(0)\n        const len = nodes.length\n        let lastIndex = -1\n        for(let i = 0;i < len; i++) {\n          const node = nodes[i]\n          if (node.left && node.right) {\n            lastIndex = i\n          }\n          if (node.left) {\n            nodeQue.push(node.left)\n          }\n          if (node.right) {\n            nodeQue.push(node.right)\n          }\n        }\n        // 如果下一层不满足完成二叉树叶子结点数量，则父节点列表为nodes\n        if (nodeQue.length !== 2 ** depth) {\n          this.parents = nodes\n          this.i = lastIndex === -1 ? 0 : lastIndex + 1\n          break\n        }\n      }\n    }\n\n    insert(v: number): number {\n      \n      if (this.parents.length === this.i) {\n        this.parents = this.parents.reduce((pre, node) => {\n          node.left && pre.push(node.left)\n          node.right && pre.push(node.right)\n          return pre\n        }, [])\n        this.i = 0\n      }\n      \n      if (this.parents[this.i].left === null) {\n        this.parents[this.i].left = new TreeNode(v)\n        return this.parents[this.i].val\n      }\n      if (this.parents[this.i].right === null) {\n        this.parents[this.i].right = new TreeNode(v)\n        return this.parents[this.i++].val\n      }\n\n    }\n\n    get_root(): TreeNode | null {\n      return this.head\n    }\n}\n\n/**\n * Your CBTInserter object will be instantiated and called as such:\n * var obj = new CBTInserter(root)\n * var param_1 = obj.insert(v)\n * var param_2 = obj.get_root()\n */\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.570Z","path":"leetcode/二叉树/919.完全二叉树插入器.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0034tnw7d9jx5pzs","content":"<h1 id=\"919-完全二叉树插入器\"><a href=\"#919-完全二叉树插入器\" class=\"headerlink\" title=\"919. 完全二叉树插入器\"></a>919. 完全二叉树插入器</h1><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>\n<p>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p>\n<ul>\n<li>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；</li>\n<li>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；</li>\n<li>CBTInserter.get_root() 将返回树的头节点。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/complete-binary-tree-inserter\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CBTInserter</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">head</span>: <span class=\"title class_\">TreeNode</span></span><br><span class=\"line\">    <span class=\"attr\">parents</span>: <span class=\"title class_\">TreeNode</span>[]</span><br><span class=\"line\">    <span class=\"attr\">i</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">head</span> = root</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">i</span> = <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeQue = [<span class=\"variable language_\">this</span>.<span class=\"property\">head</span>]</span><br><span class=\"line\">      <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        depth++</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> lastIndex = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; len; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> &amp;&amp; node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">            lastIndex = i</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">            nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">            nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果下一层不满足完成二叉树叶子结点数量，则父节点列表为nodes</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeQue.<span class=\"property\">length</span> !== <span class=\"number\">2</span> ** depth) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span> = nodes</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">i</span> = lastIndex === -<span class=\"number\">1</span> ? <span class=\"number\">0</span> : lastIndex + <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">insert</span>(<span class=\"attr\">v</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>.<span class=\"property\">length</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">i</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre, node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          node.<span class=\"property\">left</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          node.<span class=\"property\">right</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">        &#125;, [])</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">i</span> = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">val</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>++].<span class=\"property\">val</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">get_root</span>(): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">head</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new CBTInserter(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.insert(v)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.get_root()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"919-完全二叉树插入器\"><a href=\"#919-完全二叉树插入器\" class=\"headerlink\" title=\"919. 完全二叉树插入器\"></a>919. 完全二叉树插入器</h1><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>\n<p>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p>\n<ul>\n<li>CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；</li>\n<li>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；</li>\n<li>CBTInserter.get_root() 将返回树的头节点。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/complete-binary-tree-inserter\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CBTInserter</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">head</span>: <span class=\"title class_\">TreeNode</span></span><br><span class=\"line\">    <span class=\"attr\">parents</span>: <span class=\"title class_\">TreeNode</span>[]</span><br><span class=\"line\">    <span class=\"attr\">i</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">head</span> = root</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">i</span> = <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> nodeQue = [<span class=\"variable language_\">this</span>.<span class=\"property\">head</span>]</span><br><span class=\"line\">      <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        depth++</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> lastIndex = -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; len; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> &amp;&amp; node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">            lastIndex = i</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">            nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">            nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果下一层不满足完成二叉树叶子结点数量，则父节点列表为nodes</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeQue.<span class=\"property\">length</span> !== <span class=\"number\">2</span> ** depth) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span> = nodes</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">i</span> = lastIndex === -<span class=\"number\">1</span> ? <span class=\"number\">0</span> : lastIndex + <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">insert</span>(<span class=\"attr\">v</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>.<span class=\"property\">length</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">i</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">pre, node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          node.<span class=\"property\">left</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">          node.<span class=\"property\">right</span> &amp;&amp; pre.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">        &#125;, [])</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">i</span> = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">left</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">val</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>].<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">parents</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">i</span>++].<span class=\"property\">val</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">get_root</span>(): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">head</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new CBTInserter(root)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.insert(v)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.get_root()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 94. 二叉树的中序遍历\n\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n```ts\nfunction inorderTraversal(root: TreeNode | null): number[] {\n  const inorder: number[] = []\n  traverse(root, inorder)\n  return inorder\n};\n\nfunction traverse(root: TreeNode | null, inorder: number[]): void {\n  if (root === null) return\n  traverse(root.left, inorder)\n  inorder.push(root.val)\n  traverse(root.right, inorder)\n}\n```\n","source":"leetcode/二叉树/94.二叉树的中序遍历.md","raw":"# 94. 二叉树的中序遍历\n\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n[链接](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n```ts\nfunction inorderTraversal(root: TreeNode | null): number[] {\n  const inorder: number[] = []\n  traverse(root, inorder)\n  return inorder\n};\n\nfunction traverse(root: TreeNode | null, inorder: number[]): void {\n  if (root === null) return\n  traverse(root.left, inorder)\n  inorder.push(root.val)\n  traverse(root.right, inorder)\n}\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.570Z","path":"leetcode/二叉树/94.二叉树的中序遍历.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0035tnw79rmkgp3r","content":"<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a>94. 二叉树的中序遍历</h1><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inorderTraversal</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">inorder</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, inorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inorder</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, inorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, inorder)</span><br><span class=\"line\">  inorder.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, inorder)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a>94. 二叉树的中序遍历</h1><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inorderTraversal</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">inorder</span>: <span class=\"built_in\">number</span>[] = []</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root, inorder)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inorder</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, inorder: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>, inorder)</span><br><span class=\"line\">  inorder.<span class=\"title function_\">push</span>(root.<span class=\"property\">val</span>)</span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>, inorder)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 938. 二叉搜索树的范围和\n\n给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。\n\n[链接](https://leetcode-cn.com/problems/range-sum-of-bst/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction rangeSumBST(root: TreeNode | null, low: number, high: number): number {\n  let total = 0\n  function dfs(node: TreeNode | null) {\n    if (node === null) return\n    dfs(node.left)\n    if (node.val >= low && node.val <= high) {\n      total += node.val\n    } else if (node.val > high) {\n      return\n    }\n    dfs(node.right)\n  }\n  dfs(root)\n  return total\n};\n```\n","source":"leetcode/二叉树/938.二叉搜索树的范围和.md","raw":"# 938. 二叉搜索树的范围和\n\n给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。\n\n[链接](https://leetcode-cn.com/problems/range-sum-of-bst/)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction rangeSumBST(root: TreeNode | null, low: number, high: number): number {\n  let total = 0\n  function dfs(node: TreeNode | null) {\n    if (node === null) return\n    dfs(node.left)\n    if (node.val >= low && node.val <= high) {\n      total += node.val\n    } else if (node.val > high) {\n      return\n    }\n    dfs(node.right)\n  }\n  dfs(root)\n  return total\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.570Z","path":"leetcode/二叉树/938.二叉搜索树的范围和.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0036tnw72q7r61pr","content":"<h1 id=\"938-二叉搜索树的范围和\"><a href=\"#938-二叉搜索树的范围和\" class=\"headerlink\" title=\"938. 二叉搜索树的范围和\"></a>938. 二叉搜索树的范围和</h1><p>给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/range-sum-of-bst/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rangeSumBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, low: <span class=\"built_in\">number</span>, high: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt;= low &amp;&amp; node.<span class=\"property\">val</span> &lt;= high) &#123;</span><br><span class=\"line\">      total += node.<span class=\"property\">val</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt; high) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"938-二叉搜索树的范围和\"><a href=\"#938-二叉搜索树的范围和\" class=\"headerlink\" title=\"938. 二叉搜索树的范围和\"></a>938. 二叉搜索树的范围和</h1><p>给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p>\n<p><a href=\"https://leetcode-cn.com/problems/range-sum-of-bst/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rangeSumBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, low: <span class=\"built_in\">number</span>, high: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt;= low &amp;&amp; node.<span class=\"property\">val</span> &lt;= high) &#123;</span><br><span class=\"line\">      total += node.<span class=\"property\">val</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.<span class=\"property\">val</span> &gt; high) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 95. 不同的二叉搜索树 II\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n[链接](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n```ts\nfunction generateTrees(n: number): Array<TreeNode | null> {\n  if (!n) return []\n  return traverse(1, n)\n};\n\nfunction traverse(inStart: number, inEnd: number): TreeNode[] {\n  const result = []\n  if (inStart > inEnd) {\n    result.push(null)\n    return result\n  }\n  for(let i = inStart; i <= inEnd; i++) {\n    const left = traverse(inStart, i - 1)\n    const right = traverse(i + 1, inEnd)\n    const root = new TreeNode(i)\n    const leftLen = left.length\n    const rightLen = right.length\n    for(let j = 0; j < leftLen; j++) {\n      for(let k = 0; k < rightLen; k++) {\n        const root = new TreeNode(i)\n        root.left = left[j]\n        root.right = right[k]\n        result.push(root)\n      }\n    }\n  }\n  return result\n}\n```\n","source":"leetcode/二叉树/95.不同的二叉搜索树II.md","raw":"# 95. 不同的二叉搜索树 II\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n[链接](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n```ts\nfunction generateTrees(n: number): Array<TreeNode | null> {\n  if (!n) return []\n  return traverse(1, n)\n};\n\nfunction traverse(inStart: number, inEnd: number): TreeNode[] {\n  const result = []\n  if (inStart > inEnd) {\n    result.push(null)\n    return result\n  }\n  for(let i = inStart; i <= inEnd; i++) {\n    const left = traverse(inStart, i - 1)\n    const right = traverse(i + 1, inEnd)\n    const root = new TreeNode(i)\n    const leftLen = left.length\n    const rightLen = right.length\n    for(let j = 0; j < leftLen; j++) {\n      for(let k = 0; k < rightLen; k++) {\n        const root = new TreeNode(i)\n        root.left = left[j]\n        root.right = right[k]\n        result.push(root)\n      }\n    }\n  }\n  return result\n}\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.570Z","path":"leetcode/二叉树/95.不同的二叉搜索树II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0037tnw7e00d8b8j","content":"<h1 id=\"95-不同的二叉搜索树-II\"><a href=\"#95-不同的二叉搜索树-II\" class=\"headerlink\" title=\"95. 不同的二叉搜索树 II\"></a>95. 不同的二叉搜索树 II</h1><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">generateTrees</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!n) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inStart &gt; inEnd) &#123;</span><br><span class=\"line\">    result.<span class=\"title function_\">push</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = <span class=\"title function_\">traverse</span>(inStart, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = <span class=\"title function_\">traverse</span>(i + <span class=\"number\">1</span>, inEnd)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(i)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> leftLen = left.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> rightLen = right.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; leftLen; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; rightLen; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(i)</span><br><span class=\"line\">        root.<span class=\"property\">left</span> = left[j]</span><br><span class=\"line\">        root.<span class=\"property\">right</span> = right[k]</span><br><span class=\"line\">        result.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"95-不同的二叉搜索树-II\"><a href=\"#95-不同的二叉搜索树-II\" class=\"headerlink\" title=\"95. 不同的二叉搜索树 II\"></a>95. 不同的二叉搜索树 II</h1><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n<p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">generateTrees</span>(<span class=\"params\">n: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!n) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">inStart: <span class=\"built_in\">number</span>, inEnd: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inStart &gt; inEnd) &#123;</span><br><span class=\"line\">    result.<span class=\"title function_\">push</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> left = <span class=\"title function_\">traverse</span>(inStart, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> right = <span class=\"title function_\">traverse</span>(i + <span class=\"number\">1</span>, inEnd)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(i)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> leftLen = left.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> rightLen = right.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; leftLen; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; rightLen; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(i)</span><br><span class=\"line\">        root.<span class=\"property\">left</span> = left[j]</span><br><span class=\"line\">        root.<span class=\"property\">right</span> = right[k]</span><br><span class=\"line\">        result.<span class=\"title function_\">push</span>(root)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 951. 翻转等价二叉树\n\n我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。\n\n只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。\n\n编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。\n\n[链接](https://leetcode-cn.com/problems/flip-equivalent-binary-trees)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction flipEquiv(root1: TreeNode | null, root2: TreeNode | null): boolean {\n  if (root1 === null && root2 === null) return true\n  if (root1 === null || root2 === null || root1.val !== root2.val) return false\n\n  return (\n          flipEquiv(root1.left, root2.right) &&\n          flipEquiv(root1.right, root2.left)\n        ) || (\n          flipEquiv(root1.left, root2.left) &&\n          flipEquiv(root1.right, root2.right)\n        )\n};\n```\n","source":"leetcode/二叉树/951.翻转等价二叉树.md","raw":"# 951. 翻转等价二叉树\n\n我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。\n\n只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。\n\n编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。\n\n[链接](https://leetcode-cn.com/problems/flip-equivalent-binary-trees)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction flipEquiv(root1: TreeNode | null, root2: TreeNode | null): boolean {\n  if (root1 === null && root2 === null) return true\n  if (root1 === null || root2 === null || root1.val !== root2.val) return false\n\n  return (\n          flipEquiv(root1.left, root2.right) &&\n          flipEquiv(root1.right, root2.left)\n        ) || (\n          flipEquiv(root1.left, root2.left) &&\n          flipEquiv(root1.right, root2.right)\n        )\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.571Z","path":"leetcode/二叉树/951.翻转等价二叉树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0038tnw74ie85nkv","content":"<h1 id=\"951-翻转等价二叉树\"><a href=\"#951-翻转等价二叉树\" class=\"headerlink\" title=\"951. 翻转等价二叉树\"></a>951. 翻转等价二叉树</h1><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>\n<p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。</p>\n<p>编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。</p>\n<p><a href=\"https://leetcode-cn.com/problems/flip-equivalent-binary-trees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flipEquiv</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root1 === <span class=\"literal\">null</span> &amp;&amp; root2 === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root1 === <span class=\"literal\">null</span> || root2 === <span class=\"literal\">null</span> || root1.<span class=\"property\">val</span> !== root2.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">left</span>, root2.<span class=\"property\">right</span>) &amp;&amp;</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">right</span>, root2.<span class=\"property\">left</span>)</span><br><span class=\"line\">        ) || (</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">left</span>, root2.<span class=\"property\">left</span>) &amp;&amp;</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">right</span>, root2.<span class=\"property\">right</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"951-翻转等价二叉树\"><a href=\"#951-翻转等价二叉树\" class=\"headerlink\" title=\"951. 翻转等价二叉树\"></a>951. 翻转等价二叉树</h1><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>\n<p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。</p>\n<p>编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。</p>\n<p><a href=\"https://leetcode-cn.com/problems/flip-equivalent-binary-trees\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flipEquiv</span>(<span class=\"params\">root1: TreeNode | <span class=\"literal\">null</span>, root2: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root1 === <span class=\"literal\">null</span> &amp;&amp; root2 === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root1 === <span class=\"literal\">null</span> || root2 === <span class=\"literal\">null</span> || root1.<span class=\"property\">val</span> !== root2.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">left</span>, root2.<span class=\"property\">right</span>) &amp;&amp;</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">right</span>, root2.<span class=\"property\">left</span>)</span><br><span class=\"line\">        ) || (</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">left</span>, root2.<span class=\"property\">left</span>) &amp;&amp;</span><br><span class=\"line\">          <span class=\"title function_\">flipEquiv</span>(root1.<span class=\"property\">right</span>, root2.<span class=\"property\">right</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 98. 验证二叉搜索树\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n- 节点的左子树只包含小于当前节点的数。\n- 节点的右子树只包含大于当前节点的数。\n- 所有左子树和右子树自身必须也是二叉搜索树。\n\n[链接](https://leetcode-cn.com/problems/validate-binary-search-tree)\n\n```ts\nlet max = Number.NEGATIVE_INFINITY\nfunction isValidBST(root: TreeNode | null): boolean {\n  if (root === null) return false\n  max = Number.NEGATIVE_INFINITY\n  return traverse(root)\n};\n\nfunction traverse(root: TreeNode | null): boolean {\n  if (root === null) return true\n  if (traverse(root.left)) {\n    if (max < root.val) {\n      max = root.val\n      return traverse(root.right)\n    }\n  }\n  return false\n}\n```\n","source":"leetcode/二叉树/98.验证二叉搜索树.md","raw":"# 98. 验证二叉搜索树\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n- 节点的左子树只包含小于当前节点的数。\n- 节点的右子树只包含大于当前节点的数。\n- 所有左子树和右子树自身必须也是二叉搜索树。\n\n[链接](https://leetcode-cn.com/problems/validate-binary-search-tree)\n\n```ts\nlet max = Number.NEGATIVE_INFINITY\nfunction isValidBST(root: TreeNode | null): boolean {\n  if (root === null) return false\n  max = Number.NEGATIVE_INFINITY\n  return traverse(root)\n};\n\nfunction traverse(root: TreeNode | null): boolean {\n  if (root === null) return true\n  if (traverse(root.left)) {\n    if (max < root.val) {\n      max = root.val\n      return traverse(root.right)\n    }\n  }\n  return false\n}\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.571Z","path":"leetcode/二叉树/98.验证二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt0039tnw7amr25xi4","content":"<h1 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a>98. 验证二叉搜索树</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<ul>\n<li>节点的左子树只包含小于当前节点的数。</li>\n<li>节点的右子树只包含大于当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> max = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isValidBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  max = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max &lt; root.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      max = root.<span class=\"property\">val</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a>98. 验证二叉搜索树</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<ul>\n<li>节点的左子树只包含小于当前节点的数。</li>\n<li>节点的右子树只包含大于当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> max = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isValidBST</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  max = <span class=\"title class_\">Number</span>.<span class=\"property\">NEGATIVE_INFINITY</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max &lt; root.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      max = root.<span class=\"property\">val</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 958. 二叉树的完全性检验\n\n给定一个二叉树，确定它是否是一个完全二叉树。\n\n百度百科中对完全二叉树的定义如下：\n\n若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）\n\n[链接](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isCompleteTree(root: TreeNode | null): boolean {\n  if (root === null) return false\n  const nodeQue: TreeNode[] = [root]\n  let depth = 0\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    let isFindNull = false\n    let isFindNumAfterNull = false\n    depth++\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node.left === null) {\n        isFindNull = true\n      } else {\n        if (isFindNull) {\n          isFindNumAfterNull = true\n          break\n        }\n        nodeQue.push(node.left)\n      }\n      if (node.right === null) {\n        isFindNull = true\n      } else {\n        if (isFindNull) {\n          isFindNumAfterNull = true\n          break\n        }\n        nodeQue.push(node.right)\n      }\n    }\n    if (\n      isFindNumAfterNull ||\n      (nodeQue.length > 0 && len !== 2 ** (depth - 1))\n    ) return false\n  }\n  return true\n};\n```\n","source":"leetcode/二叉树/958.二叉树的完全性检验.md","raw":"# 958. 二叉树的完全性检验\n\n给定一个二叉树，确定它是否是一个完全二叉树。\n\n百度百科中对完全二叉树的定义如下：\n\n若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）\n\n[链接](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isCompleteTree(root: TreeNode | null): boolean {\n  if (root === null) return false\n  const nodeQue: TreeNode[] = [root]\n  let depth = 0\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    let isFindNull = false\n    let isFindNumAfterNull = false\n    depth++\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node.left === null) {\n        isFindNull = true\n      } else {\n        if (isFindNull) {\n          isFindNumAfterNull = true\n          break\n        }\n        nodeQue.push(node.left)\n      }\n      if (node.right === null) {\n        isFindNull = true\n      } else {\n        if (isFindNull) {\n          isFindNumAfterNull = true\n          break\n        }\n        nodeQue.push(node.right)\n      }\n    }\n    if (\n      isFindNumAfterNull ||\n      (nodeQue.length > 0 && len !== 2 ** (depth - 1))\n    ) return false\n  }\n  return true\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.571Z","path":"leetcode/二叉树/958.二叉树的完全性检验.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt003atnw7dtpb0gki","content":"<h1 id=\"958-二叉树的完全性检验\"><a href=\"#958-二叉树的完全性检验\" class=\"headerlink\" title=\"958. 二叉树的完全性检验\"></a>958. 二叉树的完全性检验</h1><p>给定一个二叉树，确定它是否是一个完全二叉树。</p>\n<p>百度百科中对完全二叉树的定义如下：</p>\n<p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）</p>\n<p><a href=\"https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isCompleteTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQue</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isFindNull = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isFindNumAfterNull = <span class=\"literal\">false</span></span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        isFindNull = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFindNull) &#123;</span><br><span class=\"line\">          isFindNumAfterNull = <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        isFindNull = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFindNull) &#123;</span><br><span class=\"line\">          isFindNumAfterNull = <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      isFindNumAfterNull ||</span><br><span class=\"line\">      (nodeQue.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; len !== <span class=\"number\">2</span> ** (depth - <span class=\"number\">1</span>))</span><br><span class=\"line\">    ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"958-二叉树的完全性检验\"><a href=\"#958-二叉树的完全性检验\" class=\"headerlink\" title=\"958. 二叉树的完全性检验\"></a>958. 二叉树的完全性检验</h1><p>给定一个二叉树，确定它是否是一个完全二叉树。</p>\n<p>百度百科中对完全二叉树的定义如下：</p>\n<p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）</p>\n<p><a href=\"https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isCompleteTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">nodeQue</span>: <span class=\"title class_\">TreeNode</span>[] = [root]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> depth = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isFindNull = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isFindNumAfterNull = <span class=\"literal\">false</span></span><br><span class=\"line\">    depth++</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        isFindNull = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFindNull) &#123;</span><br><span class=\"line\">          isFindNumAfterNull = <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        isFindNull = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFindNull) &#123;</span><br><span class=\"line\">          isFindNumAfterNull = <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      isFindNumAfterNull ||</span><br><span class=\"line\">      (nodeQue.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span> &amp;&amp; len !== <span class=\"number\">2</span> ** (depth - <span class=\"number\">1</span>))</span><br><span class=\"line\">    ) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 993. 二叉树的堂兄弟节点\n\n在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n\n如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。\n\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\n\n[链接](https://leetcode-cn.com/problems/cousins-in-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nvar isCousins = function(root, x, y) {\n  if (root === null) return false\n  const nodeQue = [root]\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    let xnode = null, ynode = null;\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node) {\n        if (x === node.val) {\n          xnode = node\n        } else if (y === node.val) {\n          ynode = node\n        }\n        if (node.left) {\n          node.left.parent = node\n          nodeQue.push(node.left)\n        }\n        if (node.right) {\n          node.right.parent = node\n          nodeQue.push(node.right)\n        }\n      }\n    }\n    if (xnode !== null && ynode !== null && xnode.parent !== ynode.parent) {\n      return true\n    } else if (xnode === null && ynode === null) {\n      continue\n    } else {\n      return false\n    }\n  }\n  return false\n};\n```\n","source":"leetcode/二叉树/993.二叉树的堂兄弟节点.md","raw":"# 993. 二叉树的堂兄弟节点\n\n在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n\n如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。\n\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\n\n[链接](https://leetcode-cn.com/problems/cousins-in-binary-tree)\n\n```ts\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nvar isCousins = function(root, x, y) {\n  if (root === null) return false\n  const nodeQue = [root]\n  while(nodeQue.length) {\n    const nodes = nodeQue.splice(0)\n    const len = nodes.length\n    let xnode = null, ynode = null;\n    for(let i = 0; i < len; i++) {\n      const node = nodes[i]\n      if (node) {\n        if (x === node.val) {\n          xnode = node\n        } else if (y === node.val) {\n          ynode = node\n        }\n        if (node.left) {\n          node.left.parent = node\n          nodeQue.push(node.left)\n        }\n        if (node.right) {\n          node.right.parent = node\n          nodeQue.push(node.right)\n        }\n      }\n    }\n    if (xnode !== null && ynode !== null && xnode.parent !== ynode.parent) {\n      return true\n    } else if (xnode === null && ynode === null) {\n      continue\n    } else {\n      return false\n    }\n  }\n  return false\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.572Z","path":"leetcode/二叉树/993.二叉树的堂兄弟节点.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt003btnw7ee8k44wb","content":"<h1 id=\"993-二叉树的堂兄弟节点\"><a href=\"#993-二叉树的堂兄弟节点\" class=\"headerlink\" title=\"993. 二叉树的堂兄弟节点\"></a>993. 二叉树的堂兄弟节点</h1><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>\n<p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>\n<p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p>\n<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p>\n<p><a href=\"https://leetcode-cn.com/problems/cousins-in-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">x</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">y</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isCousins = <span class=\"keyword\">function</span>(<span class=\"params\">root, x, y</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQue = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xnode = <span class=\"literal\">null</span>, ynode = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x === node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          xnode = node</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y === node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          ynode = node</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xnode !== <span class=\"literal\">null</span> &amp;&amp; ynode !== <span class=\"literal\">null</span> &amp;&amp; xnode.<span class=\"property\">parent</span> !== ynode.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (xnode === <span class=\"literal\">null</span> &amp;&amp; ynode === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"993-二叉树的堂兄弟节点\"><a href=\"#993-二叉树的堂兄弟节点\" class=\"headerlink\" title=\"993. 二叉树的堂兄弟节点\"></a>993. 二叉树的堂兄弟节点</h1><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>\n<p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>\n<p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p>\n<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p>\n<p><a href=\"https://leetcode-cn.com/problems/cousins-in-binary-tree\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(val, left, right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">TreeNode</span>&#125; <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">x</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number</span>&#125; <span class=\"variable\">y</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">boolean</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isCousins = <span class=\"keyword\">function</span>(<span class=\"params\">root, x, y</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> nodeQue = [root]</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(nodeQue.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nodes = nodeQue.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> len = nodes.<span class=\"property\">length</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xnode = <span class=\"literal\">null</span>, ynode = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = nodes[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x === node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          xnode = node</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y === node.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">          ynode = node</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">left</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">left</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">left</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">          node.<span class=\"property\">right</span>.<span class=\"property\">parent</span> = node</span><br><span class=\"line\">          nodeQue.<span class=\"title function_\">push</span>(node.<span class=\"property\">right</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xnode !== <span class=\"literal\">null</span> &amp;&amp; ynode !== <span class=\"literal\">null</span> &amp;&amp; xnode.<span class=\"property\">parent</span> !== ynode.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (xnode === <span class=\"literal\">null</span> &amp;&amp; ynode === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 99. 恢复二叉搜索树\n\n给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\n\n[链接](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n\n```ts\nfunction recoverTree(root: TreeNode | null): void {\n  let n1 = null\n  let n2 = null\n  let pre = null\n  traverse(root)\n  function traverse(root: TreeNode | null) {\n    if (root === null) return\n    traverse(root.left)\n    if (pre && root.val < pre.val) {\n      n2 = root\n      if (!n1) n1 = pre\n      else return\n    }\n    pre = root\n    traverse(root.right)\n  }\n  if (n1 && n2) {\n    const temp = n1.val\n    n1.val = n2.val\n    n2.val = temp\n  }\n}\n```\n\nO(1)复杂度\n\n```js\nconst swap = (x, y) => {\n    const temp = x.val\n    x.val = y.val\n    y.val = temp\n}\n\nvar recoverTree = function(root) {\n    let x = null, y = null, pred = null, predecessor = null\n\n    while (root !== null) {\n      if (root.left !== null) {\n        // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止\n        predecessor = root.left\n        while (predecessor.right !== null && predecessor.right !== root)\n          predecessor = predecessor.right\n\n        // 让 predecessor 的右指针指向 root，继续遍历左子树\n        if (predecessor.right === null) {\n          predecessor.right = root\n          root = root.left\n        }\n        // 说明左子树已经访问完了，我们需要断开链接\n        else {\n          if (pred !== null && root.val < pred.val) {\n            y = root\n            if (x === null) {\n                x = pred\n            }\n          }\n          pred = root\n\n          predecessor.right = null\n          root = root.right\n        }\n      }\n      // 如果没有左孩子，则直接访问右孩子\n      else {\n        if (pred !== null && root.val < pred.val) {\n            y = root\n            if (x === null) {\n                x = pred\n            }\n        }\n        pred = root\n\n        root = root.right\n      }\n    }\n    swap(x, y)\n}\n```\n","source":"leetcode/二叉树/99.恢复二叉搜索树.md","raw":"# 99. 恢复二叉搜索树\n\n给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\n\n[链接](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n\n```ts\nfunction recoverTree(root: TreeNode | null): void {\n  let n1 = null\n  let n2 = null\n  let pre = null\n  traverse(root)\n  function traverse(root: TreeNode | null) {\n    if (root === null) return\n    traverse(root.left)\n    if (pre && root.val < pre.val) {\n      n2 = root\n      if (!n1) n1 = pre\n      else return\n    }\n    pre = root\n    traverse(root.right)\n  }\n  if (n1 && n2) {\n    const temp = n1.val\n    n1.val = n2.val\n    n2.val = temp\n  }\n}\n```\n\nO(1)复杂度\n\n```js\nconst swap = (x, y) => {\n    const temp = x.val\n    x.val = y.val\n    y.val = temp\n}\n\nvar recoverTree = function(root) {\n    let x = null, y = null, pred = null, predecessor = null\n\n    while (root !== null) {\n      if (root.left !== null) {\n        // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止\n        predecessor = root.left\n        while (predecessor.right !== null && predecessor.right !== root)\n          predecessor = predecessor.right\n\n        // 让 predecessor 的右指针指向 root，继续遍历左子树\n        if (predecessor.right === null) {\n          predecessor.right = root\n          root = root.left\n        }\n        // 说明左子树已经访问完了，我们需要断开链接\n        else {\n          if (pred !== null && root.val < pred.val) {\n            y = root\n            if (x === null) {\n                x = pred\n            }\n          }\n          pred = root\n\n          predecessor.right = null\n          root = root.right\n        }\n      }\n      // 如果没有左孩子，则直接访问右孩子\n      else {\n        if (pred !== null && root.val < pred.val) {\n            y = root\n            if (x === null) {\n                x = pred\n            }\n        }\n        pred = root\n\n        root = root.right\n      }\n    }\n    swap(x, y)\n}\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.572Z","path":"leetcode/二叉树/99.恢复二叉搜索树.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt003ctnw7beau0swz","content":"<h1 id=\"99-恢复二叉搜索树\"><a href=\"#99-恢复二叉搜索树\" class=\"headerlink\" title=\"99. 恢复二叉搜索树\"></a>99. 恢复二叉搜索树</h1><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/recover-binary-search-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">recoverTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n1 = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> n2 = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; root.<span class=\"property\">val</span> &lt; pre.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      n2 = root</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!n1) n1 = pre</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = root</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 &amp;&amp; n2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = n1.<span class=\"property\">val</span></span><br><span class=\"line\">    n1.<span class=\"property\">val</span> = n2.<span class=\"property\">val</span></span><br><span class=\"line\">    n2.<span class=\"property\">val</span> = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>O(1)复杂度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">swap</span> = (<span class=\"params\">x, y</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = x.<span class=\"property\">val</span></span><br><span class=\"line\">    x.<span class=\"property\">val</span> = y.<span class=\"property\">val</span></span><br><span class=\"line\">    y.<span class=\"property\">val</span> = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> recoverTree = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"literal\">null</span>, y = <span class=\"literal\">null</span>, pred = <span class=\"literal\">null</span>, predecessor = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class=\"line\">        predecessor = root.<span class=\"property\">left</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (predecessor.<span class=\"property\">right</span> !== <span class=\"literal\">null</span> &amp;&amp; predecessor.<span class=\"property\">right</span> !== root)</span><br><span class=\"line\">          predecessor = predecessor.<span class=\"property\">right</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predecessor.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          predecessor.<span class=\"property\">right</span> = root</span><br><span class=\"line\">          root = root.<span class=\"property\">left</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (pred !== <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">val</span> &lt; pred.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">            y = root</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                x = pred</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          pred = root</span><br><span class=\"line\"></span><br><span class=\"line\">          predecessor.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">          root = root.<span class=\"property\">right</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred !== <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">val</span> &lt; pred.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">            y = root</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                x = pred</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pred = root</span><br><span class=\"line\"></span><br><span class=\"line\">        root = root.<span class=\"property\">right</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">swap</span>(x, y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"99-恢复二叉搜索树\"><a href=\"#99-恢复二叉搜索树\" class=\"headerlink\" title=\"99. 恢复二叉搜索树\"></a>99. 恢复二叉搜索树</h1><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>\n<p><a href=\"https://leetcode-cn.com/problems/recover-binary-search-tree/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">recoverTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n1 = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> n2 = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"title function_\">traverse</span>(root)</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">left</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre &amp;&amp; root.<span class=\"property\">val</span> &lt; pre.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">      n2 = root</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!n1) n1 = pre</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = root</span><br><span class=\"line\">    <span class=\"title function_\">traverse</span>(root.<span class=\"property\">right</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n1 &amp;&amp; n2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = n1.<span class=\"property\">val</span></span><br><span class=\"line\">    n1.<span class=\"property\">val</span> = n2.<span class=\"property\">val</span></span><br><span class=\"line\">    n2.<span class=\"property\">val</span> = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>O(1)复杂度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">swap</span> = (<span class=\"params\">x, y</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = x.<span class=\"property\">val</span></span><br><span class=\"line\">    x.<span class=\"property\">val</span> = y.<span class=\"property\">val</span></span><br><span class=\"line\">    y.<span class=\"property\">val</span> = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> recoverTree = <span class=\"keyword\">function</span>(<span class=\"params\">root</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"literal\">null</span>, y = <span class=\"literal\">null</span>, pred = <span class=\"literal\">null</span>, predecessor = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (root.<span class=\"property\">left</span> !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class=\"line\">        predecessor = root.<span class=\"property\">left</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (predecessor.<span class=\"property\">right</span> !== <span class=\"literal\">null</span> &amp;&amp; predecessor.<span class=\"property\">right</span> !== root)</span><br><span class=\"line\">          predecessor = predecessor.<span class=\"property\">right</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predecessor.<span class=\"property\">right</span> === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          predecessor.<span class=\"property\">right</span> = root</span><br><span class=\"line\">          root = root.<span class=\"property\">left</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (pred !== <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">val</span> &lt; pred.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">            y = root</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                x = pred</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          pred = root</span><br><span class=\"line\"></span><br><span class=\"line\">          predecessor.<span class=\"property\">right</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">          root = root.<span class=\"property\">right</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred !== <span class=\"literal\">null</span> &amp;&amp; root.<span class=\"property\">val</span> &lt; pred.<span class=\"property\">val</span>) &#123;</span><br><span class=\"line\">            y = root</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                x = pred</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pred = root</span><br><span class=\"line\"></span><br><span class=\"line\">        root = root.<span class=\"property\">right</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">swap</span>(x, y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 988. 从叶结点开始的最小字符串\n\n给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个从 0 到 25 的值，分别代表字母 'a' 到 'z'：值 0 代表 'a'，值 1 代表 'b'，依此类推。\n\n找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。\n\n（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 \"ab\" 比 \"aba\" 要小。叶结点是指没有子结点的结点。）\n\n[链接](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction smallestFromLeaf(root: TreeNode | null): string {\n  if (root === null) return ''\n  const paths: string[] = []\n  function dfs(node: TreeNode | null, path: string) {\n    if (node === null) {\n      return\n    }\n    path += String.fromCharCode(97 + node.val)\n    if (!node.left && !node.right) {\n      paths.push(Array.from(path).reverse().join(\"\"))\n      return\n    }\n    dfs(node.left, path)\n    dfs(node.right, path)\n  }\n  dfs(root, \"\")\n  console.log(paths.sort())\n  return paths[0]\n};\n```\n","source":"leetcode/二叉树/988.从叶结点开始的最小字符串.md","raw":"# 988. 从叶结点开始的最小字符串\n\n给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个从 0 到 25 的值，分别代表字母 'a' 到 'z'：值 0 代表 'a'，值 1 代表 'b'，依此类推。\n\n找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。\n\n（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 \"ab\" 比 \"aba\" 要小。叶结点是指没有子结点的结点。）\n\n[链接](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction smallestFromLeaf(root: TreeNode | null): string {\n  if (root === null) return ''\n  const paths: string[] = []\n  function dfs(node: TreeNode | null, path: string) {\n    if (node === null) {\n      return\n    }\n    path += String.fromCharCode(97 + node.val)\n    if (!node.left && !node.right) {\n      paths.push(Array.from(path).reverse().join(\"\"))\n      return\n    }\n    dfs(node.left, path)\n    dfs(node.right, path)\n  }\n  dfs(root, \"\")\n  console.log(paths.sort())\n  return paths[0]\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.571Z","path":"leetcode/二叉树/988.从叶结点开始的最小字符串.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxt003dtnw7fjln1zrv","content":"<h1 id=\"988-从叶结点开始的最小字符串\"><a href=\"#988-从叶结点开始的最小字符串\" class=\"headerlink\" title=\"988. 从叶结点开始的最小字符串\"></a>988. 从叶结点开始的最小字符串</h1><p>给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个从 0 到 25 的值，分别代表字母 ‘a’ 到 ‘z’：值 0 代表 ‘a’，值 1 代表 ‘b’，依此类推。</p>\n<p>找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。</p>\n<p>（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 “ab” 比 “aba” 要小。叶结点是指没有子结点的结点。）</p>\n<p><a href=\"https://leetcode-cn.com/problems/smallest-string-starting-from-leaf\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">smallestFromLeaf</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">paths</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, path: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path += <span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">97</span> + node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.<span class=\"property\">left</span> &amp;&amp; !node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      paths.<span class=\"title function_\">push</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(path).<span class=\"title function_\">reverse</span>().<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, path)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(paths.<span class=\"title function_\">sort</span>())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"988-从叶结点开始的最小字符串\"><a href=\"#988-从叶结点开始的最小字符串\" class=\"headerlink\" title=\"988. 从叶结点开始的最小字符串\"></a>988. 从叶结点开始的最小字符串</h1><p>给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个从 0 到 25 的值，分别代表字母 ‘a’ 到 ‘z’：值 0 代表 ‘a’，值 1 代表 ‘b’，依此类推。</p>\n<p>找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。</p>\n<p>（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 “ab” 比 “aba” 要小。叶结点是指没有子结点的结点。）</p>\n<p><a href=\"https://leetcode-cn.com/problems/smallest-string-starting-from-leaf\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">smallestFromLeaf</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">paths</span>: <span class=\"built_in\">string</span>[] = []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">node: TreeNode | <span class=\"literal\">null</span>, path: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    path += <span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">97</span> + node.<span class=\"property\">val</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node.<span class=\"property\">left</span> &amp;&amp; !node.<span class=\"property\">right</span>) &#123;</span><br><span class=\"line\">      paths.<span class=\"title function_\">push</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(path).<span class=\"title function_\">reverse</span>().<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">left</span>, path)</span><br><span class=\"line\">    <span class=\"title function_\">dfs</span>(node.<span class=\"property\">right</span>, path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">dfs</span>(root, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(paths.<span class=\"title function_\">sort</span>())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 998. 最大二叉树 II\n\n最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。\n\n给出最大树的根节点 root。\n\n就像之前的问题那样，给定的树是从列表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：\n\n- 如果 A 为空，返回 null\n- 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root\n- root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]])\n- root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]])\n- 返回 root\n\n请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).\n\n假设 B 是 A 的副本，并在末尾附加值 val。题目数据保证 B 中的值是不同的。\n\n返回 Construct(B)。\n\n[链接](https://leetcode-cn.com/problems/maximum-binary-tree-ii)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction insertIntoMaxTree(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) return null\n  if (root.val < val) {\n    const node = new TreeNode(val)\n    node.left = root\n    return node\n  }\n  let p = root\n  let r = root.right\n  while(r) {\n    if (r.val < val) {\n      const node = new TreeNode(val)\n      node.left = r\n      p.right = node\n      break\n    }\n    p = r\n    r = r.right\n  }\n  if (r === null) {\n    p.right = new TreeNode(val)\n  }\n  return root\n};\n```\n","source":"leetcode/二叉树/998.最大二叉树II.md","raw":"# 998. 最大二叉树 II\n\n最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。\n\n给出最大树的根节点 root。\n\n就像之前的问题那样，给定的树是从列表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：\n\n- 如果 A 为空，返回 null\n- 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root\n- root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]])\n- root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]])\n- 返回 root\n\n请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).\n\n假设 B 是 A 的副本，并在末尾附加值 val。题目数据保证 B 中的值是不同的。\n\n返回 Construct(B)。\n\n[链接](https://leetcode-cn.com/problems/maximum-binary-tree-ii)\n\n```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction insertIntoMaxTree(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) return null\n  if (root.val < val) {\n    const node = new TreeNode(val)\n    node.left = root\n    return node\n  }\n  let p = root\n  let r = root.right\n  while(r) {\n    if (r.val < val) {\n      const node = new TreeNode(val)\n      node.left = r\n      p.right = node\n      break\n    }\n    p = r\n    r = r.right\n  }\n  if (r === null) {\n    p.right = new TreeNode(val)\n  }\n  return root\n};\n```\n","date":"2023-10-11T15:10:43.209Z","updated":"2023-09-26T14:49:23.572Z","path":"leetcode/二叉树/998.最大二叉树II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003etnw77y7p9boy","content":"<h1 id=\"998-最大二叉树-II\"><a href=\"#998-最大二叉树-II\" class=\"headerlink\" title=\"998. 最大二叉树 II\"></a>998. 最大二叉树 II</h1><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p>\n<p>给出最大树的根节点 root。</p>\n<p>就像之前的问题那样，给定的树是从列表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：</p>\n<ul>\n<li>如果 A 为空，返回 null</li>\n<li>否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root</li>\n<li>root 的左子树将被构建为 Construct([A[0], A[1], …, A[i-1]])</li>\n<li>root 的右子树将被构建为 Construct([A[i+1], A[i+2], …, A[A.length - 1]])</li>\n<li>返回 root</li>\n</ul>\n<p>请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).</p>\n<p>假设 B 是 A 的副本，并在末尾附加值 val。题目数据保证 B 中的值是不同的。</p>\n<p>返回 Construct(B)。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-binary-tree-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">insertIntoMaxTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &lt; val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">    node.<span class=\"property\">left</span> = root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = root</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r = root.<span class=\"property\">right</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.<span class=\"property\">val</span> &lt; val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">      node.<span class=\"property\">left</span> = r</span><br><span class=\"line\">      p.<span class=\"property\">right</span> = node</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p = r</span><br><span class=\"line\">    r = r.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    p.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"998-最大二叉树-II\"><a href=\"#998-最大二叉树-II\" class=\"headerlink\" title=\"998. 最大二叉树 II\"></a>998. 最大二叉树 II</h1><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p>\n<p>给出最大树的根节点 root。</p>\n<p>就像之前的问题那样，给定的树是从列表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：</p>\n<ul>\n<li>如果 A 为空，返回 null</li>\n<li>否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root</li>\n<li>root 的左子树将被构建为 Construct([A[0], A[1], …, A[i-1]])</li>\n<li>root 的右子树将被构建为 Construct([A[i+1], A[i+2], …, A[A.length - 1]])</li>\n<li>返回 root</li>\n</ul>\n<p>请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).</p>\n<p>假设 B 是 A 的副本，并在末尾附加值 val。题目数据保证 B 中的值是不同的。</p>\n<p>返回 Construct(B)。</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-binary-tree-ii\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     val: number</span></span><br><span class=\"line\"><span class=\"comment\"> *     left: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     right: TreeNode | null</span></span><br><span class=\"line\"><span class=\"comment\"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = (left===undefined ? null : left)</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = (right===undefined ? null : right)</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">insertIntoMaxTree</span>(<span class=\"params\">root: TreeNode | <span class=\"literal\">null</span>, val: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">TreeNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.<span class=\"property\">val</span> &lt; val) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">    node.<span class=\"property\">left</span> = root</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = root</span><br><span class=\"line\">  <span class=\"keyword\">let</span> r = root.<span class=\"property\">right</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.<span class=\"property\">val</span> &lt; val) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">      node.<span class=\"property\">left</span> = r</span><br><span class=\"line\">      p.<span class=\"property\">right</span> = node</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p = r</span><br><span class=\"line\">    r = r.<span class=\"property\">right</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    p.<span class=\"property\">right</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 234. 回文链表\n\n请判断一个链表是否为回文链表。\n\n[链接](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n## 递归\n\n空间复杂度O(n)。因为每一次都要压栈，所以要遍历完整个链表。\n\n```ts\nfunction isPalindrome(head: ListNode | null): boolean {\n  let left = head\n  function traverse(right: ListNode | null) {\n    if (right === null) return true\n    let res = traverse(right.next)\n    res = res && (left.val === right.val)\n    left = left.next\n    return res\n  }\n  return traverse(head)\n}\n```\n\n## 迭代\n\n```ts\nfunction isPalindrome(head: ListNode | null): boolean {\n  let mid = findMid(head)\n  let left = head\n  let right = resverse(mid)\n  let last = right\n  let leftLast = null\n  while(right != null) {\n    if (left.val !== right.val) return false\n    leftLast = left\n    left = left.next\n    right = right.next\n  }\n  leftLast && (leftLast.next = resverse(last)) // 还原链表\n  return true\n}\n\nfunction findMid(head: ListNode): ListNode {\n  let slow = head, fast = head\n  while(fast != null && fast.next != null) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  if (fast !== null) slow = slow.next\n  return slow\n}\n\nfunction resverse(head: ListNode): ListNode {\n  let pre = null\n  let cur = head\n  let next = null\n  while(cur !== null) {\n    next = cur.next\n    cur.next = pre\n    pre = cur\n    cur = next\n  }\n  return pre\n}\n```\n","source":"leetcode/链表/234.回文链表.md","raw":"# 234. 回文链表\n\n请判断一个链表是否为回文链表。\n\n[链接](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n## 递归\n\n空间复杂度O(n)。因为每一次都要压栈，所以要遍历完整个链表。\n\n```ts\nfunction isPalindrome(head: ListNode | null): boolean {\n  let left = head\n  function traverse(right: ListNode | null) {\n    if (right === null) return true\n    let res = traverse(right.next)\n    res = res && (left.val === right.val)\n    left = left.next\n    return res\n  }\n  return traverse(head)\n}\n```\n\n## 迭代\n\n```ts\nfunction isPalindrome(head: ListNode | null): boolean {\n  let mid = findMid(head)\n  let left = head\n  let right = resverse(mid)\n  let last = right\n  let leftLast = null\n  while(right != null) {\n    if (left.val !== right.val) return false\n    leftLast = left\n    left = left.next\n    right = right.next\n  }\n  leftLast && (leftLast.next = resverse(last)) // 还原链表\n  return true\n}\n\nfunction findMid(head: ListNode): ListNode {\n  let slow = head, fast = head\n  while(fast != null && fast.next != null) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  if (fast !== null) slow = slow.next\n  return slow\n}\n\nfunction resverse(head: ListNode): ListNode {\n  let pre = null\n  let cur = head\n  let next = null\n  while(cur !== null) {\n    next = cur.next\n    cur.next = pre\n    pre = cur\n    cur = next\n  }\n  return pre\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.594Z","path":"leetcode/链表/234.回文链表.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003ftnw7fokl3u8h","content":"<h1 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a>234. 回文链表</h1><p>请判断一个链表是否为回文链表。</p>\n<p><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">链接</a></p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>空间复杂度O(n)。因为每一次都要压栈，所以要遍历完整个链表。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPalindrome</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = head</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">right: ListNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title function_\">traverse</span>(right.<span class=\"property\">next</span>)</span><br><span class=\"line\">    res = res &amp;&amp; (left.<span class=\"property\">val</span> === right.<span class=\"property\">val</span>)</span><br><span class=\"line\">    left = left.<span class=\"property\">next</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(head)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPalindrome</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = <span class=\"title function_\">findMid</span>(head)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = <span class=\"title function_\">resverse</span>(mid)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> last = right</span><br><span class=\"line\">  <span class=\"keyword\">let</span> leftLast = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left.<span class=\"property\">val</span> !== right.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    leftLast = left</span><br><span class=\"line\">    left = left.<span class=\"property\">next</span></span><br><span class=\"line\">    right = right.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  leftLast &amp;&amp; (leftLast.<span class=\"property\">next</span> = <span class=\"title function_\">resverse</span>(last)) <span class=\"comment\">// 还原链表</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMid</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = head, fast = head</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(fast != <span class=\"literal\">null</span> &amp;&amp; fast.<span class=\"property\">next</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span>.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fast !== <span class=\"literal\">null</span>) slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">resverse</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> cur = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> next = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(cur !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    next = cur.<span class=\"property\">next</span></span><br><span class=\"line\">    cur.<span class=\"property\">next</span> = pre</span><br><span class=\"line\">    pre = cur</span><br><span class=\"line\">    cur = next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a>234. 回文链表</h1><p>请判断一个链表是否为回文链表。</p>\n<p><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">链接</a></p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>空间复杂度O(n)。因为每一次都要压栈，所以要遍历完整个链表。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPalindrome</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = head</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">right: ListNode | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"title function_\">traverse</span>(right.<span class=\"property\">next</span>)</span><br><span class=\"line\">    res = res &amp;&amp; (left.<span class=\"property\">val</span> === right.<span class=\"property\">val</span>)</span><br><span class=\"line\">    left = left.<span class=\"property\">next</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">traverse</span>(head)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPalindrome</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid = <span class=\"title function_\">findMid</span>(head)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = <span class=\"title function_\">resverse</span>(mid)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> last = right</span><br><span class=\"line\">  <span class=\"keyword\">let</span> leftLast = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left.<span class=\"property\">val</span> !== right.<span class=\"property\">val</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    leftLast = left</span><br><span class=\"line\">    left = left.<span class=\"property\">next</span></span><br><span class=\"line\">    right = right.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  leftLast &amp;&amp; (leftLast.<span class=\"property\">next</span> = <span class=\"title function_\">resverse</span>(last)) <span class=\"comment\">// 还原链表</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">findMid</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> slow = head, fast = head</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(fast != <span class=\"literal\">null</span> &amp;&amp; fast.<span class=\"property\">next</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">    fast = fast.<span class=\"property\">next</span>.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fast !== <span class=\"literal\">null</span>) slow = slow.<span class=\"property\">next</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">resverse</span>(<span class=\"params\">head: ListNode</span>): <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> cur = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> next = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(cur !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    next = cur.<span class=\"property\">next</span></span><br><span class=\"line\">    cur.<span class=\"property\">next</span> = pre</span><br><span class=\"line\">    pre = cur</span><br><span class=\"line\">    cur = next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# K 个一组翻转链表\n\n给你一个链表，每  k  个节点一组进行翻转，请你返回翻转后的链表。\nk  是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是  k  的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n进阶：\n\n- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n- 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n[链接](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n```ts\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n  let a = head\n  let b = head\n  for (let i = 0; i < k; i++) {\n    if (b == null) return head\n    b = b.next\n  }\n  const newHead = reverse(a, b)\n  a.next = reverseKGroup(b, k)\n  return newHead\n}\n\nconst reverse = function(a: ListNode, b: ListNode) {\n  let pre: ListNode, cur: ListNode, nxt: ListNode\n  pre = null\n  cur = a\n  nxt = a\n  while(cur != b) {\n    nxt = cur.next\n    cur.next = pre\n    pre = cur\n    cur = nxt\n  }\n  return pre\n}\n```\n","source":"leetcode/链表/25.K个一组翻转链表.md","raw":"# K 个一组翻转链表\n\n给你一个链表，每  k  个节点一组进行翻转，请你返回翻转后的链表。\nk  是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是  k  的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n进阶：\n\n- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n- 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n[链接](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n```ts\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n  let a = head\n  let b = head\n  for (let i = 0; i < k; i++) {\n    if (b == null) return head\n    b = b.next\n  }\n  const newHead = reverse(a, b)\n  a.next = reverseKGroup(b, k)\n  return newHead\n}\n\nconst reverse = function(a: ListNode, b: ListNode) {\n  let pre: ListNode, cur: ListNode, nxt: ListNode\n  pre = null\n  cur = a\n  nxt = a\n  while(cur != b) {\n    nxt = cur.next\n    cur.next = pre\n    pre = cur\n    cur = nxt\n  }\n  return pre\n}\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.595Z","path":"leetcode/链表/25.K个一组翻转链表.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003gtnw7erqr4e77","content":"<h1 id=\"K-个一组翻转链表\"><a href=\"#K-个一组翻转链表\" class=\"headerlink\" title=\"K 个一组翻转链表\"></a>K 个一组翻转链表</h1><p>给你一个链表，每  k  个节点一组进行翻转，请你返回翻转后的链表。<br>k  是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是  k  的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p>进阶：</p>\n<ul>\n<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n<li>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reverseKGroup</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span>, k: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">ListNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = head</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    b = b.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newHead = <span class=\"title function_\">reverse</span>(a, b)</span><br><span class=\"line\">  a.<span class=\"property\">next</span> = <span class=\"title function_\">reverseKGroup</span>(b, k)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newHead</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reverse = <span class=\"keyword\">function</span>(<span class=\"params\">a: ListNode, b: ListNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">pre</span>: <span class=\"title class_\">ListNode</span>, <span class=\"attr\">cur</span>: <span class=\"title class_\">ListNode</span>, <span class=\"attr\">nxt</span>: <span class=\"title class_\">ListNode</span></span><br><span class=\"line\">  pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  cur = a</span><br><span class=\"line\">  nxt = a</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(cur != b) &#123;</span><br><span class=\"line\">    nxt = cur.<span class=\"property\">next</span></span><br><span class=\"line\">    cur.<span class=\"property\">next</span> = pre</span><br><span class=\"line\">    pre = cur</span><br><span class=\"line\">    cur = nxt</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"K-个一组翻转链表\"><a href=\"#K-个一组翻转链表\" class=\"headerlink\" title=\"K 个一组翻转链表\"></a>K 个一组翻转链表</h1><p>给你一个链表，每  k  个节点一组进行翻转，请你返回翻转后的链表。<br>k  是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是  k  的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p>进阶：</p>\n<ul>\n<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n<li>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</li>\n</ul>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\">链接</a></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reverseKGroup</span>(<span class=\"params\">head: ListNode | <span class=\"literal\">null</span>, k: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">ListNode</span> | <span class=\"literal\">null</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = head</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = head</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    b = b.<span class=\"property\">next</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newHead = <span class=\"title function_\">reverse</span>(a, b)</span><br><span class=\"line\">  a.<span class=\"property\">next</span> = <span class=\"title function_\">reverseKGroup</span>(b, k)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newHead</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reverse = <span class=\"keyword\">function</span>(<span class=\"params\">a: ListNode, b: ListNode</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">pre</span>: <span class=\"title class_\">ListNode</span>, <span class=\"attr\">cur</span>: <span class=\"title class_\">ListNode</span>, <span class=\"attr\">nxt</span>: <span class=\"title class_\">ListNode</span></span><br><span class=\"line\">  pre = <span class=\"literal\">null</span></span><br><span class=\"line\">  cur = a</span><br><span class=\"line\">  nxt = a</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(cur != b) &#123;</span><br><span class=\"line\">    nxt = cur.<span class=\"property\">next</span></span><br><span class=\"line\">    cur.<span class=\"property\">next</span> = pre</span><br><span class=\"line\">    pre = cur</span><br><span class=\"line\">    cur = nxt</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 12. 整数转罗马数字\n\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n字符 数值\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给你一个整数，将其转为罗马数字。\n\n```ts\nfunction intToRoman(num: number): string {\n  const map = new Map([\n    [1000, 'M'],\n    [900, 'CM'],\n    [500, 'D'],\n    [400, 'CD'],\n    [100, 'C'],\n    [90, 'XC'],\n    [50, 'L'],\n    [40, 'XL'],\n    [10, 'X'],\n    [9, 'IX'],\n    [5, 'V'],\n    [4, 'IV'],\n    [1, 'I'],\n  ]);\n\n\n  let res = '';\n\n  map.forEach((value, key) => {\n    const count = Math.floor(num / key);\n    if (count !== 0) {\n      res += Array(count).fill(value).join('');\n      num %= key;\n    }\n  })\n\n  return res;\n};\n```\n","source":"leetcode/面试经典150题/12.整数转罗马数字.md","raw":"# 12. 整数转罗马数字\n\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n字符 数值\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给你一个整数，将其转为罗马数字。\n\n```ts\nfunction intToRoman(num: number): string {\n  const map = new Map([\n    [1000, 'M'],\n    [900, 'CM'],\n    [500, 'D'],\n    [400, 'CD'],\n    [100, 'C'],\n    [90, 'XC'],\n    [50, 'L'],\n    [40, 'XL'],\n    [10, 'X'],\n    [9, 'IX'],\n    [5, 'V'],\n    [4, 'IV'],\n    [1, 'I'],\n  ]);\n\n\n  let res = '';\n\n  map.forEach((value, key) => {\n    const count = Math.floor(num / key);\n    if (count !== 0) {\n      res += Array(count).fill(value).join('');\n      num %= key;\n    }\n  })\n\n  return res;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.603Z","path":"leetcode/面试经典150题/12.整数转罗马数字.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003htnw76v4p9f84","content":"<h1 id=\"12-整数转罗马数字\"><a href=\"#12-整数转罗马数字\" class=\"headerlink\" title=\"12. 整数转罗马数字\"></a>12. 整数转罗马数字</h1><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>\n<p>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">intToRoman</span>(<span class=\"params\">num: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">    [<span class=\"number\">1000</span>, <span class=\"string\">&#x27;M&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">900</span>, <span class=\"string\">&#x27;CM&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">500</span>, <span class=\"string\">&#x27;D&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">400</span>, <span class=\"string\">&#x27;CD&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">100</span>, <span class=\"string\">&#x27;C&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">90</span>, <span class=\"string\">&#x27;XC&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">50</span>, <span class=\"string\">&#x27;L&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">40</span>, <span class=\"string\">&#x27;XL&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">10</span>, <span class=\"string\">&#x27;X&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">9</span>, <span class=\"string\">&#x27;IX&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">5</span>, <span class=\"string\">&#x27;V&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">4</span>, <span class=\"string\">&#x27;IV&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"string\">&#x27;I&#x27;</span>],</span><br><span class=\"line\">  ]);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  map.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(num / key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res += <span class=\"title class_\">Array</span>(count).<span class=\"title function_\">fill</span>(value).<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">      num %= key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"12-整数转罗马数字\"><a href=\"#12-整数转罗马数字\" class=\"headerlink\" title=\"12. 整数转罗马数字\"></a>12. 整数转罗马数字</h1><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>\n<p>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">intToRoman</span>(<span class=\"params\">num: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">    [<span class=\"number\">1000</span>, <span class=\"string\">&#x27;M&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">900</span>, <span class=\"string\">&#x27;CM&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">500</span>, <span class=\"string\">&#x27;D&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">400</span>, <span class=\"string\">&#x27;CD&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">100</span>, <span class=\"string\">&#x27;C&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">90</span>, <span class=\"string\">&#x27;XC&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">50</span>, <span class=\"string\">&#x27;L&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">40</span>, <span class=\"string\">&#x27;XL&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">10</span>, <span class=\"string\">&#x27;X&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">9</span>, <span class=\"string\">&#x27;IX&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">5</span>, <span class=\"string\">&#x27;V&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">4</span>, <span class=\"string\">&#x27;IV&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"string\">&#x27;I&#x27;</span>],</span><br><span class=\"line\">  ]);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  map.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(num / key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res += <span class=\"title class_\">Array</span>(count).<span class=\"title function_\">fill</span>(value).<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">      num %= key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 121. 买卖股票的最佳时机\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n```ts\nfunction maxProfit(prices: number[]): number {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n\n  for(let i = 0; i < prices.length;i++) {\n    if (prices[i] < minPrice) {\n      minPrice = prices[i];\n    } else if (prices[i] - minPrice > maxProfit) {\n      maxProfit = prices[i] - minPrice;\n    }\n  }\n  return maxProfit;\n};\n```\n","source":"leetcode/面试经典150题/121.买卖股票的最佳时机.md","raw":"# 121. 买卖股票的最佳时机\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n```ts\nfunction maxProfit(prices: number[]): number {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n\n  for(let i = 0; i < prices.length;i++) {\n    if (prices[i] < minPrice) {\n      minPrice = prices[i];\n    } else if (prices[i] - minPrice > maxProfit) {\n      maxProfit = prices[i] - minPrice;\n    }\n  }\n  return maxProfit;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.603Z","path":"leetcode/面试经典150题/121.买卖股票的最佳时机.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003itnw74hv2gi3v","content":"<h1 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>\n<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxProfit</span>(<span class=\"params\">prices: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minPrice = <span class=\"title class_\">Infinity</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxProfit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; prices.<span class=\"property\">length</span>;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class=\"line\">      minPrice = prices[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prices[i] - minPrice &gt; maxProfit) &#123;</span><br><span class=\"line\">      maxProfit = prices[i] - minPrice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxProfit;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>\n<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxProfit</span>(<span class=\"params\">prices: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minPrice = <span class=\"title class_\">Infinity</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxProfit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; prices.<span class=\"property\">length</span>;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class=\"line\">      minPrice = prices[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prices[i] - minPrice &gt; maxProfit) &#123;</span><br><span class=\"line\">      maxProfit = prices[i] - minPrice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxProfit;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 122. 买卖股票的最佳时机 II\n\n给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n\n返回 你能获得的 最大 利润 。\n\n## dptable\n\n可以创建一个二维数组\n0 代表卖出，1 代表买进\n\n```ts\nfunction maxProfit(prices: number[]): number {\n  if (prices.length < 2) return 0;\n  // 0卖出 1买入\n  const dpTable: number[][] = Array.from(Array(prices.length), () => Array(2).fill(0));\n  // 初始化第一天\n  dpTable[0][0] = 0;\n  dpTable[0][1] = -prices[0];\n  for(let i = 1; i < prices.length; i++) {\n    dpTable[i][0] = Math.max(dpTable[i - 1][0], dpTable[i - 1][1] + prices[i]);\n    dpTable[i][1] = Math.max(dpTable[i - 1][0] - prices[i], dpTable[i - 1][1]);\n  }\n  return dpTable[prices.length - 1][0];\n};\n\n```\n","source":"leetcode/面试经典150题/122.买卖股票的最佳时机II.md","raw":"# 122. 买卖股票的最佳时机 II\n\n给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n\n返回 你能获得的 最大 利润 。\n\n## dptable\n\n可以创建一个二维数组\n0 代表卖出，1 代表买进\n\n```ts\nfunction maxProfit(prices: number[]): number {\n  if (prices.length < 2) return 0;\n  // 0卖出 1买入\n  const dpTable: number[][] = Array.from(Array(prices.length), () => Array(2).fill(0));\n  // 初始化第一天\n  dpTable[0][0] = 0;\n  dpTable[0][1] = -prices[0];\n  for(let i = 1; i < prices.length; i++) {\n    dpTable[i][0] = Math.max(dpTable[i - 1][0], dpTable[i - 1][1] + prices[i]);\n    dpTable[i][1] = Math.max(dpTable[i - 1][0] - prices[i], dpTable[i - 1][1]);\n  }\n  return dpTable[prices.length - 1][0];\n};\n\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.604Z","path":"leetcode/面试经典150题/122.买卖股票的最佳时机II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003jtnw7e5un25hk","content":"<h1 id=\"122-买卖股票的最佳时机-II\"><a href=\"#122-买卖股票的最佳时机-II\" class=\"headerlink\" title=\"122. 买卖股票的最佳时机 II\"></a>122. 买卖股票的最佳时机 II</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>\n<p>返回 你能获得的 最大 利润 。</p>\n<h2 id=\"dptable\"><a href=\"#dptable\" class=\"headerlink\" title=\"dptable\"></a>dptable</h2><p>可以创建一个二维数组<br>0 代表卖出，1 代表买进</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxProfit</span>(<span class=\"params\">prices: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prices.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 0卖出 1买入</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"built_in\">number</span>[][] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(prices.<span class=\"property\">length</span>), <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Array</span>(<span class=\"number\">2</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">  <span class=\"comment\">// 初始化第一天</span></span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    dpTable[i][<span class=\"number\">0</span>] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">    dpTable[i][<span class=\"number\">1</span>] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i], dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dpTable[prices.<span class=\"property\">length</span> - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"122-买卖股票的最佳时机-II\"><a href=\"#122-买卖股票的最佳时机-II\" class=\"headerlink\" title=\"122. 买卖股票的最佳时机 II\"></a>122. 买卖股票的最佳时机 II</h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>\n<p>返回 你能获得的 最大 利润 。</p>\n<h2 id=\"dptable\"><a href=\"#dptable\" class=\"headerlink\" title=\"dptable\"></a>dptable</h2><p>可以创建一个二维数组<br>0 代表卖出，1 代表买进</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxProfit</span>(<span class=\"params\">prices: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prices.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 0卖出 1买入</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">dpTable</span>: <span class=\"built_in\">number</span>[][] = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"title class_\">Array</span>(prices.<span class=\"property\">length</span>), <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Array</span>(<span class=\"number\">2</span>).<span class=\"title function_\">fill</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">  <span class=\"comment\">// 初始化第一天</span></span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  dpTable[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    dpTable[i][<span class=\"number\">0</span>] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">    dpTable[i][<span class=\"number\">1</span>] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i], dpTable[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dpTable[prices.<span class=\"property\">length</span> - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 13. 罗马数字转整数\n\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符 数值\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。\n\n```ts\nfunction romanToInt(s: string): number {\n  const valuesMap = new Map();\n  valuesMap.set('I', 1);\n  valuesMap.set('V', 5);\n  valuesMap.set('X', 10);\n  valuesMap.set('L', 50);\n  valuesMap.set('C', 100);\n  valuesMap.set('D', 500);\n  valuesMap.set('M', 1000);\n\n  let ans = 0;\n  const n = s.length;\n  for(let i = 0; i < n; i++) {\n    const value = valuesMap.get(s[i]);\n    if (i < n - 1 && value < valuesMap.get(s[i + 1])) {\n      ans -= value;\n    } else {\n      ans += value;\n    }\n  }\n\n  return ans;\n};\n```\n","source":"leetcode/面试经典150题/13.罗马数字转整数.md","raw":"# 13. 罗马数字转整数\n\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符 数值\nI 1\nV 5\nX 10\nL 50\nC 100\nD 500\nM 1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。\n\n```ts\nfunction romanToInt(s: string): number {\n  const valuesMap = new Map();\n  valuesMap.set('I', 1);\n  valuesMap.set('V', 5);\n  valuesMap.set('X', 10);\n  valuesMap.set('L', 50);\n  valuesMap.set('C', 100);\n  valuesMap.set('D', 500);\n  valuesMap.set('M', 1000);\n\n  let ans = 0;\n  const n = s.length;\n  for(let i = 0; i < n; i++) {\n    const value = valuesMap.get(s[i]);\n    if (i < n - 1 && value < valuesMap.get(s[i + 1])) {\n      ans -= value;\n    } else {\n      ans += value;\n    }\n  }\n\n  return ans;\n};\n```\n","date":"2023-10-11T15:10:43.210Z","updated":"2023-09-26T14:49:23.602Z","path":"leetcode/面试经典150题/13.罗马数字转整数.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003ktnw7aoctekmx","content":"<h1 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a>13. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<p>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">romanToInt</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> valuesMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;I&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = valuesMap.<span class=\"title function_\">get</span>(s[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; n - <span class=\"number\">1</span> &amp;&amp; value &lt; valuesMap.<span class=\"title function_\">get</span>(s[i + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">      ans -= value;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ans += value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13. 罗马数字转整数\"></a>13. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<p>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">romanToInt</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> valuesMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;I&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;V&#x27;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;X&#x27;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;L&#x27;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">  valuesMap.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;M&#x27;</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = valuesMap.<span class=\"title function_\">get</span>(s[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; n - <span class=\"number\">1</span> &amp;&amp; value &lt; valuesMap.<span class=\"title function_\">get</span>(s[i + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">      ans -= value;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ans += value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 125. 验证回文串\n\n如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。\n\n字母和数字都属于字母数字字符。\n\n给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。\n\n```ts\nconst isTargetChar = (ascii: number) => {\n  return ascii >= 65 && ascii <= 90 || ascii >= 97 && ascii <= 122 || ascii >= 48 && ascii <= 57;\n};\n\nfunction isPalindrome(s: string): boolean {\n  let left = 0;\n  let right = s.length - 1;\n  while(left <= right) {\n    while(!isTargetChar(s.charCodeAt(left)) && left < s.length - 1) left++;\n    while(!isTargetChar(s.charCodeAt(right)) && right > left) right--;\n    if (left >= right) break;\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n};\n```\n","source":"leetcode/面试经典150题/125.验证回文串.md","raw":"# 125. 验证回文串\n\n如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。\n\n字母和数字都属于字母数字字符。\n\n给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。\n\n```ts\nconst isTargetChar = (ascii: number) => {\n  return ascii >= 65 && ascii <= 90 || ascii >= 97 && ascii <= 122 || ascii >= 48 && ascii <= 57;\n};\n\nfunction isPalindrome(s: string): boolean {\n  let left = 0;\n  let right = s.length - 1;\n  while(left <= right) {\n    while(!isTargetChar(s.charCodeAt(left)) && left < s.length - 1) left++;\n    while(!isTargetChar(s.charCodeAt(right)) && right > left) right--;\n    if (left >= right) break;\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-10-07T06:05:50.675Z","path":"leetcode/面试经典150题/125.验证回文串.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003ltnw72wdo8g59","content":"<h1 id=\"125-验证回文串\"><a href=\"#125-验证回文串\" class=\"headerlink\" title=\"125. 验证回文串\"></a>125. 验证回文串</h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>\n<p>字母和数字都属于字母数字字符。</p>\n<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isTargetChar</span> = (<span class=\"params\">ascii: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ascii &gt;= <span class=\"number\">65</span> &amp;&amp; ascii &lt;= <span class=\"number\">90</span> || ascii &gt;= <span class=\"number\">97</span> &amp;&amp; ascii &lt;= <span class=\"number\">122</span> || ascii &gt;= <span class=\"number\">48</span> &amp;&amp; ascii &lt;= <span class=\"number\">57</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPalindrome</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = s.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"title function_\">isTargetChar</span>(s.<span class=\"title function_\">charCodeAt</span>(left)) &amp;&amp; left &lt; s.<span class=\"property\">length</span> - <span class=\"number\">1</span>) left++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"title function_\">isTargetChar</span>(s.<span class=\"title function_\">charCodeAt</span>(right)) &amp;&amp; right &gt; left) right--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[left].<span class=\"title function_\">toLowerCase</span>() !== s[right].<span class=\"title function_\">toLowerCase</span>()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left++;</span><br><span class=\"line\">    right--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"125-验证回文串\"><a href=\"#125-验证回文串\" class=\"headerlink\" title=\"125. 验证回文串\"></a>125. 验证回文串</h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>\n<p>字母和数字都属于字母数字字符。</p>\n<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isTargetChar</span> = (<span class=\"params\">ascii: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ascii &gt;= <span class=\"number\">65</span> &amp;&amp; ascii &lt;= <span class=\"number\">90</span> || ascii &gt;= <span class=\"number\">97</span> &amp;&amp; ascii &lt;= <span class=\"number\">122</span> || ascii &gt;= <span class=\"number\">48</span> &amp;&amp; ascii &lt;= <span class=\"number\">57</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPalindrome</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = s.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"title function_\">isTargetChar</span>(s.<span class=\"title function_\">charCodeAt</span>(left)) &amp;&amp; left &lt; s.<span class=\"property\">length</span> - <span class=\"number\">1</span>) left++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"title function_\">isTargetChar</span>(s.<span class=\"title function_\">charCodeAt</span>(right)) &amp;&amp; right &gt; left) right--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[left].<span class=\"title function_\">toLowerCase</span>() !== s[right].<span class=\"title function_\">toLowerCase</span>()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left++;</span><br><span class=\"line\">    right--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 14. 最长公共前缀\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 \"\"。\n\n```ts\nfunction longestCommonPrefix(strs: string[]): string {\n  let res = '';\n  if (strs.length === 1) return strs[0];\n  const target = strs[0];\n  let len = target.length;\n  for(let i = 0; i < len; i++) {\n    let isSame = false;\n    for(let j = 1; j < strs.length; j++) {\n      if (target[i] !== strs[j][i]) {\n        isSame = false;\n        break;\n      }\n      isSame = true;\n    }\n    if (isSame) {\n      res += target[i];\n    } else {\n      break;\n    }\n  }\n\n  return res;\n};\n```\n","source":"leetcode/面试经典150题/14.最长公共前缀.md","raw":"# 14. 最长公共前缀\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 \"\"。\n\n```ts\nfunction longestCommonPrefix(strs: string[]): string {\n  let res = '';\n  if (strs.length === 1) return strs[0];\n  const target = strs[0];\n  let len = target.length;\n  for(let i = 0; i < len; i++) {\n    let isSame = false;\n    for(let j = 1; j < strs.length; j++) {\n      if (target[i] !== strs[j][i]) {\n        isSame = false;\n        break;\n      }\n      isSame = true;\n    }\n    if (isSame) {\n      res += target[i];\n    } else {\n      break;\n    }\n  }\n\n  return res;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.605Z","path":"leetcode/面试经典150题/14.最长公共前缀.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003mtnw706cidulw","content":"<h1 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a>14. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 “”。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">longestCommonPrefix</span>(<span class=\"params\">strs: <span class=\"built_in\">string</span>[]</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs.<span class=\"property\">length</span> === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> target = strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = target.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; strs.<span class=\"property\">length</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target[i] !== strs[j][i]) &#123;</span><br><span class=\"line\">        isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      isSame = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSame) &#123;</span><br><span class=\"line\">      res += target[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14. 最长公共前缀\"></a>14. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 “”。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">longestCommonPrefix</span>(<span class=\"params\">strs: <span class=\"built_in\">string</span>[]</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs.<span class=\"property\">length</span> === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> target = strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = target.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; strs.<span class=\"property\">length</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target[i] !== strs[j][i]) &#123;</span><br><span class=\"line\">        isSame = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      isSame = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSame) &#123;</span><br><span class=\"line\">      res += target[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 151. 反转字符串中的单词\n\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n\n注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n\n```ts\nfunction reverseWords(s: string): string {\n  let res = '';\n  let str = '';\n  for(let i = s.length - 1; i >= 0; i--) {\n    if (s[i] !== ' ') {\n      str = s[i] + str;\n    }\n    if (s[i] === ' ' && str) {\n      res += `${str} `;\n      str = ''\n    }\n  }\n\n  if (str) {\n    res += `${str}`;\n  } else {\n    res = res.slice(0, res.length - 1);\n  }\n\n  return res;\n};\n```\n","source":"leetcode/面试经典150题/151.反转字符串中的单词.md","raw":"# 151. 反转字符串中的单词\n\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n\n注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n\n```ts\nfunction reverseWords(s: string): string {\n  let res = '';\n  let str = '';\n  for(let i = s.length - 1; i >= 0; i--) {\n    if (s[i] !== ' ') {\n      str = s[i] + str;\n    }\n    if (s[i] === ' ' && str) {\n      res += `${str} `;\n      str = ''\n    }\n  }\n\n  if (str) {\n    res += `${str}`;\n  } else {\n    res = res.slice(0, res.length - 1);\n  }\n\n  return res;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.605Z","path":"leetcode/面试经典150题/151.反转字符串中的单词.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003ntnw73ctufh5h","content":"<h1 id=\"151-反转字符串中的单词\"><a href=\"#151-反转字符串中的单词\" class=\"headerlink\" title=\"151. 反转字符串中的单词\"></a>151. 反转字符串中的单词</h1><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>\n<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>\n<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>\n<p>注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reverseWords</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = s.<span class=\"property\">length</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">      str = s[i] + str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; str) &#123;</span><br><span class=\"line\">      res += <span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span> `</span>;</span><br><span class=\"line\">      str = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (str) &#123;</span><br><span class=\"line\">    res += <span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span>`</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    res = res.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, res.<span class=\"property\">length</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"151-反转字符串中的单词\"><a href=\"#151-反转字符串中的单词\" class=\"headerlink\" title=\"151. 反转字符串中的单词\"></a>151. 反转字符串中的单词</h1><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>\n<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>\n<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>\n<p>注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reverseWords</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = s.<span class=\"property\">length</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">      str = s[i] + str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; str) &#123;</span><br><span class=\"line\">      res += <span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span> `</span>;</span><br><span class=\"line\">      str = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (str) &#123;</span><br><span class=\"line\">    res += <span class=\"string\">`<span class=\"subst\">$&#123;str&#125;</span>`</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    res = res.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, res.<span class=\"property\">length</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 167. 两数之和 II - 输入有序数组\n\n中等\n\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n```ts\nfunction twoSum(numbers: number[], target: number): number[] {\n  let left = 0;\n  let right = numbers.length - 1;\n  while(left < right) {\n    const sum = numbers[left] + numbers[right];\n    if (sum < target) {\n      left++;\n    } else if (sum > target) {\n      right--;\n    } else {\n      return [left + 1, right + 1];\n    }\n  }\n  return [left + 1, right + 1];\n};\n```\n","source":"leetcode/面试经典150题/167.两数之和II-输入有序数组.md","raw":"# 167. 两数之和 II - 输入有序数组\n\n中等\n\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n```ts\nfunction twoSum(numbers: number[], target: number): number[] {\n  let left = 0;\n  let right = numbers.length - 1;\n  while(left < right) {\n    const sum = numbers[left] + numbers[right];\n    if (sum < target) {\n      left++;\n    } else if (sum > target) {\n      right--;\n    } else {\n      return [left + 1, right + 1];\n    }\n  }\n  return [left + 1, right + 1];\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-10-11T14:42:54.573Z","path":"leetcode/面试经典150题/167.两数之和II-输入有序数组.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003otnw79t0h0yrc","content":"<h1 id=\"167-两数之和-II-输入有序数组\"><a href=\"#167-两数之和-II-输入有序数组\" class=\"headerlink\" title=\"167. 两数之和 II - 输入有序数组\"></a>167. 两数之和 II - 输入有序数组</h1><p>中等</p>\n<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p>\n<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>\n<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>\n<p>你所设计的解决方案必须只使用常量级的额外空间。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">twoSum</span>(<span class=\"params\">numbers: <span class=\"built_in\">number</span>[], target: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = numbers.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sum = numbers[left] + numbers[right];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum &lt; target) &#123;</span><br><span class=\"line\">      left++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">      right--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [left + <span class=\"number\">1</span>, right + <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [left + <span class=\"number\">1</span>, right + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"167-两数之和-II-输入有序数组\"><a href=\"#167-两数之和-II-输入有序数组\" class=\"headerlink\" title=\"167. 两数之和 II - 输入有序数组\"></a>167. 两数之和 II - 输入有序数组</h1><p>中等</p>\n<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p>\n<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>\n<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>\n<p>你所设计的解决方案必须只使用常量级的额外空间。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">twoSum</span>(<span class=\"params\">numbers: <span class=\"built_in\">number</span>[], target: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = numbers.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sum = numbers[left] + numbers[right];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum &lt; target) &#123;</span><br><span class=\"line\">      left++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">      right--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [left + <span class=\"number\">1</span>, right + <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [left + <span class=\"number\">1</span>, right + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 134. 加油站\n\n在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n\n给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\n\n## 解法\n\n用图解的思维去来解决\n\n```ts\nfunction canCompleteCircuit(gas: number[], cost: number[]): number {\n  const len = gas.length;\n  let spare = 0;\n  let minSpare = Infinity;\n  let minIndex = 0;\n\n  for(let i = 0; i < len; i++) {\n    spare += gas[i] - cost[i];\n    if (spare < minSpare) {\n      minSpare = spare;\n      minIndex = i;\n    }\n  }\n\n  if (minSpare > 0) return 0;\n\n  return spare < 0 ? - 1 : (minIndex + 1) % len;\n};\n```\n","source":"leetcode/面试经典150题/134.加油站.md","raw":"# 134. 加油站\n\n在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n\n给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\n\n## 解法\n\n用图解的思维去来解决\n\n```ts\nfunction canCompleteCircuit(gas: number[], cost: number[]): number {\n  const len = gas.length;\n  let spare = 0;\n  let minSpare = Infinity;\n  let minIndex = 0;\n\n  for(let i = 0; i < len; i++) {\n    spare += gas[i] - cost[i];\n    if (spare < minSpare) {\n      minSpare = spare;\n      minIndex = i;\n    }\n  }\n\n  if (minSpare > 0) return 0;\n\n  return spare < 0 ? - 1 : (minIndex + 1) % len;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.604Z","path":"leetcode/面试经典150题/134.加油站.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxu003ptnw7f5w854bf","content":"<h1 id=\"134-加油站\"><a href=\"#134-加油站\" class=\"headerlink\" title=\"134. 加油站\"></a>134. 加油站</h1><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>\n<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>\n<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><p>用图解的思维去来解决</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">canCompleteCircuit</span>(<span class=\"params\">gas: <span class=\"built_in\">number</span>[], cost: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = gas.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> spare = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minSpare = <span class=\"title class_\">Infinity</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    spare += gas[i] - cost[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (spare &lt; minSpare) &#123;</span><br><span class=\"line\">      minSpare = spare;</span><br><span class=\"line\">      minIndex = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minSpare &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> spare &lt; <span class=\"number\">0</span> ? - <span class=\"number\">1</span> : (minIndex + <span class=\"number\">1</span>) % len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"134-加油站\"><a href=\"#134-加油站\" class=\"headerlink\" title=\"134. 加油站\"></a>134. 加油站</h1><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>\n<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>\n<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><p>用图解的思维去来解决</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">canCompleteCircuit</span>(<span class=\"params\">gas: <span class=\"built_in\">number</span>[], cost: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = gas.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> spare = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minSpare = <span class=\"title class_\">Infinity</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    spare += gas[i] - cost[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (spare &lt; minSpare) &#123;</span><br><span class=\"line\">      minSpare = spare;</span><br><span class=\"line\">      minIndex = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minSpare &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> spare &lt; <span class=\"number\">0</span> ? - <span class=\"number\">1</span> : (minIndex + <span class=\"number\">1</span>) % len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 169. 多数元素\n\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n```ts\nfunction majorityElement(nums: number[]): number {\n  const timesMap: Record<string, number> = {};\n  const len = nums.length;\n  let maxTimes = 0;\n  let maxNum = 0;\n  for(let i = 0;i < len;i++) {\n    const num = nums[i];\n    const times = (timesMap[nums[i]] || 0) + 1;\n    timesMap[nums[i]] = times;\n    if (maxTimes < times) {\n      maxNum = num;\n      maxTimes = times;\n    }\n  }\n  return maxNum;\n};\n```\n","source":"leetcode/面试经典150题/169.多数元素.md","raw":"# 169. 多数元素\n\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n```ts\nfunction majorityElement(nums: number[]): number {\n  const timesMap: Record<string, number> = {};\n  const len = nums.length;\n  let maxTimes = 0;\n  let maxNum = 0;\n  for(let i = 0;i < len;i++) {\n    const num = nums[i];\n    const times = (timesMap[nums[i]] || 0) + 1;\n    timesMap[nums[i]] = times;\n    if (maxTimes < times) {\n      maxNum = num;\n      maxTimes = times;\n    }\n  }\n  return maxNum;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.606Z","path":"leetcode/面试经典150题/169.多数元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003qtnw74un1g8zu","content":"<h1 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169. 多数元素\"></a>169. 多数元素</h1><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">majorityElement</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">timesMap</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxTimes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; len;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> num = nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> times = (timesMap[nums[i]] || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    timesMap[nums[i]] = times;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTimes &lt; times) &#123;</span><br><span class=\"line\">      maxNum = num;</span><br><span class=\"line\">      maxTimes = times;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxNum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169. 多数元素\"></a>169. 多数元素</h1><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">majorityElement</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">timesMap</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>&gt; = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxTimes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> maxNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; len;i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> num = nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> times = (timesMap[nums[i]] || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    timesMap[nums[i]] = times;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTimes &lt; times) &#123;</span><br><span class=\"line\">      maxNum = num;</span><br><span class=\"line\">      maxTimes = times;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxNum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 189. 轮转数组\n\n给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n\n暴力解法\n第一个和最后一个交换\n第二个开始和最后一个交换\n循环 K 次\n\n```ts\n/**\n Do not return anything, modify nums in-place instead.\n */\nfunction rotate(nums: number[], k: number): void {\n  const lastIndex = nums.length - 1;\n  for(let i = 0; i < k; i++) {\n    const temp = nums[0];\n    nums[0] = nums[lastIndex];\n    nums[lastIndex] = temp;\n    for(let j = 1; j < nums.length - 1; j++) {\n      const temp = nums[j];\n      nums[j] = nums[lastIndex];\n      nums[lastIndex] = temp;\n    }\n  }\n};\n```\n\n翻转数组\n先翻转整个数组\n再翻转 0 到 k -1 数组\n再翻转 k-1 到 length - 1 数组\n\n```ts\nconst reverse = (nums: number[], start: number, end: number) => {\n  while(start < end) {\n    const temp = nums[start];\n    nums[start] = nums[end];\n    nums[end] = temp;\n    start += 1;\n    end -= 1;\n  }\n}\n\n/**\n Do not return anything, modify nums in-place instead.\n */\nfunction rotate(nums: number[], k: number): void {\n  k %= nums.length;\n  reverse(nums, 0, nums.length - 1);\n  reverse(nums, 0, k - 1);\n  reverse(nums, k, nums.length - 1);\n};\n```\n","source":"leetcode/面试经典150题/189.轮转数组.md","raw":"# 189. 轮转数组\n\n给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n\n暴力解法\n第一个和最后一个交换\n第二个开始和最后一个交换\n循环 K 次\n\n```ts\n/**\n Do not return anything, modify nums in-place instead.\n */\nfunction rotate(nums: number[], k: number): void {\n  const lastIndex = nums.length - 1;\n  for(let i = 0; i < k; i++) {\n    const temp = nums[0];\n    nums[0] = nums[lastIndex];\n    nums[lastIndex] = temp;\n    for(let j = 1; j < nums.length - 1; j++) {\n      const temp = nums[j];\n      nums[j] = nums[lastIndex];\n      nums[lastIndex] = temp;\n    }\n  }\n};\n```\n\n翻转数组\n先翻转整个数组\n再翻转 0 到 k -1 数组\n再翻转 k-1 到 length - 1 数组\n\n```ts\nconst reverse = (nums: number[], start: number, end: number) => {\n  while(start < end) {\n    const temp = nums[start];\n    nums[start] = nums[end];\n    nums[end] = temp;\n    start += 1;\n    end -= 1;\n  }\n}\n\n/**\n Do not return anything, modify nums in-place instead.\n */\nfunction rotate(nums: number[], k: number): void {\n  k %= nums.length;\n  reverse(nums, 0, nums.length - 1);\n  reverse(nums, 0, k - 1);\n  reverse(nums, k, nums.length - 1);\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.607Z","path":"leetcode/面试经典150题/189.轮转数组.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003rtnw765drcosr","content":"<h1 id=\"189-轮转数组\"><a href=\"#189-轮转数组\" class=\"headerlink\" title=\"189. 轮转数组\"></a>189. 轮转数组</h1><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>\n<p>暴力解法<br>第一个和最后一个交换<br>第二个开始和最后一个交换<br>循环 K 次</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rotate</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lastIndex = nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = nums[lastIndex];</span><br><span class=\"line\">    nums[lastIndex] = temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> temp = nums[j];</span><br><span class=\"line\">      nums[j] = nums[lastIndex];</span><br><span class=\"line\">      nums[lastIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>翻转数组<br>先翻转整个数组<br>再翻转 0 到 k -1 数组<br>再翻转 k-1 到 length - 1 数组</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">reverse</span> = (<span class=\"params\">nums: <span class=\"built_in\">number</span>[], start: <span class=\"built_in\">number</span>, end: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(start &lt; end) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = nums[start];</span><br><span class=\"line\">    nums[start] = nums[end];</span><br><span class=\"line\">    nums[end] = temp;</span><br><span class=\"line\">    start += <span class=\"number\">1</span>;</span><br><span class=\"line\">    end -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rotate</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  k %= nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"title function_\">reverse</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"title function_\">reverse</span>(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"title function_\">reverse</span>(nums, k, nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"189-轮转数组\"><a href=\"#189-轮转数组\" class=\"headerlink\" title=\"189. 轮转数组\"></a>189. 轮转数组</h1><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>\n<p>暴力解法<br>第一个和最后一个交换<br>第二个开始和最后一个交换<br>循环 K 次</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rotate</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lastIndex = nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = nums[lastIndex];</span><br><span class=\"line\">    nums[lastIndex] = temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> temp = nums[j];</span><br><span class=\"line\">      nums[j] = nums[lastIndex];</span><br><span class=\"line\">      nums[lastIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>翻转数组<br>先翻转整个数组<br>再翻转 0 到 k -1 数组<br>再翻转 k-1 到 length - 1 数组</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">reverse</span> = (<span class=\"params\">nums: <span class=\"built_in\">number</span>[], start: <span class=\"built_in\">number</span>, end: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(start &lt; end) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = nums[start];</span><br><span class=\"line\">    nums[start] = nums[end];</span><br><span class=\"line\">    nums[end] = temp;</span><br><span class=\"line\">    start += <span class=\"number\">1</span>;</span><br><span class=\"line\">    end -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">rotate</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], k: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  k %= nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"title function_\">reverse</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"title function_\">reverse</span>(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"title function_\">reverse</span>(nums, k, nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 26. 删除有序数组中的重复项\n\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n返回 k 。\n\n```ts\nfunction removeDuplicates(nums: number[]): number {\n    let left = 0;\n    let len = nums.length;\n    for(let right = 1; right < len; right++) {\n        if (nums[left] !== nums[right]) {\n            left++;\n            nums[left] = nums[right];\n        }\n    }\n    return left + 1;\n};\n```\n","source":"leetcode/面试经典150题/26.删除有序数组中的重复项.md","raw":"# 26. 删除有序数组中的重复项\n\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n返回 k 。\n\n```ts\nfunction removeDuplicates(nums: number[]): number {\n    let left = 0;\n    let len = nums.length;\n    for(let right = 1; right < len; right++) {\n        if (nums[left] !== nums[right]) {\n            left++;\n            nums[left] = nums[right];\n        }\n    }\n    return left + 1;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.607Z","path":"leetcode/面试经典150题/26.删除有序数组中的重复项.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003stnw75sos2r7r","content":"<h1 id=\"26-删除有序数组中的重复项\"><a href=\"#26-删除有序数组中的重复项\" class=\"headerlink\" title=\"26. 删除有序数组中的重复项\"></a>26. 删除有序数组中的重复项</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>\n<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>\n<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeDuplicates</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> right = <span class=\"number\">1</span>; right &lt; len; right++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[left] !== nums[right]) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            nums[left] = nums[right];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"26-删除有序数组中的重复项\"><a href=\"#26-删除有序数组中的重复项\" class=\"headerlink\" title=\"26. 删除有序数组中的重复项\"></a>26. 删除有序数组中的重复项</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>\n<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>\n<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeDuplicates</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> right = <span class=\"number\">1</span>; right &lt; len; right++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[left] !== nums[right]) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            nums[left] = nums[right];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 27. 移除元素\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n## 粗暴解法\n\n```ts\nfunction removeElement(nums: number[], val: number): number {\n    let i = 0;\n    while (i < nums.length) {\n        if (nums[i] === val) {\n            nums.splice(i, 1);\n        } else {\n            i++\n        }\n    }\n    return nums.length;\n};\n```\n\n## 双指针\n\nleft指针是要改变的位置，right指针是遍历位，当right处的指不等于val的时候，表示是要保存下来的数据，直接替换left位置的数据，并且left++。\n\n```ts\nfunction removeElement(nums: number[], val: number): number {\n  let left = 0;\n  let len = nums.length\n  for(let right = 0; right < len; right++) {\n    if (nums[right] !== val) {\n      nums[left] = nums[right];\n      left++;\n    }\n  }\n  return left;\n};\n```\n","source":"leetcode/面试经典150题/27.移除元素.md","raw":"# 27. 移除元素\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n## 粗暴解法\n\n```ts\nfunction removeElement(nums: number[], val: number): number {\n    let i = 0;\n    while (i < nums.length) {\n        if (nums[i] === val) {\n            nums.splice(i, 1);\n        } else {\n            i++\n        }\n    }\n    return nums.length;\n};\n```\n\n## 双指针\n\nleft指针是要改变的位置，right指针是遍历位，当right处的指不等于val的时候，表示是要保存下来的数据，直接替换left位置的数据，并且left++。\n\n```ts\nfunction removeElement(nums: number[], val: number): number {\n  let left = 0;\n  let len = nums.length\n  for(let right = 0; right < len; right++) {\n    if (nums[right] !== val) {\n      nums[left] = nums[right];\n      left++;\n    }\n  }\n  return left;\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-09-26T14:49:23.608Z","path":"leetcode/面试经典150题/27.移除元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003ttnw721vy6jmi","content":"<h1 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<h2 id=\"粗暴解法\"><a href=\"#粗暴解法\" class=\"headerlink\" title=\"粗暴解法\"></a>粗暴解法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], val: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; nums.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] === val) &#123;</span><br><span class=\"line\">            nums.<span class=\"title function_\">splice</span>(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><p>left指针是要改变的位置，right指针是遍历位，当right处的指不等于val的时候，表示是要保存下来的数据，直接替换left位置的数据，并且left++。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], val: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> right = <span class=\"number\">0</span>; right &lt; len; right++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[right] !== val) &#123;</span><br><span class=\"line\">      nums[left] = nums[right];</span><br><span class=\"line\">      left++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<h2 id=\"粗暴解法\"><a href=\"#粗暴解法\" class=\"headerlink\" title=\"粗暴解法\"></a>粗暴解法</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], val: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; nums.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] === val) &#123;</span><br><span class=\"line\">            nums.<span class=\"title function_\">splice</span>(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><p>left指针是要改变的位置，right指针是遍历位，当right处的指不等于val的时候，表示是要保存下来的数据，直接替换left位置的数据，并且left++。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[], val: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> right = <span class=\"number\">0</span>; right &lt; len; right++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[right] !== val) &#123;</span><br><span class=\"line\">      nums[left] = nums[right];</span><br><span class=\"line\">      left++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 380. O(1) 时间插入、删除和获取随机元素\n\n实现 RandomizedSet 类：\n\nRandomizedSet() 初始化 RandomizedSet 对象\nbool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。\nbool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。\nint getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。\n你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。\n\n```ts\nclass RandomizedSet {\n    nums: number[];\n    map: Map<number,number>;\n    constructor() {\n      this.map = new Map();\n      this.nums = [];\n    }\n\n    insert(val: number): boolean {\n      if (this.map.has(val)) {\n        return false;\n      }\n      const lastIndex = this.nums.length;\n      this.nums.push(val);\n      this.map.set(val, lastIndex);\n      return true;\n    }\n\n    remove(val: number): boolean {\n      const index = this.map.get(val);\n      if (index === undefined) {\n        return false;\n      }\n      this.nums[index] = this.nums[this.nums.length - 1];\n      this.map.set(this.nums[index], index);\n      this.nums.pop();\n      this.map.delete(val);\n      return true;\n    }\n\n    getRandom(): number {\n      const index = Math.floor(Math.random() * this.nums.length);\n      return this.nums[index];\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * var obj = new RandomizedSet()\n * var param_1 = obj.insert(val)\n * var param_2 = obj.remove(val)\n * var param_3 = obj.getRandom()\n */\n```\n","source":"leetcode/面试经典150题/380.O(1)时间插入、删除和获取随机元素.md","raw":"# 380. O(1) 时间插入、删除和获取随机元素\n\n实现 RandomizedSet 类：\n\nRandomizedSet() 初始化 RandomizedSet 对象\nbool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。\nbool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。\nint getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。\n你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。\n\n```ts\nclass RandomizedSet {\n    nums: number[];\n    map: Map<number,number>;\n    constructor() {\n      this.map = new Map();\n      this.nums = [];\n    }\n\n    insert(val: number): boolean {\n      if (this.map.has(val)) {\n        return false;\n      }\n      const lastIndex = this.nums.length;\n      this.nums.push(val);\n      this.map.set(val, lastIndex);\n      return true;\n    }\n\n    remove(val: number): boolean {\n      const index = this.map.get(val);\n      if (index === undefined) {\n        return false;\n      }\n      this.nums[index] = this.nums[this.nums.length - 1];\n      this.map.set(this.nums[index], index);\n      this.nums.pop();\n      this.map.delete(val);\n      return true;\n    }\n\n    getRandom(): number {\n      const index = Math.floor(Math.random() * this.nums.length);\n      return this.nums[index];\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * var obj = new RandomizedSet()\n * var param_1 = obj.insert(val)\n * var param_2 = obj.remove(val)\n * var param_3 = obj.getRandom()\n */\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.608Z","path":"leetcode/面试经典150题/380.O(1)时间插入、删除和获取随机元素.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003utnw7hgdy87zm","content":"<h1 id=\"380-O-1-时间插入、删除和获取随机元素\"><a href=\"#380-O-1-时间插入、删除和获取随机元素\" class=\"headerlink\" title=\"380. O(1) 时间插入、删除和获取随机元素\"></a>380. O(1) 时间插入、删除和获取随机元素</h1><p>实现 RandomizedSet 类：</p>\n<p>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomizedSet</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">nums</span>: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">    <span class=\"attr\">map</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">number</span>,<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span> = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">insert</span>(<span class=\"attr\">val</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">has</span>(val)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> lastIndex = <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"title function_\">push</span>(val);</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">set</span>(val, lastIndex);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">remove</span>(<span class=\"attr\">val</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">get</span>(val);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[index] = <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">set</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[index], index);</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">delete</span>(val);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">getRandom</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() * <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"property\">length</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new RandomizedSet()</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.insert(val)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.remove(val)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_3 = obj.getRandom()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"380-O-1-时间插入、删除和获取随机元素\"><a href=\"#380-O-1-时间插入、删除和获取随机元素\" class=\"headerlink\" title=\"380. O(1) 时间插入、删除和获取随机元素\"></a>380. O(1) 时间插入、删除和获取随机元素</h1><p>实现 RandomizedSet 类：</p>\n<p>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomizedSet</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">nums</span>: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">    <span class=\"attr\">map</span>: <span class=\"title class_\">Map</span>&lt;<span class=\"built_in\">number</span>,<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span> = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">insert</span>(<span class=\"attr\">val</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">has</span>(val)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> lastIndex = <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"title function_\">push</span>(val);</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">set</span>(val, lastIndex);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">remove</span>(<span class=\"attr\">val</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">get</span>(val);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[index] = <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">set</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[index], index);</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">map</span>.<span class=\"title function_\">delete</span>(val);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">getRandom</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() * <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>.<span class=\"property\">length</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">nums</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * var obj = new RandomizedSet()</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_1 = obj.insert(val)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_2 = obj.remove(val)</span></span><br><span class=\"line\"><span class=\"comment\"> * var param_3 = obj.getRandom()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# 45. 跳跃游戏 II\n\n给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\n\n每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\n\n0 <= j <= nums[i]\ni + j < n\n返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n\n## 解题思路\n\n首先给出的测试用例都可以达到数组最右边界，说明不用考虑到达不了的情况\n\n那么可以简单的考虑，只要每次更新当前最大能到达的右边界时，步数+1 即可\n\n```ts\nfunction jump(nums: number[]): number {\n  let len = nums.length;\n  let ans = 0;\n  let rightPos = 0;\n  let end = 0;\n  for(let i = 0; i < len - 1;i++) {\n    // 每次更新右边界\n    rightPos = Math.max(rightPos, i + nums[i]);\n    // 当遍历到end到时候，rightPos记录着目前跳跃区间内的最大值\n    if (i === end) {\n      end = rightPos;\n      ans++;\n    }\n  }\n  return ans;\n};\n```\n","source":"leetcode/面试经典150题/45.跳跃游戏II.md","raw":"# 45. 跳跃游戏 II\n\n给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\n\n每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\n\n0 <= j <= nums[i]\ni + j < n\n返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n\n## 解题思路\n\n首先给出的测试用例都可以达到数组最右边界，说明不用考虑到达不了的情况\n\n那么可以简单的考虑，只要每次更新当前最大能到达的右边界时，步数+1 即可\n\n```ts\nfunction jump(nums: number[]): number {\n  let len = nums.length;\n  let ans = 0;\n  let rightPos = 0;\n  let end = 0;\n  for(let i = 0; i < len - 1;i++) {\n    // 每次更新右边界\n    rightPos = Math.max(rightPos, i + nums[i]);\n    // 当遍历到end到时候，rightPos记录着目前跳跃区间内的最大值\n    if (i === end) {\n      end = rightPos;\n      ans++;\n    }\n  }\n  return ans;\n};\n```\n","date":"2023-10-11T15:10:43.211Z","updated":"2023-09-26T14:49:23.609Z","path":"leetcode/面试经典150题/45.跳跃游戏II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003vtnw7e0f80m5i","content":"<h1 id=\"45-跳跃游戏-II\"><a href=\"#45-跳跃游戏-II\" class=\"headerlink\" title=\"45. 跳跃游戏 II\"></a>45. 跳跃游戏 II</h1><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>\n<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>\n<p>0 &lt;= j &lt;= nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>首先给出的测试用例都可以达到数组最右边界，说明不用考虑到达不了的情况</p>\n<p>那么可以简单的考虑，只要每次更新当前最大能到达的右边界时，步数+1 即可</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>;i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次更新右边界</span></span><br><span class=\"line\">    rightPos = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rightPos, i + nums[i]);</span><br><span class=\"line\">    <span class=\"comment\">// 当遍历到end到时候，rightPos记录着目前跳跃区间内的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i === end) &#123;</span><br><span class=\"line\">      end = rightPos;</span><br><span class=\"line\">      ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"45-跳跃游戏-II\"><a href=\"#45-跳跃游戏-II\" class=\"headerlink\" title=\"45. 跳跃游戏 II\"></a>45. 跳跃游戏 II</h1><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>\n<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>\n<p>0 &lt;= j &lt;= nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>首先给出的测试用例都可以达到数组最右边界，说明不用考虑到达不了的情况</p>\n<p>那么可以简单的考虑，只要每次更新当前最大能到达的右边界时，步数+1 即可</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>;i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次更新右边界</span></span><br><span class=\"line\">    rightPos = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rightPos, i + nums[i]);</span><br><span class=\"line\">    <span class=\"comment\">// 当遍历到end到时候，rightPos记录着目前跳跃区间内的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i === end) &#123;</span><br><span class=\"line\">      end = rightPos;</span><br><span class=\"line\">      ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 55. 跳跃游戏\n\n给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\n\n## 解题思路\n\n遍历最大范围，找到这个范围内最大可到达的位置\n\n```ts\nfunction canJump(nums: number[]): boolean {\n  // 右边界\n  let rightPos = 0;\n  const len = nums.length - 1;\n\n  for(let i = 0; i <= len; i++) {\n    // 遍历可达范围内rightpos最大值，更新rightpos\n    if (i <= rightPos) {\n      rightPos = Math.max(rightPos, i + nums[i]);\n      if (rightPos >= len) {\n        return true;\n      }\n    } else {\n      break;\n    }\n  }\n  return false;\n};\n```\n","source":"leetcode/面试经典150题/55.跳跃游戏.md","raw":"# 55. 跳跃游戏\n\n给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\n\n## 解题思路\n\n遍历最大范围，找到这个范围内最大可到达的位置\n\n```ts\nfunction canJump(nums: number[]): boolean {\n  // 右边界\n  let rightPos = 0;\n  const len = nums.length - 1;\n\n  for(let i = 0; i <= len; i++) {\n    // 遍历可达范围内rightpos最大值，更新rightpos\n    if (i <= rightPos) {\n      rightPos = Math.max(rightPos, i + nums[i]);\n      if (rightPos >= len) {\n        return true;\n      }\n    } else {\n      break;\n    }\n  }\n  return false;\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-09-26T14:49:23.610Z","path":"leetcode/面试经典150题/55.跳跃游戏.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003wtnw71gnd8l2h","content":"<h1 id=\"55-跳跃游戏\"><a href=\"#55-跳跃游戏\" class=\"headerlink\" title=\"55. 跳跃游戏\"></a>55. 跳跃游戏</h1><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>遍历最大范围，找到这个范围内最大可到达的位置</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">canJump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 右边界</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历可达范围内rightpos最大值，更新rightpos</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= rightPos) &#123;</span><br><span class=\"line\">      rightPos = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rightPos, i + nums[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightPos &gt;= len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"55-跳跃游戏\"><a href=\"#55-跳跃游戏\" class=\"headerlink\" title=\"55. 跳跃游戏\"></a>55. 跳跃游戏</h1><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>遍历最大范围，找到这个范围内最大可到达的位置</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">canJump</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 右边界</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = nums.<span class=\"property\">length</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历可达范围内rightpos最大值，更新rightpos</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt;= rightPos) &#123;</span><br><span class=\"line\">      rightPos = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(rightPos, i + nums[i]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rightPos &gt;= len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 6. N 字形变换\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：\n\nP A H N\nA P L S I I G\nY I R\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\nstring convert(string s, int numRows);\n\n```ts\nfunction convert(s: string, numRows: number): string {\n  if (numRows < 2) return s;\n  const rows: string[] = Array(numRows).fill('');\n  let flag = -1;\n\n  let j = 0;\n  for(let i = 0; i < s.length; i++) {\n    rows[j] += s[i];\n    if (j === 0 || j === numRows - 1) {\n      flag = -flag;\n    }\n\n    j += flag;\n  }\n\n  return rows.join('');\n};\n```\n","source":"leetcode/面试经典150题/6.N字形变换.md","raw":"# 6. N 字形变换\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：\n\nP A H N\nA P L S I I G\nY I R\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\nstring convert(string s, int numRows);\n\n```ts\nfunction convert(s: string, numRows: number): string {\n  if (numRows < 2) return s;\n  const rows: string[] = Array(numRows).fill('');\n  let flag = -1;\n\n  let j = 0;\n  for(let i = 0; i < s.length; i++) {\n    rows[j] += s[i];\n    if (j === 0 || j === numRows - 1) {\n      flag = -flag;\n    }\n\n    j += flag;\n  }\n\n  return rows.join('');\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-09-26T14:49:23.610Z","path":"leetcode/面试经典150题/6.N字形变换.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003xtnw72gkfdr9m","content":"<h1 id=\"6-N-字形变换\"><a href=\"#6-N-字形变换\" class=\"headerlink\" title=\"6. N 字形变换\"></a>6. N 字形变换</h1><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>\n<p>P A H N<br>A P L S I I G<br>Y I R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<p>string convert(string s, int numRows);</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">convert</span>(<span class=\"params\">s: <span class=\"built_in\">string</span>, numRows: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numRows &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">rows</span>: <span class=\"built_in\">string</span>[] = <span class=\"title class_\">Array</span>(numRows).<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    rows[j] += s[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j === <span class=\"number\">0</span> || j === numRows - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      flag = -flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    j += flag;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> rows.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"6-N-字形变换\"><a href=\"#6-N-字形变换\" class=\"headerlink\" title=\"6. N 字形变换\"></a>6. N 字形变换</h1><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>\n<p>P A H N<br>A P L S I I G<br>Y I R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n<p>string convert(string s, int numRows);</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">convert</span>(<span class=\"params\">s: <span class=\"built_in\">string</span>, numRows: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numRows &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">rows</span>: <span class=\"built_in\">string</span>[] = <span class=\"title class_\">Array</span>(numRows).<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    rows[j] += s[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j === <span class=\"number\">0</span> || j === numRows - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      flag = -flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    j += flag;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> rows.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 392. 判断子序列\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n进阶：\n\n如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n```ts\nfunction isSubsequence(s: string, t: string): boolean {\n  if (s === '') return true;\n  let sPos = 0;\n  for(let i = 0;i < t.length; i++) {\n    if (s[sPos] === t[i]) {\n      if (sPos === s.length - 1) {\n        return true;\n      }\n      sPos++;\n    }\n  }\n  return false;\n};\n```\n","source":"leetcode/面试经典150题/392.判断子序列.md","raw":"# 392. 判断子序列\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n进阶：\n\n如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n```ts\nfunction isSubsequence(s: string, t: string): boolean {\n  if (s === '') return true;\n  let sPos = 0;\n  for(let i = 0;i < t.length; i++) {\n    if (s[sPos] === t[i]) {\n      if (sPos === s.length - 1) {\n        return true;\n      }\n      sPos++;\n    }\n  }\n  return false;\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-10-09T15:31:50.204Z","path":"leetcode/面试经典150题/392.判断子序列.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003ytnw79rew0412","content":"<h1 id=\"392-判断子序列\"><a href=\"#392-判断子序列\" class=\"headerlink\" title=\"392. 判断子序列\"></a>392. 判断子序列</h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>\n<p>进阶：</p>\n<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSubsequence</span>(<span class=\"params\">s: <span class=\"built_in\">string</span>, t: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; t.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[sPos] === t[i]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sPos === s.<span class=\"property\">length</span> - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      sPos++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"392-判断子序列\"><a href=\"#392-判断子序列\" class=\"headerlink\" title=\"392. 判断子序列\"></a>392. 判断子序列</h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>\n<p>进阶：</p>\n<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isSubsequence</span>(<span class=\"params\">s: <span class=\"built_in\">string</span>, t: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s === <span class=\"string\">&#x27;&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; t.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[sPos] === t[i]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sPos === s.<span class=\"property\">length</span> - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      sPos++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 80. 删除有序数组中的重复项 II\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n```ts\nfunction removeDuplicates(nums: number[]): number {\n    const n = nums.length;\n    const SAME_COUNT = 2\n    if (n <= SAME_COUNT) {\n        return n;\n    }\n    let slow = SAME_COUNT, fast = SAME_COUNT;\n    while(fast < n) {\n        if (nums[slow - SAME_COUNT] !== nums[fast]) {\n            nums[slow] = nums[fast];\n            ++slow;\n        }\n        ++fast;\n    }\n    return slow;\n};\n```\n","source":"leetcode/面试经典150题/80.删除有序数组中的重复项II.md","raw":"# 80. 删除有序数组中的重复项 II\n\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n```ts\nfunction removeDuplicates(nums: number[]): number {\n    const n = nums.length;\n    const SAME_COUNT = 2\n    if (n <= SAME_COUNT) {\n        return n;\n    }\n    let slow = SAME_COUNT, fast = SAME_COUNT;\n    while(fast < n) {\n        if (nums[slow - SAME_COUNT] !== nums[fast]) {\n            nums[slow] = nums[fast];\n            ++slow;\n        }\n        ++fast;\n    }\n    return slow;\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-09-26T14:49:23.611Z","path":"leetcode/面试经典150题/80.删除有序数组中的重复项II.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv003ztnw7b0dxhuty","content":"<h1 id=\"80-删除有序数组中的重复项-II\"><a href=\"#80-删除有序数组中的重复项-II\" class=\"headerlink\" title=\"80. 删除有序数组中的重复项 II\"></a>80. 删除有序数组中的重复项 II</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeDuplicates</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"variable constant_\">SAME_COUNT</span> = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"variable constant_\">SAME_COUNT</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> slow = <span class=\"variable constant_\">SAME_COUNT</span>, fast = <span class=\"variable constant_\">SAME_COUNT</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &lt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[slow - <span class=\"variable constant_\">SAME_COUNT</span>] !== nums[fast]) &#123;</span><br><span class=\"line\">            nums[slow] = nums[fast];</span><br><span class=\"line\">            ++slow;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"80-删除有序数组中的重复项-II\"><a href=\"#80-删除有序数组中的重复项-II\" class=\"headerlink\" title=\"80. 删除有序数组中的重复项 II\"></a>80. 删除有序数组中的重复项 II</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeDuplicates</span>(<span class=\"params\">nums: <span class=\"built_in\">number</span>[]</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = nums.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"variable constant_\">SAME_COUNT</span> = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"variable constant_\">SAME_COUNT</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> slow = <span class=\"variable constant_\">SAME_COUNT</span>, fast = <span class=\"variable constant_\">SAME_COUNT</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast &lt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[slow - <span class=\"variable constant_\">SAME_COUNT</span>] !== nums[fast]) &#123;</span><br><span class=\"line\">            nums[slow] = nums[fast];</span><br><span class=\"line\">            ++slow;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 58. 最后一个单词的长度\n\n给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n```ts\nfunction lengthOfLastWord(s: string): number {\n  let res = 0;\n  const len = s.length;\n  for(let i = len - 1; i >= 0; i--) {\n    if (s[i] === ' ' && res === 0) {\n      continue;\n    }\n    if (s[i] === ' ' && res > 0) {\n      break;\n    }\n    res++;\n  }\n  return res;\n};\n```\n","source":"leetcode/面试经典150题/58.最后一个单词的长度.md","raw":"# 58. 最后一个单词的长度\n\n给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n```ts\nfunction lengthOfLastWord(s: string): number {\n  let res = 0;\n  const len = s.length;\n  for(let i = len - 1; i >= 0; i--) {\n    if (s[i] === ' ' && res === 0) {\n      continue;\n    }\n    if (s[i] === ' ' && res > 0) {\n      break;\n    }\n    res++;\n  }\n  return res;\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-09-26T14:49:23.610Z","path":"leetcode/面试经典150题/58.最后一个单词的长度.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv0040tnw7bikqby5g","content":"<h1 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58. 最后一个单词的长度\"></a>58. 最后一个单词的长度</h1><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p>\n<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lengthOfLastWord</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = len - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; res === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; res &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58. 最后一个单词的长度\"></a>58. 最后一个单词的长度</h1><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p>\n<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lengthOfLastWord</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = s.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = len - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; res === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; res &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# 88. 合并两个有序数组\n\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n## 逆指针\n\n```ts\n/**\n Do not return anything, modify nums1 in-place instead.\n */\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\n    let p1 = m - 1, p2 = n - 1;\n    let tail = m + n - 1;\n\n    let cur: number;\n\n    while(p1 >= 0 || p2 >= 0) {\n        if (p1 === -1) {\n            cur = nums2[p2--];\n        } else if (p2 === -1) {\n            cur = nums1[p1--];\n        } else if (nums1[p1] > nums2[p2]) {\n            cur = nums1[p1--];\n        } else {\n            cur = nums2[p2--];\n        }\n        nums1[tail--] = cur;\n    }\n};\n```\n","source":"leetcode/面试经典150题/88.合并两个有序数组.md","raw":"# 88. 合并两个有序数组\n\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n## 逆指针\n\n```ts\n/**\n Do not return anything, modify nums1 in-place instead.\n */\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\n    let p1 = m - 1, p2 = n - 1;\n    let tail = m + n - 1;\n\n    let cur: number;\n\n    while(p1 >= 0 || p2 >= 0) {\n        if (p1 === -1) {\n            cur = nums2[p2--];\n        } else if (p2 === -1) {\n            cur = nums1[p1--];\n        } else if (nums1[p1] > nums2[p2]) {\n            cur = nums1[p1--];\n        } else {\n            cur = nums2[p2--];\n        }\n        nums1[tail--] = cur;\n    }\n};\n```\n","date":"2023-10-11T15:10:43.212Z","updated":"2023-09-26T14:49:23.611Z","path":"leetcode/面试经典150题/88.合并两个有序数组.html","title":"","comments":1,"layout":"page","_id":"clnlw1sxv0041tnw79kycai6m","content":"<h1 id=\"88-合并两个有序数组\"><a href=\"#88-合并两个有序数组\" class=\"headerlink\" title=\"88. 合并两个有序数组\"></a>88. 合并两个有序数组</h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>\n<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>\n<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>\n<h2 id=\"逆指针\"><a href=\"#逆指针\" class=\"headerlink\" title=\"逆指针\"></a>逆指针</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Do not return anything, modify nums1 in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">merge</span>(<span class=\"params\">nums1: <span class=\"built_in\">number</span>[], m: <span class=\"built_in\">number</span>, nums2: <span class=\"built_in\">number</span>[], n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p1 = m - <span class=\"number\">1</span>, p2 = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tail = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">cur</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1 &gt;= <span class=\"number\">0</span> || p2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p1 === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            cur = nums2[p2--];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p2 === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            cur = nums1[p1--];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class=\"line\">            cur = nums1[p1--];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cur = nums2[p2--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums1[tail--] = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"88-合并两个有序数组\"><a href=\"#88-合并两个有序数组\" class=\"headerlink\" title=\"88. 合并两个有序数组\"></a>88. 合并两个有序数组</h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>\n<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>\n<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>\n<h2 id=\"逆指针\"><a href=\"#逆指针\" class=\"headerlink\" title=\"逆指针\"></a>逆指针</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> Do not return anything, modify nums1 in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">merge</span>(<span class=\"params\">nums1: <span class=\"built_in\">number</span>[], m: <span class=\"built_in\">number</span>, nums2: <span class=\"built_in\">number</span>[], n: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p1 = m - <span class=\"number\">1</span>, p2 = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tail = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">cur</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1 &gt;= <span class=\"number\">0</span> || p2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p1 === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            cur = nums2[p2--];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p2 === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            cur = nums1[p1--];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class=\"line\">            cur = nums1[p1--];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cur = nums2[p2--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums1[tail--] = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"_content":"const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst p = path.join(__dirname, \"./\");\n\nconst targetDir = [\"二叉树\", \"动态规划\", \"算法实现\", \"链表\", \"面试经典150题\"];\n\nconst baseURL = \"/leetcode\";\nconst run = () => {\n  targetDir.forEach(async (dir) => {\n    const dirPath = path.join(p, dir);\n    const files = fs.readdirSync(dirPath);\n\n    let content = `---\\r\\ntitle: ${dir}\\r\\n---\\r\\n`;\n    const targetPath = path.join(dirPath, \"index.md\");\n    files.forEach(async (file) => {\n      if (file !== \"index.md\") {\n        if (file.includes(\" \")) {\n          const oldPath = path.join(dirPath, file);\n          file = file.replace(/\\s/g, \"\");\n          const newPath = path.join(dirPath, file);\n          fs.rename(oldPath, newPath, (err) =>\n            err ? console.log(err) : console.log(\"success\")\n          );\n        }\n        const last = file.lastIndexOf(\".\");\n        file = file.slice(0, last);\n        content += `[${file}](${baseURL}/${dir}/${file})\\r\\n`;\n        console.log(`${baseURL}/${dir}/${file}`);\n      }\n    });\n    fs.writeFile(targetPath, content, (err) =>\n      err ? console.log(err) : console.log(\"success\")\n    );\n  });\n};\n\nrun();\n","source":"leetcode/format.js","raw":"const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst p = path.join(__dirname, \"./\");\n\nconst targetDir = [\"二叉树\", \"动态规划\", \"算法实现\", \"链表\", \"面试经典150题\"];\n\nconst baseURL = \"/leetcode\";\nconst run = () => {\n  targetDir.forEach(async (dir) => {\n    const dirPath = path.join(p, dir);\n    const files = fs.readdirSync(dirPath);\n\n    let content = `---\\r\\ntitle: ${dir}\\r\\n---\\r\\n`;\n    const targetPath = path.join(dirPath, \"index.md\");\n    files.forEach(async (file) => {\n      if (file !== \"index.md\") {\n        if (file.includes(\" \")) {\n          const oldPath = path.join(dirPath, file);\n          file = file.replace(/\\s/g, \"\");\n          const newPath = path.join(dirPath, file);\n          fs.rename(oldPath, newPath, (err) =>\n            err ? console.log(err) : console.log(\"success\")\n          );\n        }\n        const last = file.lastIndexOf(\".\");\n        file = file.slice(0, last);\n        content += `[${file}](${baseURL}/${dir}/${file})\\r\\n`;\n        console.log(`${baseURL}/${dir}/${file}`);\n      }\n    });\n    fs.writeFile(targetPath, content, (err) =>\n      err ? console.log(err) : console.log(\"success\")\n    );\n  });\n};\n\nrun();\n","date":"2023-10-11T15:15:18.474Z","updated":"2023-10-11T15:15:18.474Z","path":"leetcode/format.js","layout":"false","_id":"clnlw2tmy0042tnw7dmzievb0","title":"","comments":1,"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst p = path.join(__dirname, \"./\");\n\nconst targetDir = [\"二叉树\", \"动态规划\", \"算法实现\", \"链表\", \"面试经典150题\"];\n\nconst baseURL = \"/leetcode\";\nconst run = () => {\n  targetDir.forEach(async (dir) => {\n    const dirPath = path.join(p, dir);\n    const files = fs.readdirSync(dirPath);\n\n    let content = `---\\r\\ntitle: ${dir}\\r\\n---\\r\\n`;\n    const targetPath = path.join(dirPath, \"index.md\");\n    files.forEach(async (file) => {\n      if (file !== \"index.md\") {\n        if (file.includes(\" \")) {\n          const oldPath = path.join(dirPath, file);\n          file = file.replace(/\\s/g, \"\");\n          const newPath = path.join(dirPath, file);\n          fs.rename(oldPath, newPath, (err) =>\n            err ? console.log(err) : console.log(\"success\")\n          );\n        }\n        const last = file.lastIndexOf(\".\");\n        file = file.slice(0, last);\n        content += `[${file}](${baseURL}/${dir}/${file})\\r\\n`;\n        console.log(`${baseURL}/${dir}/${file}`);\n      }\n    });\n    fs.writeFile(targetPath, content, (err) =>\n      err ? console.log(err) : console.log(\"success\")\n    );\n  });\n};\n\nrun();\n","site":{"data":{}},"cover":false,"excerpt":"","more":"const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst p = path.join(__dirname, \"./\");\n\nconst targetDir = [\"二叉树\", \"动态规划\", \"算法实现\", \"链表\", \"面试经典150题\"];\n\nconst baseURL = \"/leetcode\";\nconst run = () => {\n  targetDir.forEach(async (dir) => {\n    const dirPath = path.join(p, dir);\n    const files = fs.readdirSync(dirPath);\n\n    let content = `---\\r\\ntitle: ${dir}\\r\\n---\\r\\n`;\n    const targetPath = path.join(dirPath, \"index.md\");\n    files.forEach(async (file) => {\n      if (file !== \"index.md\") {\n        if (file.includes(\" \")) {\n          const oldPath = path.join(dirPath, file);\n          file = file.replace(/\\s/g, \"\");\n          const newPath = path.join(dirPath, file);\n          fs.rename(oldPath, newPath, (err) =>\n            err ? console.log(err) : console.log(\"success\")\n          );\n        }\n        const last = file.lastIndexOf(\".\");\n        file = file.slice(0, last);\n        content += `[${file}](${baseURL}/${dir}/${file})\\r\\n`;\n        console.log(`${baseURL}/${dir}/${file}`);\n      }\n    });\n    fs.writeFile(targetPath, content, (err) =>\n      err ? console.log(err) : console.log(\"success\")\n    );\n  });\n};\n\nrun();\n"}],"Post":[{"title":"socketio实现服务器推送（demo实现一个聊天室）","date":"2020-06-29T03:20:26.000Z","_content":"\ndemo 演示地址：<http://chat.lstmxx.cn>\n\ngithub 地址：<https://github.com/Lstmxx/chatroom>\n\n## 前言\n\n服务端推送是一种服务器主动给客户端发送的技术，主要用于实时对客户端进行消息推送，如天气预报、聊天功能等。\n\n### HTTP 1.x\n\n在 websocket api 出现之前，由于 http1.x 的缺陷，导致通信只能由客户端发起，用户想要获取到实时数据变化，就要不停的向服务器发送请求，这种方法我们一般称为轮询。这种方法在 web 端可以一用，但是在移动端就不行了，想一想你的 app 不停的消耗你的流量发请求到服务器，这会导致用户流量的大量浪费，体现极其差。\n\n```js\nsetInterval(() => {\n  axios()then((res) => {\n    ···\n  }).catch(err => {\n    ···\n  })\n}, 3000)\n```\n\n### HTTP 2.0\n\n为了解决这一问题，终于在 http2.0 协议里面增加了一个新特性——服务器推送。而 Html5 根据这一特性提供了一种在单个 TCP 连接上进行全双工通讯的协议——[WebSocket](https://www.runoob.com/html/html5-websocket.html)。\n\n### Socketio\n\n#### 描述\n\n如果客户端想要使用 websocket 接受服务器推送的话，Socketio 是一个不错的选择。Socket.io 将 Websocket、轮询机制以及其它的实时通信方式（ajax 等）封装成了通用的接口，并且在服务端也实现了这些实时机制的相应代码。所以，使用 Socket.io 便不需要担心浏览器兼容问题。\n\n#### namespace 和 room\n\nsocketio 有两个重要的概念——namespace 和 room。两者关系是 namespace 包含 room。举个例子，你要通知北小区的 4 座的所有用户交管理费，你先找到了北小区（namespace）然后再找到 4 座（room），最后给 4 座里面的业主发送交管理费消息。\n\n## Socketio 的安装与使用\n\n### Vue 中使用 Socketio\n\n在 Vue 中有两种方式使用 Socketio\n\n#### 直接使用官方包\n\n下载\n\n```bash\nnpm install socket.io\n```\n\n引入\n\n```js\nimport io from 'socket.io-client'\n```\n\n使用\n\n```js\n// 这里的namespace和后端设置的namespace是一样的\nconst socket = io.connect(`http://${域名}/${namespace}`)\n\n// on函数是监听函数，接受两个参数，第一个是订阅名，第二个是接受订阅信息的回调\nsocket.on('chatMessage', res => {\n  console.log(res)\n})\nsocket.on('response', res => {\n  console.log(res)\n})\nsocket.on('connect', res => {\n  console.log(res)\n})\n···\n// emit是发送函数，第一个参数是后端的订阅名，第二个是数据，可以是任意类型\nsocket.emit('user_input', 'wdnmd')\n```\n\n#### 使用 VueSocketio\n\n相较于 socket.io-client，VueSocketio 自带支持在 vuex 中使用，这使得多组件共用消息更加便利。npm 地址：<https://www.npmjs.com/package/vue-socket.io> 。\n\n下载\n\n```bash\nnpm install vue-socket.io\n```\n\n引入\n\n```js\n// /fronted/src/main.js\nimport store from './store'\nimport VueSocketio from 'vue-socket.io'\n···\nVue.use(new VueSocketio({\n  debug: true,\n  connection: `/${namespace}`,\n  /* 推荐使用vuex引入，方便多组件状态共享 */\n  vuex: {\n    store,\n    actionPrefix: 'SOCKET_' // 前缀，为了区分vuex文件中响应函数和普通函数\n  }\n}))\n```\n\n单组件使用\n\n```js\n// 在需要监听的vue引入\n···\nexport default {\n  sockets: {\n    connect: function () {\n      console.log('socket connected')\n    },\n    received: function (res) {\n      console.log(res)\n    }\n  }\n}\n···\n```\n\nvuex 中使用\n\n```js\n// /store/module/room.js\n···\n// responseData 为响应数据\nSOCKET_received ({ state, rootState, commit }, responseData) {\n  // do something\n},\nSOCKET_join_one ({}, responseData) {\n  // do something\n}\n```\n\n### flask 中使用 Socketio\n\nflask 中使用 socketio 主要用到 Flask-SocketIO 这个包，官网地址：<https://flask-socketio.readthedocs.io/en/latest/> 。\n\n下载\n\n```python\npip install flask-socketio\n```\n\n使用\n\n```python\n···\n# /backend/blueprint/socketio.py\nfrom flask_cors import CORS # 跨域\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, close_room, rooms, disconnect\n\n# 初始化socketio\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n# 第一个参数为事件名，第二个为namespace\n# 通过监听namespace下的事件做出响应，这里的namespace和前面前端定义的namespace要相同\n# message为请求参数\n@socketio.on('test_input', namespace='/chatroom')\ndef test_input(message):\n    # do someting\n    socketio.emit('test_received', '收到啦', namespace='/chatroom')\n```\n\n在 app.py 中引入\n\n```python\n# /backend/app.py\nfrom blueprint.socketio import app, socketio, db\n···\nif __name__ == \"__main__\":\n    ···\n    socketio.run(app, host=\"0.0.0.0\", port=4999, debug=True)\n```\n\n### nginx 配置\n\n既然是前后端分离，那当然要使用 nginx 啦~\n\n配置 chatroom.conf\n\n```nginx\nupstream chat_frontend {\n    server 127.0.0.1:8181; # 前端工程运行的地址\n}\n\nupstream chat_backend {\n    server 127.0.0.1:4999; # 后端工程运行的地址\n}\n\nserver {\n    listen       80; # 监听端口\n    server_name  www.chatroom.com; #域名\n        location ^~ /api { # 普通接口路由\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-Server $host;\n            proxy_pass http://chat_backend;\n        }\n        location /socket.io { # socketio的路由\n            proxy_http_version 1.1;\n            proxy_buffering off;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"Upgrade\";\n            proxy_pass http://chat_backend;\n        }\n        location / { # 前端路由\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-Server $host;\n            proxy_pass http://chat_frontend;\n        }\n}\n```\n\n配置 host\n\n```conf\n···\n127.0.0.1 www.chatroom.com\n```\n\n### 通信\n\n前面把 flask 和 vue 都配置好了，那么先测试一下。\n\n整个流程非常简单，流程图如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe93449800d38~tplv-t2oaga2asx-image.image)\n\n#### vue\n\n获取用户输入后，向目标事件发送数据。这里我自己实现了一个简陋的 rich-text，如果不追求效果直接用 input 标签就完事了。\n\n```js\n// /src/components/chat-room/message-box/message-box.vue\n···\nsendMessage (message) {\n  // 第一个参数为事件名，第二个参数为要发送的数据\n  this.$socket.emit('test_input', message)\n}\n```\n\n在 vuex 中监听 received 事件获取服务器返回消息。\n\n```js\n// /src/store/module/room.js\nexport default {\n  ···\n  actions: {\n    ···\n    SOCKET_test_received ({ state, rootState, commit }, responseData) {\n      console.log(responseData)\n    }\n  }\n}\n\n```\n\n#### flask\n\n后端这边就非常简单了，增加一个消息回调函数就好了。\n\n```python\nfrom flask_socketio import SocketIO, emit\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n···\n@socketio.on('test_input', namespace='/chatroom')\ndef test_input(message):\n    # do someting\n    socketio.emit('test_received', '收到啦', namespace='/chatroom')\n    # 或者\n    # emit('test_received', '收到啦', namespace='/chatroom')\n```\n\n要注意的是，这个 emit 没有指定某一个 room，所以会广播给在这个 namespace 下的所有人。\n\n打开谷歌浏览器，效果如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe94c8b5e4c45~tplv-t2oaga2asx-image.image)\n\n## 实现聊天室小 demo\n\n### 构思\n\n一个简单的聊天室肯定会涉及到用户，房间和消息记录。\n\n### 实现登录页面\n\n首先解决一下用户，最核心的是登录。先建一个用户表。\n\n```sql\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `create_time` datetime(0) DEFAULT NULL,\n  `avatar_image` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `room_id_set` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT '每个用户所参加的房间',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `ix_user_username`(`username`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n```\n\n封装一下登录接口，使用 vuex 保存登录状态。因为关闭页面后 vuex 会清掉 token 使用 cookie 来保存（axios 的封装就不说了，不是重点）\n\n```js\n// /fronted/src/libs/requestApi.js\n···\nexport function baseLogin (config) {\n  const request = {\n    url: config.url,\n    method: 'POST',\n    data: config.data\n  }\n  return service.request(request)\n}\n```\n\n```js\n// /fronted/src/libs/request.js\nexport function login (config) {\n  return new Promise((resolve, reject) => {\n    baseLogin(config).then((response) => {\n      resolve(response.data.data)\n    }).catch((err) => {\n      reject(err)\n    })\n  })\n}\n```\n\n保存 token\n\n```js\n// /fronted/src/libs/utility/token.js\nimport Cookies from 'js-cookie'\nconst TOKEN_KEY = 'token'\nexport const setToken = (token) => {\n  Cookies.set(TOKEN_KEY, token, { expires: 1 })\n}\n\nexport const getToken = () => {\n  const token = Cookies.get(TOKEN_KEY)\n  if (token !== 'null') return token\n  else return false\n}\n```\n\n编写 vuex 的 user 模块\n\n```js\n// /fronted/src/store/module/user.js\nimport { getToken, setToken } from '../../libs/utility/token'\nimport { login, getUserInfo, logout } from '@/libs/request'\nexport default {\n  state: {\n    token: getToken(),\n    userName: null,\n    userId: null,\n    avatarImage: null\n  },\n  getters: {\n    getToken (state) {\n      return state.token\n    },\n    getUserName (state) {\n      return state.userName\n    },\n    getUserId (state) {\n      return state.userId\n    },\n    getAvatarImage (state) {\n      return state.avatarImage\n    }\n  },\n  mutations: {\n    setToken (state, token) {\n      state.token = token\n      setToken(token)\n    },\n    setUserName (state, name) {\n      state.userName = name\n    },\n    setUserId (state, userId) {\n      state.userId = userId\n    },\n    setAvatarImage (state, avatarImage) {\n      state.avatarImage = avatarImage\n    }\n  },\n  actions: {\n    handleLogin ({ commit }, config) {\n      return new Promise((resolve, reject) => {\n        login(config).then((responseData) => {\n          commit('setToken', responseData.token)\n          resolve(responseData)\n        }).catch((err) => {\n          reject(err)\n          console.log(err)\n        })\n      })\n    },\n    loadUserInfo ({ commit }) {\n      return new Promise((resolve, reject) => {\n        getUserInfo().then((responseData) => {\n          commit('setToken', getToken())\n          commit('setUserName', responseData.userInfo.name)\n          commit('setUserId', responseData.userInfo.userId)\n          commit('setAvatarImage', responseData.userInfo.avatar_image)\n          resolve(responseData)\n        }).catch((err) => {\n          commit('setToken', null)\n          reject(err)\n          console.log(err)\n        })\n      })\n    }\n  }\n}\n```\n\n在 login 页面中使用\n\n```js\n// /fronted/src/views/login/login.vue\nimport { mapActions } from 'vuex'\nexport default {\n  ···\n  methods: {\n    ...mapActions([\n      'handleLogin',\n      'loadUserInfo'\n    ]),\n    checkCapslock (e) {\n      const { key } = e\n      this.capsTooltip = key && key.length === 1 && (key >= 'A' && key <= 'Z')\n    },\n    // 登录，成功后跳转\n    onLogin () {\n      this.$refs.loginForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/login',\n            data: this.loginForm\n          }\n          this.handleLogin(config).then(() => {\n            this.$Loading.hide()\n            this.$router.push({\n              name: 'ChatRoom'\n            })\n          }).catch((err) => {\n            this.$Loading.hide()\n            console.log(err)\n          })\n        }\n      })\n    },\n    // 注册，成功后回调登录\n    onRegister () {\n      this.$refs.loginForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/register',\n            data: this.loginForm\n          }\n          this.handleLogin(config).then(() => {\n            this.$Loading.hide()\n            this.onLogin()\n          }).catch((err) => {\n            this.$Loading.hide()\n            console.log(err)\n          })\n        }\n      })\n    }\n  }\n}\n```\n\n后端方面，可以看看/backend/blueprint/user.py。ui 方面就不说了，不是重点。\n\n### 实现房间的创建，展示和加入功能\n\n对于房间来说，肯定要有创建和加入这两个功能的，下面先说说创建。\n\n先建个表吧\n\n```sql\nDROP TABLE IF EXISTS `room`;\nCREATE TABLE `room`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `owner` int(11) DEFAULT NULL COMMENT '房间创建人',\n  `user_set` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,\n  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,\n  `create_time` datetime(0) DEFAULT NULL,\n  `update_time` datetime(0) DEFAULT NULL,\n  `avatar_image` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `room_hash_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `ix_room_avatar_image`(`avatar_image`) USING BTREE,\n  INDEX `ix_room_create_time`(`create_time`) USING BTREE,\n  INDEX `ix_room_name`(`name`) USING BTREE,\n  INDEX `ix_room_owner`(`owner`) USING BTREE,\n  INDEX `ix_room_update_time`(`update_time`) USING BTREE,\n  CONSTRAINT `room_ibfk_1` FOREIGN KEY (`owner`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n```\n\n#### 创建房间\n\n首先先明确创建房间需要什么数据，我的想法是需要房间头像，房间名和房间描述。\n\n前端主要是获取了房间头像、房间名和房间描述后发送请求到后端。这里的 upLoadFile 是自己模仿 element 来写的组件，有兴趣可以在 /fronted/src/components/base/up-load-file/up-load-file.vue 查看\n\n```vue\n// /fronted/src/components/chat-room/room-list/room-list.vue\n<template>\n···\n    <el-dialog title=\"创建房间\" :visible.sync=\"createRoomDialog\">\n      <el-form :model=\"createRoom\" :rules=\"createRules\" ref=\"createRoomForm\">\n        <el-form-item label=\"房间名\" prop=\"hashId\">\n          <el-input v-model=\"createRoom.name\" autocomplete=\"off\" :maxlength='32' :minlength='32'></el-input>\n        </el-form-item>\n        <el-form-item label=\"房间描述\" prop=\"description\">\n          <el-input v-model=\"createRoom.description\" autocomplete=\"off\" :maxlength='32' :minlength='32'></el-input>\n        </el-form-item>\n        <el-form-item label=\"房间头像\" prop=\"avatarImage\">\n          <upLoadFile :maxImageNum=\"1\" @on-change=\"getFilePath\"/>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"createRoomDialog = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleCreateRoom\">确 定</el-button>\n      </div>\n    </el-dialog>\n···\n</template>\n<script>\nimport { post } from '@/libs/request'\nimport upLoadFile from '@/components/base/up-load-file'\nexport default {\n  name: 'RoomList',\n  props: {\n    roomList: {\n      default: () => [],\n      type: Array\n    }\n  },\n  components: {\n    ···\n    upLoadFile\n  },\n  data () {\n    return {\n      ···\n      createRoom: {\n        name: '',\n        description: '',\n        avatarImage: ''\n      }\n    }\n  },\n  method: {\n    getFilePath (imageList) {\n      this.createRoom.avatarImage = imageList[0].base64Path\n    },\n    handleCreateRoom () {\n      this.$refs.createRoomForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/room/create',\n            data: this.createRoom\n          }\n          post(config).then((responseData) => {\n            this.$Loading.hide()\n            this.createRoom.name = ''\n            this.createRoomDialog = false\n            this.createRoom = {\n              name: '',\n              description: '',\n              avatarImage: ''\n            }\n            this.$message({\n              message: '创建成功',\n              type: 'success'\n            })\n            this.$emit('create-room-success', responseData.room)\n          }).catch((err) => {\n            this.$Loading.hide()\n            this.createRoomDialog = false\n            console.log(err)\n          })\n        }\n      })\n    }\n  }\n}\n</script>\n```\n\n后端这边就简单了，直接插入数据库。插入时候使用 base64 来生成房间码，之后加入房间要用。\n\n```python\n# /backend/blueprint/room.py\n···\n@room_bp.route('/api/room/create', methods=['POST'])\n@verify_token\ndef room_create(tokenData):\n    values = request.get_json()\n    user = User.query.filter_by(id=tokenData['userId']).first()\n    if user:\n        room = Room(name=values['name'],\n                    description=values['description'],\n                    user_set=str(tokenData['userId']),\n                    owner=user.id,\n                    avatar_image='')\n        db.session.add(room)\n        db.session.flush()\n        room.room_hash_id = hashlib.md5(f'{room.id}{time.time()}'.encode('utf-8')).hexdigest()\n        room.user_set = f'{room.user_set},{user.id}' if room.user_set else user.id\n        if values['avatarImage']:\n            avatartImageList = values['avatarImage'].split(',')\n            suffix = avatartImageList[0].split('/')[1].split(';')[0]\n            filename = f'room_avatar/{room.room_hash_id}.{suffix}'\n            print(filename)\n            with open(f'media/{filename}', 'wb') as f:\n                f.write(base64.b64decode(avatartImageList[1]))\n            room.avatar_image = filename\n        user.room_id_set = f'{user.room_id_set},{room.id}' if user.room_id_set else room.id\n        db.session.commit()\n        return jsonify({\n            'data': {\n                'room': JSONHelper.model_to_json(room)\n            },\n            'message': '成功',\n            'status': 200\n        })\n    return jsonify({\n        'data': '',\n        'message': '失败失败',\n        'status': 500\n    })\n```\n\n#### 展示房间\n\n这个其实就是拉一个房间列表。要注意的是前端获取到房间列表后，要调用 join_all 这个事件监听这些房间的消息。\n\n后端\n\n```python\n@room_bp.route('/api/room/list', methods=['GET'])\n@verify_token\ndef room_list(tokenData):\n    user = User.query.filter_by(id=tokenData['userId']).first()\n    if user:\n        roomlist = Room.query.filter(Room.id.in_(user.room_id_set.split(','))).all() if user.room_id_set else []\n        return jsonify({\n            'data': {\n                'roomList': JSONHelper.to_json_list(roomlist)\n            },\n            'message': '成功',\n            'status': 200\n        })\n    return jsonify({\n        'data': '',\n        'message': '失败失败',\n        'status': 500\n    })\n```\n\n前端这边先在 room 模块里编写加载房间列表函数。\n\n```js\n// /fronted/src/store/module/room.js\n···\nloadRoomList ({ commit }) {\n  return new Promise((resolve, reject) => {\n    const config = {\n      url: '/room/list'\n    }\n    get(config).then((responseData) => {\n      commit('setRoomList', responseData.roomList)\n      resolve(responseData.roomList)\n    }).catch((err) => {\n      reject(err)\n    })\n  })\n}\n```\n\n在 chat-room 页面调用。\n\n```js\n// /fronted/src/views/chat-room/chat-room.vue\nmounted () {\n  this.loadRoomList().then((roomList) => {\n    const request = {\n      roomList: roomList.map(room => room.id),\n      userId: this.userId\n    }\n    this.$socket.emit('join_all', request)\n  }).catch((err) => {\n    console.log(err)\n  })\n}\n```\n\n后端响应 join_all 事件，调用 join_room 加入用户所在的所有房间。\n\n```python\n# /backend/blueprint/socketio.py\n@socketio.on('join_all', namespace='/chatroom')\ndef join_chats(message):\n    \"\"\"加入多个聊天室\n    \"\"\"\n    user = User.query.filter_by(id=message['userId']).first()\n    if user and len(message['roomList']) > 0:\n        for roomId in message['roomList']:\n            join_room(roomId)\n            emit('received', { # 发送加入消息\n                'user': {\n                    'id': user.id,\n                    'name': user.username,\n                    'avatarImage': user.avatar_image,\n                },\n                'roomId': roomId,\n                'type': 'join'\n            }, namespace='/chatroom', room=roomId)\n```\n\n#### 加入房间\n\n获取对应的房间码后，输入加入就 OK 了。\n\n```vue\n// /fronted/src/components/chat-room/room-list/room-list.vue\n<template>\n···\n    <el-dialog title=\"加入房间\" :visible.sync=\"joinRoomDialog\">\n      <el-form :model=\"joinRoom\" :rules=\"joinRules\" ref=\"joinRoomForm\">\n        <el-form-item label=\"房间号\" prop=\"hashId\">\n          <el-input v-model=\"joinRoom.hashId\" autocomplete=\"off\" :maxlength='32' :minlength='32'></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"joinRoomDialog = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleJoinRoom\">确 定</el-button>\n      </div>\n    </el-dialog>\n···\n</template>\n<script>\nimport { post } from '@/libs/request'\nexport default {\n  name: 'RoomList',\n  props: {\n    roomList: {\n      default: () => [],\n      type: Array\n    }\n  },\n  data () {\n    return {\n      ···\n      joinRoom: {\n        hashId: ''\n      }\n    }\n  },\n  method: {\n    handleJoinRoom () {\n      this.$refs.joinRoomForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/room/join',\n            data: {\n              roomIdHash: this.joinRoom.hashId\n            }\n          }\n          post(config).then((responseData) => {\n            this.$Loading.hide()\n            this.joinRoomDialog = false\n            this.$message({\n              message: '加入成功',\n              type: 'success'\n            })\n            this.$emit('create-room-success', responseData.room)\n          }).catch((err) => {\n            this.$Loading.hide()\n            console.log(err)\n          })\n        }\n      })\n    }\n  }\n}\n</script>\n```\n\n加入成功后，和创建一样，调用 join_one_chat 事件来加入房间。\n\n```js\n// /fronted/src/views/chat-room/chat-room.vue\nhandleCreateJoinRoom (room) {\n  const roomList = this.roomList\n  roomList.push(room)\n  this.$store.commit('setRoomList', roomList)\n  const request = {\n    roomId: room.id,\n    userId: this.userId\n  }\n  this.$socket.emit('join_one_chat', request)\n}\n```\n\n后端响应回调。\n\n```python\n# /backend/blueprint/socketio.py\n@socketio.on('join_one_chat', namespace='/chatroom')\ndef join_one_chat(join):\n    \"\"\"加入聊天室\n    \"\"\"\n    room = Room.query.filter_by(id=join['roomId']).first()\n    user = User.query.filter_by(id=join['userId']).first()\n    print(join)\n    if room and user:\n        join_room(room.id)\n        emit('received', {\n            'user': {\n                'id': user.id,\n                'name': user.username,\n                'avatarImage': user.avatar_image,\n            },\n            'roomId': room.id,\n            'type': 'join'\n        }, namespace='/chatroom', room=room)\n```\n\n### 消息记录的发送与保存\n\n先建个表\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-----------------------------\n-Table structure for room_record\n-----------------------------\nDROP TABLE IF EXISTS `room_record`;\nCREATE TABLE `room_record`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,\n  `create_time` datetime(0) DEFAULT NULL,\n  `room_id` int(11) DEFAULT NULL,\n  `user_id` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `ix_room_record_create_time`(`create_time`) USING BTREE,\n  INDEX `ix_room_record_room_id`(`room_id`) USING BTREE,\n  CONSTRAINT `room_record_ibfk_1` FOREIGN KEY (`room_id`) REFERENCES `room` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n用户选择了对应房间，在对应房间中发送消息就 OK 了。\n\n```js\n// /fronted/src/components/chat-room/message-box/message-box.vue\n···\nimport { mapGetters, mapActions } from 'vuex'\nimport util from '@/libs/utility/util.js'\nimport UserMessage from '../user-message/index'\nimport JoinMessage from '../join-message/index'\nimport RichText from '@/components/base/rich-text/index'\nexport default {\n  name: 'MessageBox',\n  components: {\n    UserMessage,\n    JoinMessage,\n    RichText\n  },\n  computed: {\n    ...mapGetters({\n      selectedRoom: 'getSelectedRoom',\n      userId: 'getUserId',\n      userName: 'getUserName',\n      messageList: 'getMessageList',\n      isUpdate: 'getUpdate',\n      avatarImage: 'getAvatarImage'\n    })\n  },\n  watch: {\n    selectedRoom () {\n      this.setMessageContentScroll()\n    },\n    isUpdate () {\n      if (this.isUpdate) {\n        this.$forceUpdate()\n        this.updateComplete()\n        this.setMessageContentScroll()\n      }\n    }\n  },\n  methods: {\n    ...mapActions([\n      'updateComplete',\n      'userInput'\n    ]),\n    setMessageContentScroll () {\n      this.$nextTick(() => {\n        const messageContent = document.getElementById('messageContent')\n        if (messageContent) {\n          if (messageContent.scrollHeight > messageContent.clientHeight) {\n            messageContent.scrollTop = messageContent.scrollHeight\n          }\n        }\n      })\n    },\n    sendMessage (message) {\n      const messageId = Number(new Date())\n      const messageContext = {\n        user: {\n          id: this.userId,\n          name: this.userName,\n          avatarImage: this.avatarImage\n        },\n        roomId: this.selectedRoom.id,\n        id: messageId,\n        message,\n        loading: true,\n        type: 'input'\n      }\n      const request = {\n        userId: this.userId,\n        roomId: this.selectedRoom.id,\n        id: messageId,\n        message,\n        type: 'input'\n      }\n      this.userInput(messageContext)\n      this.$socket.emit('user_send_message', request)\n    }\n  }\n}\n```\n\n后端。接收到请求后，完成插入数据库处理并通过 received 事件返回给前端\n\n```python\n# /backend/blueprint/socketio.py\n@socketio.on('user_send_message', namespace='/chatroom')\ndef user_input(message):\n    \"\"\"获取用户输入\n    \"\"\"\n    userId = message['userId']\n    user = User.query.filter_by(id=message['userId']).first()\n    if user:\n        response = {\n            'user': {\n                'id': user.id,\n                'name': user.username,\n                'avatarImage': user.avatar_image,\n            },\n            'message': message['message'],\n            'roomId': message['roomId'],\n            'id': message['id'],\n            'type': message['type'],\n            'time': datetime.utcnow().isoformat(),\n        }\n        roomRecord = RoomRecord(content=message['message'], user_id=user.id, room_id=message['roomId'])\n        db.session.add(roomRecord)\n        db.session.commit()\n        socketio.emit('received', response,\n                        namespace='/chatroom',\n                        room=message['roomId'])\n```\n\n前端 vuex 的 room 模块接收\n\n```js\n// /fronted/src/store/module/room.js\nexport default {\n  action: {\n    updateComplete ({ commit }) {\n      commit('setUpdate', false)\n    },\n    SOCKET_received ({ state, rootState, commit }, responseData) {\n      const messageList = state.messageList\n      const user = rootState.user\n      responseData.time = normalizeTimeDetail(responseData.time)\n      if (user.userId === responseData.user.id && responseData.type !== 'join') {\n        for (let i = messageList[responseData.roomId].length 1; i > 0; i--) {\n          if (messageList[responseData.roomId][i].user.id === user.userId && responseData.id === messageList[responseData.roomId][i].id) {\n            messageList[responseData.roomId][i].loading = false\n            messageList[responseData.roomId][i].time = responseData.time\n            break\n          }\n        }\n        if (!state.update) {\n          commit('setUpdate', true)\n        }\n      } else {\n        if (!messageList[responseData.roomId]) {\n          messageList[responseData.roomId] = []\n        }\n        messageList[responseData.roomId].push(responseData)\n        if (!state.update) {\n          commit('setUpdate', state.selectedRoom ? responseData.roomId === state.selectedRoom.id : false)\n        }\n      }\n      commit('setMessageList', messageList)\n    }\n  }\n}\n```\n\n## 总结\n\n说到这里其实也说完了重点的地方了，有兴趣可以看看源码。第一次写文章，有不足的地方请大佬们多多指点。\n\n## 参考连接\n\n- [1] <https://www.runoob.com/html/html5-websocket.html>\n- [2] <https://www.npmjs.com/package/vue-socket.io>\n- [3] <https://flask-socketio.readthedocs.io/en/latest/>\n","source":"_posts/socketio实现服务器推送（demo实现一个聊天室）.md","raw":"---\ntitle: socketio实现服务器推送（demo实现一个聊天室）\ndate: 2020-06-29 11:20:26\ntags:\ncategories:\n---\n\ndemo 演示地址：<http://chat.lstmxx.cn>\n\ngithub 地址：<https://github.com/Lstmxx/chatroom>\n\n## 前言\n\n服务端推送是一种服务器主动给客户端发送的技术，主要用于实时对客户端进行消息推送，如天气预报、聊天功能等。\n\n### HTTP 1.x\n\n在 websocket api 出现之前，由于 http1.x 的缺陷，导致通信只能由客户端发起，用户想要获取到实时数据变化，就要不停的向服务器发送请求，这种方法我们一般称为轮询。这种方法在 web 端可以一用，但是在移动端就不行了，想一想你的 app 不停的消耗你的流量发请求到服务器，这会导致用户流量的大量浪费，体现极其差。\n\n```js\nsetInterval(() => {\n  axios()then((res) => {\n    ···\n  }).catch(err => {\n    ···\n  })\n}, 3000)\n```\n\n### HTTP 2.0\n\n为了解决这一问题，终于在 http2.0 协议里面增加了一个新特性——服务器推送。而 Html5 根据这一特性提供了一种在单个 TCP 连接上进行全双工通讯的协议——[WebSocket](https://www.runoob.com/html/html5-websocket.html)。\n\n### Socketio\n\n#### 描述\n\n如果客户端想要使用 websocket 接受服务器推送的话，Socketio 是一个不错的选择。Socket.io 将 Websocket、轮询机制以及其它的实时通信方式（ajax 等）封装成了通用的接口，并且在服务端也实现了这些实时机制的相应代码。所以，使用 Socket.io 便不需要担心浏览器兼容问题。\n\n#### namespace 和 room\n\nsocketio 有两个重要的概念——namespace 和 room。两者关系是 namespace 包含 room。举个例子，你要通知北小区的 4 座的所有用户交管理费，你先找到了北小区（namespace）然后再找到 4 座（room），最后给 4 座里面的业主发送交管理费消息。\n\n## Socketio 的安装与使用\n\n### Vue 中使用 Socketio\n\n在 Vue 中有两种方式使用 Socketio\n\n#### 直接使用官方包\n\n下载\n\n```bash\nnpm install socket.io\n```\n\n引入\n\n```js\nimport io from 'socket.io-client'\n```\n\n使用\n\n```js\n// 这里的namespace和后端设置的namespace是一样的\nconst socket = io.connect(`http://${域名}/${namespace}`)\n\n// on函数是监听函数，接受两个参数，第一个是订阅名，第二个是接受订阅信息的回调\nsocket.on('chatMessage', res => {\n  console.log(res)\n})\nsocket.on('response', res => {\n  console.log(res)\n})\nsocket.on('connect', res => {\n  console.log(res)\n})\n···\n// emit是发送函数，第一个参数是后端的订阅名，第二个是数据，可以是任意类型\nsocket.emit('user_input', 'wdnmd')\n```\n\n#### 使用 VueSocketio\n\n相较于 socket.io-client，VueSocketio 自带支持在 vuex 中使用，这使得多组件共用消息更加便利。npm 地址：<https://www.npmjs.com/package/vue-socket.io> 。\n\n下载\n\n```bash\nnpm install vue-socket.io\n```\n\n引入\n\n```js\n// /fronted/src/main.js\nimport store from './store'\nimport VueSocketio from 'vue-socket.io'\n···\nVue.use(new VueSocketio({\n  debug: true,\n  connection: `/${namespace}`,\n  /* 推荐使用vuex引入，方便多组件状态共享 */\n  vuex: {\n    store,\n    actionPrefix: 'SOCKET_' // 前缀，为了区分vuex文件中响应函数和普通函数\n  }\n}))\n```\n\n单组件使用\n\n```js\n// 在需要监听的vue引入\n···\nexport default {\n  sockets: {\n    connect: function () {\n      console.log('socket connected')\n    },\n    received: function (res) {\n      console.log(res)\n    }\n  }\n}\n···\n```\n\nvuex 中使用\n\n```js\n// /store/module/room.js\n···\n// responseData 为响应数据\nSOCKET_received ({ state, rootState, commit }, responseData) {\n  // do something\n},\nSOCKET_join_one ({}, responseData) {\n  // do something\n}\n```\n\n### flask 中使用 Socketio\n\nflask 中使用 socketio 主要用到 Flask-SocketIO 这个包，官网地址：<https://flask-socketio.readthedocs.io/en/latest/> 。\n\n下载\n\n```python\npip install flask-socketio\n```\n\n使用\n\n```python\n···\n# /backend/blueprint/socketio.py\nfrom flask_cors import CORS # 跨域\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, close_room, rooms, disconnect\n\n# 初始化socketio\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n# 第一个参数为事件名，第二个为namespace\n# 通过监听namespace下的事件做出响应，这里的namespace和前面前端定义的namespace要相同\n# message为请求参数\n@socketio.on('test_input', namespace='/chatroom')\ndef test_input(message):\n    # do someting\n    socketio.emit('test_received', '收到啦', namespace='/chatroom')\n```\n\n在 app.py 中引入\n\n```python\n# /backend/app.py\nfrom blueprint.socketio import app, socketio, db\n···\nif __name__ == \"__main__\":\n    ···\n    socketio.run(app, host=\"0.0.0.0\", port=4999, debug=True)\n```\n\n### nginx 配置\n\n既然是前后端分离，那当然要使用 nginx 啦~\n\n配置 chatroom.conf\n\n```nginx\nupstream chat_frontend {\n    server 127.0.0.1:8181; # 前端工程运行的地址\n}\n\nupstream chat_backend {\n    server 127.0.0.1:4999; # 后端工程运行的地址\n}\n\nserver {\n    listen       80; # 监听端口\n    server_name  www.chatroom.com; #域名\n        location ^~ /api { # 普通接口路由\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-Server $host;\n            proxy_pass http://chat_backend;\n        }\n        location /socket.io { # socketio的路由\n            proxy_http_version 1.1;\n            proxy_buffering off;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"Upgrade\";\n            proxy_pass http://chat_backend;\n        }\n        location / { # 前端路由\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-Server $host;\n            proxy_pass http://chat_frontend;\n        }\n}\n```\n\n配置 host\n\n```conf\n···\n127.0.0.1 www.chatroom.com\n```\n\n### 通信\n\n前面把 flask 和 vue 都配置好了，那么先测试一下。\n\n整个流程非常简单，流程图如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe93449800d38~tplv-t2oaga2asx-image.image)\n\n#### vue\n\n获取用户输入后，向目标事件发送数据。这里我自己实现了一个简陋的 rich-text，如果不追求效果直接用 input 标签就完事了。\n\n```js\n// /src/components/chat-room/message-box/message-box.vue\n···\nsendMessage (message) {\n  // 第一个参数为事件名，第二个参数为要发送的数据\n  this.$socket.emit('test_input', message)\n}\n```\n\n在 vuex 中监听 received 事件获取服务器返回消息。\n\n```js\n// /src/store/module/room.js\nexport default {\n  ···\n  actions: {\n    ···\n    SOCKET_test_received ({ state, rootState, commit }, responseData) {\n      console.log(responseData)\n    }\n  }\n}\n\n```\n\n#### flask\n\n后端这边就非常简单了，增加一个消息回调函数就好了。\n\n```python\nfrom flask_socketio import SocketIO, emit\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n···\n@socketio.on('test_input', namespace='/chatroom')\ndef test_input(message):\n    # do someting\n    socketio.emit('test_received', '收到啦', namespace='/chatroom')\n    # 或者\n    # emit('test_received', '收到啦', namespace='/chatroom')\n```\n\n要注意的是，这个 emit 没有指定某一个 room，所以会广播给在这个 namespace 下的所有人。\n\n打开谷歌浏览器，效果如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe94c8b5e4c45~tplv-t2oaga2asx-image.image)\n\n## 实现聊天室小 demo\n\n### 构思\n\n一个简单的聊天室肯定会涉及到用户，房间和消息记录。\n\n### 实现登录页面\n\n首先解决一下用户，最核心的是登录。先建一个用户表。\n\n```sql\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `create_time` datetime(0) DEFAULT NULL,\n  `avatar_image` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `room_id_set` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT '每个用户所参加的房间',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `ix_user_username`(`username`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n```\n\n封装一下登录接口，使用 vuex 保存登录状态。因为关闭页面后 vuex 会清掉 token 使用 cookie 来保存（axios 的封装就不说了，不是重点）\n\n```js\n// /fronted/src/libs/requestApi.js\n···\nexport function baseLogin (config) {\n  const request = {\n    url: config.url,\n    method: 'POST',\n    data: config.data\n  }\n  return service.request(request)\n}\n```\n\n```js\n// /fronted/src/libs/request.js\nexport function login (config) {\n  return new Promise((resolve, reject) => {\n    baseLogin(config).then((response) => {\n      resolve(response.data.data)\n    }).catch((err) => {\n      reject(err)\n    })\n  })\n}\n```\n\n保存 token\n\n```js\n// /fronted/src/libs/utility/token.js\nimport Cookies from 'js-cookie'\nconst TOKEN_KEY = 'token'\nexport const setToken = (token) => {\n  Cookies.set(TOKEN_KEY, token, { expires: 1 })\n}\n\nexport const getToken = () => {\n  const token = Cookies.get(TOKEN_KEY)\n  if (token !== 'null') return token\n  else return false\n}\n```\n\n编写 vuex 的 user 模块\n\n```js\n// /fronted/src/store/module/user.js\nimport { getToken, setToken } from '../../libs/utility/token'\nimport { login, getUserInfo, logout } from '@/libs/request'\nexport default {\n  state: {\n    token: getToken(),\n    userName: null,\n    userId: null,\n    avatarImage: null\n  },\n  getters: {\n    getToken (state) {\n      return state.token\n    },\n    getUserName (state) {\n      return state.userName\n    },\n    getUserId (state) {\n      return state.userId\n    },\n    getAvatarImage (state) {\n      return state.avatarImage\n    }\n  },\n  mutations: {\n    setToken (state, token) {\n      state.token = token\n      setToken(token)\n    },\n    setUserName (state, name) {\n      state.userName = name\n    },\n    setUserId (state, userId) {\n      state.userId = userId\n    },\n    setAvatarImage (state, avatarImage) {\n      state.avatarImage = avatarImage\n    }\n  },\n  actions: {\n    handleLogin ({ commit }, config) {\n      return new Promise((resolve, reject) => {\n        login(config).then((responseData) => {\n          commit('setToken', responseData.token)\n          resolve(responseData)\n        }).catch((err) => {\n          reject(err)\n          console.log(err)\n        })\n      })\n    },\n    loadUserInfo ({ commit }) {\n      return new Promise((resolve, reject) => {\n        getUserInfo().then((responseData) => {\n          commit('setToken', getToken())\n          commit('setUserName', responseData.userInfo.name)\n          commit('setUserId', responseData.userInfo.userId)\n          commit('setAvatarImage', responseData.userInfo.avatar_image)\n          resolve(responseData)\n        }).catch((err) => {\n          commit('setToken', null)\n          reject(err)\n          console.log(err)\n        })\n      })\n    }\n  }\n}\n```\n\n在 login 页面中使用\n\n```js\n// /fronted/src/views/login/login.vue\nimport { mapActions } from 'vuex'\nexport default {\n  ···\n  methods: {\n    ...mapActions([\n      'handleLogin',\n      'loadUserInfo'\n    ]),\n    checkCapslock (e) {\n      const { key } = e\n      this.capsTooltip = key && key.length === 1 && (key >= 'A' && key <= 'Z')\n    },\n    // 登录，成功后跳转\n    onLogin () {\n      this.$refs.loginForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/login',\n            data: this.loginForm\n          }\n          this.handleLogin(config).then(() => {\n            this.$Loading.hide()\n            this.$router.push({\n              name: 'ChatRoom'\n            })\n          }).catch((err) => {\n            this.$Loading.hide()\n            console.log(err)\n          })\n        }\n      })\n    },\n    // 注册，成功后回调登录\n    onRegister () {\n      this.$refs.loginForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/register',\n            data: this.loginForm\n          }\n          this.handleLogin(config).then(() => {\n            this.$Loading.hide()\n            this.onLogin()\n          }).catch((err) => {\n            this.$Loading.hide()\n            console.log(err)\n          })\n        }\n      })\n    }\n  }\n}\n```\n\n后端方面，可以看看/backend/blueprint/user.py。ui 方面就不说了，不是重点。\n\n### 实现房间的创建，展示和加入功能\n\n对于房间来说，肯定要有创建和加入这两个功能的，下面先说说创建。\n\n先建个表吧\n\n```sql\nDROP TABLE IF EXISTS `room`;\nCREATE TABLE `room`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `owner` int(11) DEFAULT NULL COMMENT '房间创建人',\n  `user_set` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,\n  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,\n  `create_time` datetime(0) DEFAULT NULL,\n  `update_time` datetime(0) DEFAULT NULL,\n  `avatar_image` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `room_hash_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `ix_room_avatar_image`(`avatar_image`) USING BTREE,\n  INDEX `ix_room_create_time`(`create_time`) USING BTREE,\n  INDEX `ix_room_name`(`name`) USING BTREE,\n  INDEX `ix_room_owner`(`owner`) USING BTREE,\n  INDEX `ix_room_update_time`(`update_time`) USING BTREE,\n  CONSTRAINT `room_ibfk_1` FOREIGN KEY (`owner`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n```\n\n#### 创建房间\n\n首先先明确创建房间需要什么数据，我的想法是需要房间头像，房间名和房间描述。\n\n前端主要是获取了房间头像、房间名和房间描述后发送请求到后端。这里的 upLoadFile 是自己模仿 element 来写的组件，有兴趣可以在 /fronted/src/components/base/up-load-file/up-load-file.vue 查看\n\n```vue\n// /fronted/src/components/chat-room/room-list/room-list.vue\n<template>\n···\n    <el-dialog title=\"创建房间\" :visible.sync=\"createRoomDialog\">\n      <el-form :model=\"createRoom\" :rules=\"createRules\" ref=\"createRoomForm\">\n        <el-form-item label=\"房间名\" prop=\"hashId\">\n          <el-input v-model=\"createRoom.name\" autocomplete=\"off\" :maxlength='32' :minlength='32'></el-input>\n        </el-form-item>\n        <el-form-item label=\"房间描述\" prop=\"description\">\n          <el-input v-model=\"createRoom.description\" autocomplete=\"off\" :maxlength='32' :minlength='32'></el-input>\n        </el-form-item>\n        <el-form-item label=\"房间头像\" prop=\"avatarImage\">\n          <upLoadFile :maxImageNum=\"1\" @on-change=\"getFilePath\"/>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"createRoomDialog = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleCreateRoom\">确 定</el-button>\n      </div>\n    </el-dialog>\n···\n</template>\n<script>\nimport { post } from '@/libs/request'\nimport upLoadFile from '@/components/base/up-load-file'\nexport default {\n  name: 'RoomList',\n  props: {\n    roomList: {\n      default: () => [],\n      type: Array\n    }\n  },\n  components: {\n    ···\n    upLoadFile\n  },\n  data () {\n    return {\n      ···\n      createRoom: {\n        name: '',\n        description: '',\n        avatarImage: ''\n      }\n    }\n  },\n  method: {\n    getFilePath (imageList) {\n      this.createRoom.avatarImage = imageList[0].base64Path\n    },\n    handleCreateRoom () {\n      this.$refs.createRoomForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/room/create',\n            data: this.createRoom\n          }\n          post(config).then((responseData) => {\n            this.$Loading.hide()\n            this.createRoom.name = ''\n            this.createRoomDialog = false\n            this.createRoom = {\n              name: '',\n              description: '',\n              avatarImage: ''\n            }\n            this.$message({\n              message: '创建成功',\n              type: 'success'\n            })\n            this.$emit('create-room-success', responseData.room)\n          }).catch((err) => {\n            this.$Loading.hide()\n            this.createRoomDialog = false\n            console.log(err)\n          })\n        }\n      })\n    }\n  }\n}\n</script>\n```\n\n后端这边就简单了，直接插入数据库。插入时候使用 base64 来生成房间码，之后加入房间要用。\n\n```python\n# /backend/blueprint/room.py\n···\n@room_bp.route('/api/room/create', methods=['POST'])\n@verify_token\ndef room_create(tokenData):\n    values = request.get_json()\n    user = User.query.filter_by(id=tokenData['userId']).first()\n    if user:\n        room = Room(name=values['name'],\n                    description=values['description'],\n                    user_set=str(tokenData['userId']),\n                    owner=user.id,\n                    avatar_image='')\n        db.session.add(room)\n        db.session.flush()\n        room.room_hash_id = hashlib.md5(f'{room.id}{time.time()}'.encode('utf-8')).hexdigest()\n        room.user_set = f'{room.user_set},{user.id}' if room.user_set else user.id\n        if values['avatarImage']:\n            avatartImageList = values['avatarImage'].split(',')\n            suffix = avatartImageList[0].split('/')[1].split(';')[0]\n            filename = f'room_avatar/{room.room_hash_id}.{suffix}'\n            print(filename)\n            with open(f'media/{filename}', 'wb') as f:\n                f.write(base64.b64decode(avatartImageList[1]))\n            room.avatar_image = filename\n        user.room_id_set = f'{user.room_id_set},{room.id}' if user.room_id_set else room.id\n        db.session.commit()\n        return jsonify({\n            'data': {\n                'room': JSONHelper.model_to_json(room)\n            },\n            'message': '成功',\n            'status': 200\n        })\n    return jsonify({\n        'data': '',\n        'message': '失败失败',\n        'status': 500\n    })\n```\n\n#### 展示房间\n\n这个其实就是拉一个房间列表。要注意的是前端获取到房间列表后，要调用 join_all 这个事件监听这些房间的消息。\n\n后端\n\n```python\n@room_bp.route('/api/room/list', methods=['GET'])\n@verify_token\ndef room_list(tokenData):\n    user = User.query.filter_by(id=tokenData['userId']).first()\n    if user:\n        roomlist = Room.query.filter(Room.id.in_(user.room_id_set.split(','))).all() if user.room_id_set else []\n        return jsonify({\n            'data': {\n                'roomList': JSONHelper.to_json_list(roomlist)\n            },\n            'message': '成功',\n            'status': 200\n        })\n    return jsonify({\n        'data': '',\n        'message': '失败失败',\n        'status': 500\n    })\n```\n\n前端这边先在 room 模块里编写加载房间列表函数。\n\n```js\n// /fronted/src/store/module/room.js\n···\nloadRoomList ({ commit }) {\n  return new Promise((resolve, reject) => {\n    const config = {\n      url: '/room/list'\n    }\n    get(config).then((responseData) => {\n      commit('setRoomList', responseData.roomList)\n      resolve(responseData.roomList)\n    }).catch((err) => {\n      reject(err)\n    })\n  })\n}\n```\n\n在 chat-room 页面调用。\n\n```js\n// /fronted/src/views/chat-room/chat-room.vue\nmounted () {\n  this.loadRoomList().then((roomList) => {\n    const request = {\n      roomList: roomList.map(room => room.id),\n      userId: this.userId\n    }\n    this.$socket.emit('join_all', request)\n  }).catch((err) => {\n    console.log(err)\n  })\n}\n```\n\n后端响应 join_all 事件，调用 join_room 加入用户所在的所有房间。\n\n```python\n# /backend/blueprint/socketio.py\n@socketio.on('join_all', namespace='/chatroom')\ndef join_chats(message):\n    \"\"\"加入多个聊天室\n    \"\"\"\n    user = User.query.filter_by(id=message['userId']).first()\n    if user and len(message['roomList']) > 0:\n        for roomId in message['roomList']:\n            join_room(roomId)\n            emit('received', { # 发送加入消息\n                'user': {\n                    'id': user.id,\n                    'name': user.username,\n                    'avatarImage': user.avatar_image,\n                },\n                'roomId': roomId,\n                'type': 'join'\n            }, namespace='/chatroom', room=roomId)\n```\n\n#### 加入房间\n\n获取对应的房间码后，输入加入就 OK 了。\n\n```vue\n// /fronted/src/components/chat-room/room-list/room-list.vue\n<template>\n···\n    <el-dialog title=\"加入房间\" :visible.sync=\"joinRoomDialog\">\n      <el-form :model=\"joinRoom\" :rules=\"joinRules\" ref=\"joinRoomForm\">\n        <el-form-item label=\"房间号\" prop=\"hashId\">\n          <el-input v-model=\"joinRoom.hashId\" autocomplete=\"off\" :maxlength='32' :minlength='32'></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"joinRoomDialog = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleJoinRoom\">确 定</el-button>\n      </div>\n    </el-dialog>\n···\n</template>\n<script>\nimport { post } from '@/libs/request'\nexport default {\n  name: 'RoomList',\n  props: {\n    roomList: {\n      default: () => [],\n      type: Array\n    }\n  },\n  data () {\n    return {\n      ···\n      joinRoom: {\n        hashId: ''\n      }\n    }\n  },\n  method: {\n    handleJoinRoom () {\n      this.$refs.joinRoomForm.validate(valid => {\n        if (valid) {\n          this.$Loading.show()\n          const config = {\n            url: '/room/join',\n            data: {\n              roomIdHash: this.joinRoom.hashId\n            }\n          }\n          post(config).then((responseData) => {\n            this.$Loading.hide()\n            this.joinRoomDialog = false\n            this.$message({\n              message: '加入成功',\n              type: 'success'\n            })\n            this.$emit('create-room-success', responseData.room)\n          }).catch((err) => {\n            this.$Loading.hide()\n            console.log(err)\n          })\n        }\n      })\n    }\n  }\n}\n</script>\n```\n\n加入成功后，和创建一样，调用 join_one_chat 事件来加入房间。\n\n```js\n// /fronted/src/views/chat-room/chat-room.vue\nhandleCreateJoinRoom (room) {\n  const roomList = this.roomList\n  roomList.push(room)\n  this.$store.commit('setRoomList', roomList)\n  const request = {\n    roomId: room.id,\n    userId: this.userId\n  }\n  this.$socket.emit('join_one_chat', request)\n}\n```\n\n后端响应回调。\n\n```python\n# /backend/blueprint/socketio.py\n@socketio.on('join_one_chat', namespace='/chatroom')\ndef join_one_chat(join):\n    \"\"\"加入聊天室\n    \"\"\"\n    room = Room.query.filter_by(id=join['roomId']).first()\n    user = User.query.filter_by(id=join['userId']).first()\n    print(join)\n    if room and user:\n        join_room(room.id)\n        emit('received', {\n            'user': {\n                'id': user.id,\n                'name': user.username,\n                'avatarImage': user.avatar_image,\n            },\n            'roomId': room.id,\n            'type': 'join'\n        }, namespace='/chatroom', room=room)\n```\n\n### 消息记录的发送与保存\n\n先建个表\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-----------------------------\n-Table structure for room_record\n-----------------------------\nDROP TABLE IF EXISTS `room_record`;\nCREATE TABLE `room_record`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,\n  `create_time` datetime(0) DEFAULT NULL,\n  `room_id` int(11) DEFAULT NULL,\n  `user_id` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `ix_room_record_create_time`(`create_time`) USING BTREE,\n  INDEX `ix_room_record_room_id`(`room_id`) USING BTREE,\n  CONSTRAINT `room_record_ibfk_1` FOREIGN KEY (`room_id`) REFERENCES `room` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n用户选择了对应房间，在对应房间中发送消息就 OK 了。\n\n```js\n// /fronted/src/components/chat-room/message-box/message-box.vue\n···\nimport { mapGetters, mapActions } from 'vuex'\nimport util from '@/libs/utility/util.js'\nimport UserMessage from '../user-message/index'\nimport JoinMessage from '../join-message/index'\nimport RichText from '@/components/base/rich-text/index'\nexport default {\n  name: 'MessageBox',\n  components: {\n    UserMessage,\n    JoinMessage,\n    RichText\n  },\n  computed: {\n    ...mapGetters({\n      selectedRoom: 'getSelectedRoom',\n      userId: 'getUserId',\n      userName: 'getUserName',\n      messageList: 'getMessageList',\n      isUpdate: 'getUpdate',\n      avatarImage: 'getAvatarImage'\n    })\n  },\n  watch: {\n    selectedRoom () {\n      this.setMessageContentScroll()\n    },\n    isUpdate () {\n      if (this.isUpdate) {\n        this.$forceUpdate()\n        this.updateComplete()\n        this.setMessageContentScroll()\n      }\n    }\n  },\n  methods: {\n    ...mapActions([\n      'updateComplete',\n      'userInput'\n    ]),\n    setMessageContentScroll () {\n      this.$nextTick(() => {\n        const messageContent = document.getElementById('messageContent')\n        if (messageContent) {\n          if (messageContent.scrollHeight > messageContent.clientHeight) {\n            messageContent.scrollTop = messageContent.scrollHeight\n          }\n        }\n      })\n    },\n    sendMessage (message) {\n      const messageId = Number(new Date())\n      const messageContext = {\n        user: {\n          id: this.userId,\n          name: this.userName,\n          avatarImage: this.avatarImage\n        },\n        roomId: this.selectedRoom.id,\n        id: messageId,\n        message,\n        loading: true,\n        type: 'input'\n      }\n      const request = {\n        userId: this.userId,\n        roomId: this.selectedRoom.id,\n        id: messageId,\n        message,\n        type: 'input'\n      }\n      this.userInput(messageContext)\n      this.$socket.emit('user_send_message', request)\n    }\n  }\n}\n```\n\n后端。接收到请求后，完成插入数据库处理并通过 received 事件返回给前端\n\n```python\n# /backend/blueprint/socketio.py\n@socketio.on('user_send_message', namespace='/chatroom')\ndef user_input(message):\n    \"\"\"获取用户输入\n    \"\"\"\n    userId = message['userId']\n    user = User.query.filter_by(id=message['userId']).first()\n    if user:\n        response = {\n            'user': {\n                'id': user.id,\n                'name': user.username,\n                'avatarImage': user.avatar_image,\n            },\n            'message': message['message'],\n            'roomId': message['roomId'],\n            'id': message['id'],\n            'type': message['type'],\n            'time': datetime.utcnow().isoformat(),\n        }\n        roomRecord = RoomRecord(content=message['message'], user_id=user.id, room_id=message['roomId'])\n        db.session.add(roomRecord)\n        db.session.commit()\n        socketio.emit('received', response,\n                        namespace='/chatroom',\n                        room=message['roomId'])\n```\n\n前端 vuex 的 room 模块接收\n\n```js\n// /fronted/src/store/module/room.js\nexport default {\n  action: {\n    updateComplete ({ commit }) {\n      commit('setUpdate', false)\n    },\n    SOCKET_received ({ state, rootState, commit }, responseData) {\n      const messageList = state.messageList\n      const user = rootState.user\n      responseData.time = normalizeTimeDetail(responseData.time)\n      if (user.userId === responseData.user.id && responseData.type !== 'join') {\n        for (let i = messageList[responseData.roomId].length 1; i > 0; i--) {\n          if (messageList[responseData.roomId][i].user.id === user.userId && responseData.id === messageList[responseData.roomId][i].id) {\n            messageList[responseData.roomId][i].loading = false\n            messageList[responseData.roomId][i].time = responseData.time\n            break\n          }\n        }\n        if (!state.update) {\n          commit('setUpdate', true)\n        }\n      } else {\n        if (!messageList[responseData.roomId]) {\n          messageList[responseData.roomId] = []\n        }\n        messageList[responseData.roomId].push(responseData)\n        if (!state.update) {\n          commit('setUpdate', state.selectedRoom ? responseData.roomId === state.selectedRoom.id : false)\n        }\n      }\n      commit('setMessageList', messageList)\n    }\n  }\n}\n```\n\n## 总结\n\n说到这里其实也说完了重点的地方了，有兴趣可以看看源码。第一次写文章，有不足的地方请大佬们多多指点。\n\n## 参考连接\n\n- [1] <https://www.runoob.com/html/html5-websocket.html>\n- [2] <https://www.npmjs.com/package/vue-socket.io>\n- [3] <https://flask-socketio.readthedocs.io/en/latest/>\n","slug":"socketio实现服务器推送（demo实现一个聊天室）","published":1,"updated":"2023-09-23T03:40:32.475Z","_id":"clmvgqo5b0001xpyhbmmcdhku","comments":1,"layout":"post","photos":[],"link":"","content":"<p>demo 演示地址：<a href=\"http://chat.lstmxx.cn/\">http://chat.lstmxx.cn</a></p>\n<p>github 地址：<a href=\"https://github.com/Lstmxx/chatroom\">https://github.com/Lstmxx/chatroom</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>服务端推送是一种服务器主动给客户端发送的技术，主要用于实时对客户端进行消息推送，如天气预报、聊天功能等。</p>\n<h3 id=\"HTTP-1-x\"><a href=\"#HTTP-1-x\" class=\"headerlink\" title=\"HTTP 1.x\"></a>HTTP 1.x</h3><p>在 websocket api 出现之前，由于 http1.x 的缺陷，导致通信只能由客户端发起，用户想要获取到实时数据变化，就要不停的向服务器发送请求，这种方法我们一般称为轮询。这种方法在 web 端可以一用，但是在移动端就不行了，想一想你的 app 不停的消耗你的流量发请求到服务器，这会导致用户流量的大量浪费，体现极其差。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">axios</span>()<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;, <span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP 2.0\"></a>HTTP 2.0</h3><p>为了解决这一问题，终于在 http2.0 协议里面增加了一个新特性——服务器推送。而 Html5 根据这一特性提供了一种在单个 TCP 连接上进行全双工通讯的协议——<a href=\"https://www.runoob.com/html/html5-websocket.html\">WebSocket</a>。</p>\n<h3 id=\"Socketio\"><a href=\"#Socketio\" class=\"headerlink\" title=\"Socketio\"></a>Socketio</h3><h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>如果客户端想要使用 websocket 接受服务器推送的话，Socketio 是一个不错的选择。Socket.io 将 Websocket、轮询机制以及其它的实时通信方式（ajax 等）封装成了通用的接口，并且在服务端也实现了这些实时机制的相应代码。所以，使用 Socket.io 便不需要担心浏览器兼容问题。</p>\n<h4 id=\"namespace-和-room\"><a href=\"#namespace-和-room\" class=\"headerlink\" title=\"namespace 和 room\"></a>namespace 和 room</h4><p>socketio 有两个重要的概念——namespace 和 room。两者关系是 namespace 包含 room。举个例子，你要通知北小区的 4 座的所有用户交管理费，你先找到了北小区（namespace）然后再找到 4 座（room），最后给 4 座里面的业主发送交管理费消息。</p>\n<h2 id=\"Socketio-的安装与使用\"><a href=\"#Socketio-的安装与使用\" class=\"headerlink\" title=\"Socketio 的安装与使用\"></a>Socketio 的安装与使用</h2><h3 id=\"Vue-中使用-Socketio\"><a href=\"#Vue-中使用-Socketio\" class=\"headerlink\" title=\"Vue 中使用 Socketio\"></a>Vue 中使用 Socketio</h3><p>在 Vue 中有两种方式使用 Socketio</p>\n<h4 id=\"直接使用官方包\"><a href=\"#直接使用官方包\" class=\"headerlink\" title=\"直接使用官方包\"></a>直接使用官方包</h4><p>下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install socket.io</span><br></pre></td></tr></table></figure>\n\n<p>引入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io <span class=\"keyword\">from</span> <span class=\"string\">&#x27;socket.io-client&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的namespace和后端设置的namespace是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io.<span class=\"title function_\">connect</span>(<span class=\"string\">`http://<span class=\"subst\">$&#123;域名&#125;</span>/<span class=\"subst\">$&#123;namespace&#125;</span>`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on函数是监听函数，接受两个参数，第一个是订阅名，第二个是接受订阅信息的回调</span></span><br><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;chatMessage&#x27;</span>, <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;response&#x27;</span>, <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;connect&#x27;</span>, <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"comment\">// emit是发送函数，第一个参数是后端的订阅名，第二个是数据，可以是任意类型</span></span><br><span class=\"line\">socket.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;user_input&#x27;</span>, <span class=\"string\">&#x27;wdnmd&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-VueSocketio\"><a href=\"#使用-VueSocketio\" class=\"headerlink\" title=\"使用 VueSocketio\"></a>使用 VueSocketio</h4><p>相较于 socket.io-client，VueSocketio 自带支持在 vuex 中使用，这使得多组件共用消息更加便利。npm 地址：<a href=\"https://www.npmjs.com/package/vue-socket.io\">https://www.npmjs.com/package/vue-socket.io</a> 。</p>\n<p>下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-socket.io</span><br></pre></td></tr></table></figure>\n\n<p>引入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VueSocketio</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-socket.io&#x27;</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">VueSocketio</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">debug</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">connection</span>: <span class=\"string\">`/<span class=\"subst\">$&#123;namespace&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"comment\">/* 推荐使用vuex引入，方便多组件状态共享 */</span></span><br><span class=\"line\">  <span class=\"attr\">vuex</span>: &#123;</span><br><span class=\"line\">    store,</span><br><span class=\"line\">    <span class=\"attr\">actionPrefix</span>: <span class=\"string\">&#x27;SOCKET_&#x27;</span> <span class=\"comment\">// 前缀，为了区分vuex文件中响应函数和普通函数</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>单组件使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在需要监听的vue引入</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">sockets</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">connect</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;socket connected&#x27;</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">received</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">···</span><br></pre></td></tr></table></figure>\n\n<p>vuex 中使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /store/module/room.js</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"comment\">// responseData 为响应数据</span></span><br><span class=\"line\">SOCKET_received (&#123; state, rootState, commit &#125;, responseData) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">SOCKET_join_one (&#123;&#125;, responseData) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flask-中使用-Socketio\"><a href=\"#flask-中使用-Socketio\" class=\"headerlink\" title=\"flask 中使用 Socketio\"></a>flask 中使用 Socketio</h3><p>flask 中使用 socketio 主要用到 Flask-SocketIO 这个包，官网地址：<a href=\"https://flask-socketio.readthedocs.io/en/latest/\">https://flask-socketio.readthedocs.io/en/latest/</a> 。</p>\n<p>下载</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install flask-socketio</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">···</span><br><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_cors <span class=\"keyword\">import</span> CORS <span class=\"comment\"># 跨域</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_socketio <span class=\"keyword\">import</span> SocketIO, emit, join_room, leave_room, close_room, rooms, disconnect</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化socketio</span></span><br><span class=\"line\">socketio = SocketIO(app, cors_allowed_origins=<span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 第一个参数为事件名，第二个为namespace</span></span><br><span class=\"line\"><span class=\"comment\"># 通过监听namespace下的事件做出响应，这里的namespace和前面前端定义的namespace要相同</span></span><br><span class=\"line\"><span class=\"comment\"># message为请求参数</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;test_input&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_input</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"comment\"># do someting</span></span><br><span class=\"line\">    socketio.emit(<span class=\"string\">&#x27;test_received&#x27;</span>, <span class=\"string\">&#x27;收到啦&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在 app.py 中引入</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/app.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> blueprint.socketio <span class=\"keyword\">import</span> app, socketio, db</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    socketio.run(app, host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, port=<span class=\"number\">4999</span>, debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"nginx-配置\"><a href=\"#nginx-配置\" class=\"headerlink\" title=\"nginx 配置\"></a>nginx 配置</h3><p>既然是前后端分离，那当然要使用 nginx 啦~</p>\n<p>配置 chatroom.conf</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">upstream</span> chat_frontend &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">127.0.0.1:8181</span>; <span class=\"comment\"># 前端工程运行的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">upstream</span> chat_backend &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">127.0.0.1:4999</span>; <span class=\"comment\"># 后端工程运行的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span>       <span class=\"number\">80</span>; <span class=\"comment\"># 监听端口</span></span><br><span class=\"line\">    <span class=\"attribute\">server_name</span>  www.chatroom.com; <span class=\"comment\">#域名</span></span><br><span class=\"line\">        <span class=\"section\">location</span><span class=\"regexp\"> ^~</span> /api &#123; <span class=\"comment\"># 普通接口路由</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Server <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://chat_backend;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"section\">location</span> /socket.io &#123; <span class=\"comment\"># socketio的路由</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_http_version</span> <span class=\"number\">1</span>.<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_buffering</span> <span class=\"literal\">off</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Upgrade <span class=\"variable\">$http_upgrade</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Connection <span class=\"string\">&quot;Upgrade&quot;</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://chat_backend;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123; <span class=\"comment\"># 前端路由</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Server <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://chat_frontend;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置 host</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">···</span><br><span class=\"line\">127.0.0.1 www.chatroom.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h3><p>前面把 flask 和 vue 都配置好了，那么先测试一下。</p>\n<p>整个流程非常简单，流程图如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe93449800d38~tplv-t2oaga2asx-image.image\"></p>\n<h4 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h4><p>获取用户输入后，向目标事件发送数据。这里我自己实现了一个简陋的 rich-text，如果不追求效果直接用 input 标签就完事了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /src/components/chat-room/message-box/message-box.vue</span></span><br><span class=\"line\">···</span><br><span class=\"line\">sendMessage (message) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个参数为事件名，第二个参数为要发送的数据</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;test_input&#x27;</span>, message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 vuex 中监听 received 事件获取服务器返回消息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /src/store/module/room.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    SOCKET_test_received (&#123; state, rootState, commit &#125;, responseData) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(responseData)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flask\"><a href=\"#flask\" class=\"headerlink\" title=\"flask\"></a>flask</h4><p>后端这边就非常简单了，增加一个消息回调函数就好了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_socketio <span class=\"keyword\">import</span> SocketIO, emit</span><br><span class=\"line\">socketio = SocketIO(app, cors_allowed_origins=<span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;test_input&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_input</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"comment\"># do someting</span></span><br><span class=\"line\">    socketio.emit(<span class=\"string\">&#x27;test_received&#x27;</span>, <span class=\"string\">&#x27;收到啦&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 或者</span></span><br><span class=\"line\">    <span class=\"comment\"># emit(&#x27;test_received&#x27;, &#x27;收到啦&#x27;, namespace=&#x27;/chatroom&#x27;)</span></span><br></pre></td></tr></table></figure>\n\n<p>要注意的是，这个 emit 没有指定某一个 room，所以会广播给在这个 namespace 下的所有人。</p>\n<p>打开谷歌浏览器，效果如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe94c8b5e4c45~tplv-t2oaga2asx-image.image\"></p>\n<h2 id=\"实现聊天室小-demo\"><a href=\"#实现聊天室小-demo\" class=\"headerlink\" title=\"实现聊天室小 demo\"></a>实现聊天室小 demo</h2><h3 id=\"构思\"><a href=\"#构思\" class=\"headerlink\" title=\"构思\"></a>构思</h3><p>一个简单的聊天室肯定会涉及到用户，房间和消息记录。</p>\n<h3 id=\"实现登录页面\"><a href=\"#实现登录页面\" class=\"headerlink\" title=\"实现登录页面\"></a>实现登录页面</h3><p>首先解决一下用户，最核心的是登录。先建一个用户表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `<span class=\"keyword\">user</span>`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>`  (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `username` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `password` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `avatar_image` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `room_id_set` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci COMMENT <span class=\"string\">&#x27;每个用户所参加的房间&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_user_username`(`username`) <span class=\"keyword\">USING</span> BTREE</span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> InnoDB AUTO_INCREMENT <span class=\"operator\">=</span> <span class=\"number\">5</span> <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> <span class=\"operator\">=</span> utf8mb4 <span class=\"keyword\">COLLATE</span> <span class=\"operator\">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class=\"operator\">=</span> <span class=\"keyword\">Dynamic</span>;</span><br></pre></td></tr></table></figure>\n\n<p>封装一下登录接口，使用 vuex 保存登录状态。因为关闭页面后 vuex 会清掉 token 使用 cookie 来保存（axios 的封装就不说了，不是重点）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/libs/requestApi.js</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">baseLogin</span> (config) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>: config.<span class=\"property\">url</span>,</span><br><span class=\"line\">    <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: config.<span class=\"property\">data</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> service.<span class=\"title function_\">request</span>(request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/libs/request.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">login</span> (config) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">baseLogin</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(response.<span class=\"property\">data</span>.<span class=\"property\">data</span>)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存 token</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/libs/utility/token.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Cookies</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;js-cookie&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">TOKEN_KEY</span> = <span class=\"string\">&#x27;token&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">setToken</span> = (<span class=\"params\">token</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Cookies</span>.<span class=\"title function_\">set</span>(<span class=\"variable constant_\">TOKEN_KEY</span>, token, &#123; <span class=\"attr\">expires</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">getToken</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = <span class=\"title class_\">Cookies</span>.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">TOKEN_KEY</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (token !== <span class=\"string\">&#x27;null&#x27;</span>) <span class=\"keyword\">return</span> token</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写 vuex 的 user 模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/store/module/user.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getToken, setToken &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../libs/utility/token&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; login, getUserInfo, logout &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/libs/request&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">token</span>: <span class=\"title function_\">getToken</span>(),</span><br><span class=\"line\">    <span class=\"attr\">userName</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">userId</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">avatarImage</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    getToken (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">token</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getUserName (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">userName</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getUserId (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">userId</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getAvatarImage (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">avatarImage</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    setToken (state, token) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">token</span> = token</span><br><span class=\"line\">      <span class=\"title function_\">setToken</span>(token)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setUserName (state, name) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">userName</span> = name</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setUserId (state, userId) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">userId</span> = userId</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setAvatarImage (state, avatarImage) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">avatarImage</span> = avatarImage</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    handleLogin (&#123; commit &#125;, config) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">login</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setToken&#x27;</span>, responseData.<span class=\"property\">token</span>)</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(responseData)</span><br><span class=\"line\">        &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    loadUserInfo (&#123; commit &#125;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">getUserInfo</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setToken&#x27;</span>, <span class=\"title function_\">getToken</span>())</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUserName&#x27;</span>, responseData.<span class=\"property\">userInfo</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUserId&#x27;</span>, responseData.<span class=\"property\">userInfo</span>.<span class=\"property\">userId</span>)</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setAvatarImage&#x27;</span>, responseData.<span class=\"property\">userInfo</span>.<span class=\"property\">avatar_image</span>)</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(responseData)</span><br><span class=\"line\">        &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setToken&#x27;</span>, <span class=\"literal\">null</span>)</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 login 页面中使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/views/login/login.vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>([</span><br><span class=\"line\">      <span class=\"string\">&#x27;handleLogin&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;loadUserInfo&#x27;</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    checkCapslock (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; key &#125; = e</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">capsTooltip</span> = key &amp;&amp; key.<span class=\"property\">length</span> === <span class=\"number\">1</span> &amp;&amp; (key &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; key &lt;= <span class=\"string\">&#x27;Z&#x27;</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 登录，成功后跳转</span></span><br><span class=\"line\">    onLogin () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">$refs</span>.<span class=\"property\">loginForm</span>.<span class=\"title function_\">validate</span>(<span class=\"function\"><span class=\"params\">valid</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (valid) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">show</span>()</span><br><span class=\"line\">          <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&#x27;/login&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">loginForm</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleLogin</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">name</span>: <span class=\"string\">&#x27;ChatRoom&#x27;</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 注册，成功后回调登录</span></span><br><span class=\"line\">    onRegister () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">$refs</span>.<span class=\"property\">loginForm</span>.<span class=\"title function_\">validate</span>(<span class=\"function\"><span class=\"params\">valid</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (valid) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">show</span>()</span><br><span class=\"line\">          <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&#x27;/register&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">loginForm</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleLogin</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">onLogin</span>()</span><br><span class=\"line\">          &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端方面，可以看看/backend/blueprint/user.py。ui 方面就不说了，不是重点。</p>\n<h3 id=\"实现房间的创建，展示和加入功能\"><a href=\"#实现房间的创建，展示和加入功能\" class=\"headerlink\" title=\"实现房间的创建，展示和加入功能\"></a>实现房间的创建，展示和加入功能</h3><p>对于房间来说，肯定要有创建和加入这两个功能的，下面先说说创建。</p>\n<p>先建个表吧</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `room`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `room`  (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `name` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `owner` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;房间创建人&#x27;</span>,</span><br><span class=\"line\">  `user_set` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci,</span><br><span class=\"line\">  `description` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `update_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `avatar_image` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `room_hash_id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_avatar_image`(`avatar_image`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_create_time`(`create_time`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_name`(`name`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_owner`(`owner`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_update_time`(`update_time`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> `room_ibfk_1` <span class=\"keyword\">FOREIGN</span> KEY (`owner`) <span class=\"keyword\">REFERENCES</span> `<span class=\"keyword\">user</span>` (`id`) <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> RESTRICT <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> RESTRICT</span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> InnoDB AUTO_INCREMENT <span class=\"operator\">=</span> <span class=\"number\">38</span> <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> <span class=\"operator\">=</span> utf8mb4 <span class=\"keyword\">COLLATE</span> <span class=\"operator\">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class=\"operator\">=</span> <span class=\"keyword\">Dynamic</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建房间\"><a href=\"#创建房间\" class=\"headerlink\" title=\"创建房间\"></a>创建房间</h4><p>首先先明确创建房间需要什么数据，我的想法是需要房间头像，房间名和房间描述。</p>\n<p>前端主要是获取了房间头像、房间名和房间描述后发送请求到后端。这里的 upLoadFile 是自己模仿 element 来写的组件，有兴趣可以在 /fronted/src/components/base/up-load-file/up-load-file.vue 查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// /fronted/src/components/chat-room/room-list/room-list.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">    &lt;el-dialog title=&quot;创建房间&quot; :visible.sync=&quot;createRoomDialog&quot;&gt;</span><br><span class=\"line\">      &lt;el-form :model=&quot;createRoom&quot; :rules=&quot;createRules&quot; ref=&quot;createRoomForm&quot;&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间名&quot; prop=&quot;hashId&quot;&gt;</span><br><span class=\"line\">          &lt;el-input v-model=&quot;createRoom.name&quot; autocomplete=&quot;off&quot; :maxlength=&#x27;32&#x27; :minlength=&#x27;32&#x27;&gt;&lt;/el-input&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间描述&quot; prop=&quot;description&quot;&gt;</span><br><span class=\"line\">          &lt;el-input v-model=&quot;createRoom.description&quot; autocomplete=&quot;off&quot; :maxlength=&#x27;32&#x27; :minlength=&#x27;32&#x27;&gt;&lt;/el-input&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间头像&quot; prop=&quot;avatarImage&quot;&gt;</span><br><span class=\"line\">          &lt;upLoadFile :maxImageNum=&quot;1&quot; @on-change=&quot;getFilePath&quot;/&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">      &lt;/el-form&gt;</span><br><span class=\"line\">      &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">        &lt;el-button @click=&quot;createRoomDialog = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class=\"line\">        &lt;el-button type=&quot;primary&quot; @click=&quot;handleCreateRoom&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/el-dialog&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; post &#125; from &#x27;@/libs/request&#x27;</span><br><span class=\"line\">import upLoadFile from &#x27;@/components/base/up-load-file&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;RoomList&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    roomList: &#123;</span><br><span class=\"line\">      default: () =&gt; [],</span><br><span class=\"line\">      type: Array</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    upLoadFile</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ···</span><br><span class=\"line\">      createRoom: &#123;</span><br><span class=\"line\">        name: &#x27;&#x27;,</span><br><span class=\"line\">        description: &#x27;&#x27;,</span><br><span class=\"line\">        avatarImage: &#x27;&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  method: &#123;</span><br><span class=\"line\">    getFilePath (imageList) &#123;</span><br><span class=\"line\">      this.createRoom.avatarImage = imageList[0].base64Path</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleCreateRoom () &#123;</span><br><span class=\"line\">      this.$refs.createRoomForm.validate(valid =&gt; &#123;</span><br><span class=\"line\">        if (valid) &#123;</span><br><span class=\"line\">          this.$Loading.show()</span><br><span class=\"line\">          const config = &#123;</span><br><span class=\"line\">            url: &#x27;/room/create&#x27;,</span><br><span class=\"line\">            data: this.createRoom</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          post(config).then((responseData) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            this.createRoom.name = &#x27;&#x27;</span><br><span class=\"line\">            this.createRoomDialog = false</span><br><span class=\"line\">            this.createRoom = &#123;</span><br><span class=\"line\">              name: &#x27;&#x27;,</span><br><span class=\"line\">              description: &#x27;&#x27;,</span><br><span class=\"line\">              avatarImage: &#x27;&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            this.$message(&#123;</span><br><span class=\"line\">              message: &#x27;创建成功&#x27;,</span><br><span class=\"line\">              type: &#x27;success&#x27;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.$emit(&#x27;create-room-success&#x27;, responseData.room)</span><br><span class=\"line\">          &#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            this.createRoomDialog = false</span><br><span class=\"line\">            console.log(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>后端这边就简单了，直接插入数据库。插入时候使用 base64 来生成房间码，之后加入房间要用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/room.py</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"meta\">@room_bp.route(<span class=\"params\"><span class=\"string\">&#x27;/api/room/create&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@verify_token</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">room_create</span>(<span class=\"params\">tokenData</span>):</span><br><span class=\"line\">    values = request.get_json()</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=tokenData[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user:</span><br><span class=\"line\">        room = Room(name=values[<span class=\"string\">&#x27;name&#x27;</span>],</span><br><span class=\"line\">                    description=values[<span class=\"string\">&#x27;description&#x27;</span>],</span><br><span class=\"line\">                    user_set=<span class=\"built_in\">str</span>(tokenData[<span class=\"string\">&#x27;userId&#x27;</span>]),</span><br><span class=\"line\">                    owner=user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                    avatar_image=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        db.session.add(room)</span><br><span class=\"line\">        db.session.flush()</span><br><span class=\"line\">        room.room_hash_id = hashlib.md5(<span class=\"string\">f&#x27;<span class=\"subst\">&#123;room.<span class=\"built_in\">id</span>&#125;</span><span class=\"subst\">&#123;time.time()&#125;</span>&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class=\"line\">        room.user_set = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;room.user_set&#125;</span>,<span class=\"subst\">&#123;user.<span class=\"built_in\">id</span>&#125;</span>&#x27;</span> <span class=\"keyword\">if</span> room.user_set <span class=\"keyword\">else</span> user.<span class=\"built_in\">id</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> values[<span class=\"string\">&#x27;avatarImage&#x27;</span>]:</span><br><span class=\"line\">            avatartImageList = values[<span class=\"string\">&#x27;avatarImage&#x27;</span>].split(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">            suffix = avatartImageList[<span class=\"number\">0</span>].split(<span class=\"string\">&#x27;/&#x27;</span>)[<span class=\"number\">1</span>].split(<span class=\"string\">&#x27;;&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">            filename = <span class=\"string\">f&#x27;room_avatar/<span class=\"subst\">&#123;room.room_hash_id&#125;</span>.<span class=\"subst\">&#123;suffix&#125;</span>&#x27;</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(filename)</span><br><span class=\"line\">            <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&#x27;media/<span class=\"subst\">&#123;filename&#125;</span>&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">                f.write(base64.b64decode(avatartImageList[<span class=\"number\">1</span>]))</span><br><span class=\"line\">            room.avatar_image = filename</span><br><span class=\"line\">        user.room_id_set = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;user.room_id_set&#125;</span>,<span class=\"subst\">&#123;room.<span class=\"built_in\">id</span>&#125;</span>&#x27;</span> <span class=\"keyword\">if</span> user.room_id_set <span class=\"keyword\">else</span> room.<span class=\"built_in\">id</span></span><br><span class=\"line\">        db.session.commit()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;data&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;room&#x27;</span>: JSONHelper.model_to_json(room)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;成功&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;data&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;失败失败&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">500</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"展示房间\"><a href=\"#展示房间\" class=\"headerlink\" title=\"展示房间\"></a>展示房间</h4><p>这个其实就是拉一个房间列表。要注意的是前端获取到房间列表后，要调用 join_all 这个事件监听这些房间的消息。</p>\n<p>后端</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@room_bp.route(<span class=\"params\"><span class=\"string\">&#x27;/api/room/list&#x27;</span>, methods=[<span class=\"string\">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@verify_token</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">room_list</span>(<span class=\"params\">tokenData</span>):</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=tokenData[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user:</span><br><span class=\"line\">        roomlist = Room.query.<span class=\"built_in\">filter</span>(Room.<span class=\"built_in\">id</span>.in_(user.room_id_set.split(<span class=\"string\">&#x27;,&#x27;</span>))).<span class=\"built_in\">all</span>() <span class=\"keyword\">if</span> user.room_id_set <span class=\"keyword\">else</span> []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;data&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;roomList&#x27;</span>: JSONHelper.to_json_list(roomlist)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;成功&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;data&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;失败失败&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">500</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>前端这边先在 room 模块里编写加载房间列表函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/store/module/room.js</span></span><br><span class=\"line\">···</span><br><span class=\"line\">loadRoomList (&#123; commit &#125;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&#x27;/room/list&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setRoomList&#x27;</span>, responseData.<span class=\"property\">roomList</span>)</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(responseData.<span class=\"property\">roomList</span>)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 chat-room 页面调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/views/chat-room/chat-room.vue</span></span><br><span class=\"line\">mounted () &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">loadRoomList</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">roomList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">      <span class=\"attr\">roomList</span>: roomList.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">room</span> =&gt;</span> room.<span class=\"property\">id</span>),</span><br><span class=\"line\">      <span class=\"attr\">userId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;join_all&#x27;</span>, request)</span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端响应 join_all 事件，调用 join_room 加入用户所在的所有房间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;join_all&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">join_chats</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;加入多个聊天室</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=message[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user <span class=\"keyword\">and</span> <span class=\"built_in\">len</span>(message[<span class=\"string\">&#x27;roomList&#x27;</span>]) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> roomId <span class=\"keyword\">in</span> message[<span class=\"string\">&#x27;roomList&#x27;</span>]:</span><br><span class=\"line\">            join_room(roomId)</span><br><span class=\"line\">            emit(<span class=\"string\">&#x27;received&#x27;</span>, &#123; <span class=\"comment\"># 发送加入消息</span></span><br><span class=\"line\">                <span class=\"string\">&#x27;user&#x27;</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">&#x27;id&#x27;</span>: user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;name&#x27;</span>: user.username,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;avatarImage&#x27;</span>: user.avatar_image,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"string\">&#x27;roomId&#x27;</span>: roomId,</span><br><span class=\"line\">                <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;join&#x27;</span></span><br><span class=\"line\">            &#125;, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>, room=roomId)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"加入房间\"><a href=\"#加入房间\" class=\"headerlink\" title=\"加入房间\"></a>加入房间</h4><p>获取对应的房间码后，输入加入就 OK 了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// /fronted/src/components/chat-room/room-list/room-list.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">    &lt;el-dialog title=&quot;加入房间&quot; :visible.sync=&quot;joinRoomDialog&quot;&gt;</span><br><span class=\"line\">      &lt;el-form :model=&quot;joinRoom&quot; :rules=&quot;joinRules&quot; ref=&quot;joinRoomForm&quot;&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间号&quot; prop=&quot;hashId&quot;&gt;</span><br><span class=\"line\">          &lt;el-input v-model=&quot;joinRoom.hashId&quot; autocomplete=&quot;off&quot; :maxlength=&#x27;32&#x27; :minlength=&#x27;32&#x27;&gt;&lt;/el-input&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">      &lt;/el-form&gt;</span><br><span class=\"line\">      &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">        &lt;el-button @click=&quot;joinRoomDialog = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class=\"line\">        &lt;el-button type=&quot;primary&quot; @click=&quot;handleJoinRoom&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/el-dialog&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; post &#125; from &#x27;@/libs/request&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;RoomList&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    roomList: &#123;</span><br><span class=\"line\">      default: () =&gt; [],</span><br><span class=\"line\">      type: Array</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ···</span><br><span class=\"line\">      joinRoom: &#123;</span><br><span class=\"line\">        hashId: &#x27;&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  method: &#123;</span><br><span class=\"line\">    handleJoinRoom () &#123;</span><br><span class=\"line\">      this.$refs.joinRoomForm.validate(valid =&gt; &#123;</span><br><span class=\"line\">        if (valid) &#123;</span><br><span class=\"line\">          this.$Loading.show()</span><br><span class=\"line\">          const config = &#123;</span><br><span class=\"line\">            url: &#x27;/room/join&#x27;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">              roomIdHash: this.joinRoom.hashId</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          post(config).then((responseData) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            this.joinRoomDialog = false</span><br><span class=\"line\">            this.$message(&#123;</span><br><span class=\"line\">              message: &#x27;加入成功&#x27;,</span><br><span class=\"line\">              type: &#x27;success&#x27;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.$emit(&#x27;create-room-success&#x27;, responseData.room)</span><br><span class=\"line\">          &#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            console.log(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>加入成功后，和创建一样，调用 join_one_chat 事件来加入房间。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/views/chat-room/chat-room.vue</span></span><br><span class=\"line\">handleCreateJoinRoom (room) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> roomList = <span class=\"variable language_\">this</span>.<span class=\"property\">roomList</span></span><br><span class=\"line\">  roomList.<span class=\"title function_\">push</span>(room)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setRoomList&#x27;</span>, roomList)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">    <span class=\"attr\">roomId</span>: room.<span class=\"property\">id</span>,</span><br><span class=\"line\">    <span class=\"attr\">userId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;join_one_chat&#x27;</span>, request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端响应回调。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;join_one_chat&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">join_one_chat</span>(<span class=\"params\">join</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;加入聊天室</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    room = Room.query.filter_by(<span class=\"built_in\">id</span>=join[<span class=\"string\">&#x27;roomId&#x27;</span>]).first()</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=join[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(join)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> room <span class=\"keyword\">and</span> user:</span><br><span class=\"line\">        join_room(room.<span class=\"built_in\">id</span>)</span><br><span class=\"line\">        emit(<span class=\"string\">&#x27;received&#x27;</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;user&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;id&#x27;</span>: user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;name&#x27;</span>: user.username,</span><br><span class=\"line\">                <span class=\"string\">&#x27;avatarImage&#x27;</span>: user.avatar_image,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;roomId&#x27;</span>: room.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;join&#x27;</span></span><br><span class=\"line\">        &#125;, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>, room=room)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息记录的发送与保存\"><a href=\"#消息记录的发送与保存\" class=\"headerlink\" title=\"消息记录的发送与保存\"></a>消息记录的发送与保存</h3><p>先建个表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> NAMES utf8mb4;</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"operator\">-</span><span class=\"keyword\">Table</span> structure <span class=\"keyword\">for</span> room_record</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `room_record`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `room_record`  (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `content` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `room_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `user_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_record_create_time`(`create_time`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_record_room_id`(`room_id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> `room_record_ibfk_1` <span class=\"keyword\">FOREIGN</span> KEY (`room_id`) <span class=\"keyword\">REFERENCES</span> `room` (`id`) <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> RESTRICT <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> RESTRICT</span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> InnoDB AUTO_INCREMENT <span class=\"operator\">=</span> <span class=\"number\">12</span> <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> <span class=\"operator\">=</span> utf8mb4 <span class=\"keyword\">COLLATE</span> <span class=\"operator\">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class=\"operator\">=</span> <span class=\"keyword\">Dynamic</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>用户选择了对应房间，在对应房间中发送消息就 OK 了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/components/chat-room/message-box/message-box.vue</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters, mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> util <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/libs/utility/util.js&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserMessage</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../user-message/index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">JoinMessage</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../join-message/index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RichText</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/components/base/rich-text/index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;MessageBox&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123;</span><br><span class=\"line\">    <span class=\"title class_\">UserMessage</span>,</span><br><span class=\"line\">    <span class=\"title class_\">JoinMessage</span>,</span><br><span class=\"line\">    <span class=\"title class_\">RichText</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">mapGetters</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">selectedRoom</span>: <span class=\"string\">&#x27;getSelectedRoom&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">userId</span>: <span class=\"string\">&#x27;getUserId&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;getUserName&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">messageList</span>: <span class=\"string\">&#x27;getMessageList&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">isUpdate</span>: <span class=\"string\">&#x27;getUpdate&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">avatarImage</span>: <span class=\"string\">&#x27;getAvatarImage&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    selectedRoom () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setMessageContentScroll</span>()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isUpdate () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">isUpdate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.$forceUpdate()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">updateComplete</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">setMessageContentScroll</span>()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>([</span><br><span class=\"line\">      <span class=\"string\">&#x27;updateComplete&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;userInput&#x27;</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    setMessageContentScroll () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> messageContent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;messageContent&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageContent) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (messageContent.<span class=\"property\">scrollHeight</span> &gt; messageContent.<span class=\"property\">clientHeight</span>) &#123;</span><br><span class=\"line\">            messageContent.<span class=\"property\">scrollTop</span> = messageContent.<span class=\"property\">scrollHeight</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    sendMessage (message) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> messageId = <span class=\"title class_\">Number</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>())</span><br><span class=\"line\">      <span class=\"keyword\">const</span> messageContext = &#123;</span><br><span class=\"line\">        <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">id</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span>,</span><br><span class=\"line\">          <span class=\"attr\">avatarImage</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">avatarImage</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">roomId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">selectedRoom</span>.<span class=\"property\">id</span>,</span><br><span class=\"line\">        <span class=\"attr\">id</span>: messageId,</span><br><span class=\"line\">        message,</span><br><span class=\"line\">        <span class=\"attr\">loading</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;input&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">        <span class=\"attr\">userId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span>,</span><br><span class=\"line\">        <span class=\"attr\">roomId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">selectedRoom</span>.<span class=\"property\">id</span>,</span><br><span class=\"line\">        <span class=\"attr\">id</span>: messageId,</span><br><span class=\"line\">        message,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;input&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">userInput</span>(messageContext)</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;user_send_message&#x27;</span>, request)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端。接收到请求后，完成插入数据库处理并通过 received 事件返回给前端</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;user_send_message&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">user_input</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;获取用户输入</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    userId = message[<span class=\"string\">&#x27;userId&#x27;</span>]</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=message[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user:</span><br><span class=\"line\">        response = &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;user&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;id&#x27;</span>: user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;name&#x27;</span>: user.username,</span><br><span class=\"line\">                <span class=\"string\">&#x27;avatarImage&#x27;</span>: user.avatar_image,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;message&#x27;</span>: message[<span class=\"string\">&#x27;message&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;roomId&#x27;</span>: message[<span class=\"string\">&#x27;roomId&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;id&#x27;</span>: message[<span class=\"string\">&#x27;id&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;type&#x27;</span>: message[<span class=\"string\">&#x27;type&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;time&#x27;</span>: datetime.utcnow().isoformat(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        roomRecord = RoomRecord(content=message[<span class=\"string\">&#x27;message&#x27;</span>], user_id=user.<span class=\"built_in\">id</span>, room_id=message[<span class=\"string\">&#x27;roomId&#x27;</span>])</span><br><span class=\"line\">        db.session.add(roomRecord)</span><br><span class=\"line\">        db.session.commit()</span><br><span class=\"line\">        socketio.emit(<span class=\"string\">&#x27;received&#x27;</span>, response,</span><br><span class=\"line\">                        namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>,</span><br><span class=\"line\">                        room=message[<span class=\"string\">&#x27;roomId&#x27;</span>])</span><br></pre></td></tr></table></figure>\n\n<p>前端 vuex 的 room 模块接收</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/store/module/room.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">action</span>: &#123;</span><br><span class=\"line\">    updateComplete (&#123; commit &#125;) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUpdate&#x27;</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    SOCKET_received (&#123; state, rootState, commit &#125;, responseData) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> messageList = state.<span class=\"property\">messageList</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> user = rootState.<span class=\"property\">user</span></span><br><span class=\"line\">      responseData.<span class=\"property\">time</span> = <span class=\"title function_\">normalizeTimeDetail</span>(responseData.<span class=\"property\">time</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (user.<span class=\"property\">userId</span> === responseData.<span class=\"property\">user</span>.<span class=\"property\">id</span> &amp;&amp; responseData.<span class=\"property\">type</span> !== <span class=\"string\">&#x27;join&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = messageList[responseData.<span class=\"property\">roomId</span>].<span class=\"property\">length</span> <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">user</span>.<span class=\"property\">id</span> === user.<span class=\"property\">userId</span> &amp;&amp; responseData.<span class=\"property\">id</span> === messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">id</span>) &#123;</span><br><span class=\"line\">            messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">loading</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">            messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">time</span> = responseData.<span class=\"property\">time</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!state.<span class=\"property\">update</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUpdate&#x27;</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!messageList[responseData.<span class=\"property\">roomId</span>]) &#123;</span><br><span class=\"line\">          messageList[responseData.<span class=\"property\">roomId</span>] = []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        messageList[responseData.<span class=\"property\">roomId</span>].<span class=\"title function_\">push</span>(responseData)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!state.<span class=\"property\">update</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUpdate&#x27;</span>, state.<span class=\"property\">selectedRoom</span> ? responseData.<span class=\"property\">roomId</span> === state.<span class=\"property\">selectedRoom</span>.<span class=\"property\">id</span> : <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setMessageList&#x27;</span>, messageList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说到这里其实也说完了重点的地方了，有兴趣可以看看源码。第一次写文章，有不足的地方请大佬们多多指点。</p>\n<h2 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接\"></a>参考连接</h2><ul>\n<li>[1] <a href=\"https://www.runoob.com/html/html5-websocket.html\">https://www.runoob.com/html/html5-websocket.html</a></li>\n<li>[2] <a href=\"https://www.npmjs.com/package/vue-socket.io\">https://www.npmjs.com/package/vue-socket.io</a></li>\n<li>[3] <a href=\"https://flask-socketio.readthedocs.io/en/latest/\">https://flask-socketio.readthedocs.io/en/latest/</a></li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>demo 演示地址：<a href=\"http://chat.lstmxx.cn/\">http://chat.lstmxx.cn</a></p>\n<p>github 地址：<a href=\"https://github.com/Lstmxx/chatroom\">https://github.com/Lstmxx/chatroom</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>服务端推送是一种服务器主动给客户端发送的技术，主要用于实时对客户端进行消息推送，如天气预报、聊天功能等。</p>\n<h3 id=\"HTTP-1-x\"><a href=\"#HTTP-1-x\" class=\"headerlink\" title=\"HTTP 1.x\"></a>HTTP 1.x</h3><p>在 websocket api 出现之前，由于 http1.x 的缺陷，导致通信只能由客户端发起，用户想要获取到实时数据变化，就要不停的向服务器发送请求，这种方法我们一般称为轮询。这种方法在 web 端可以一用，但是在移动端就不行了，想一想你的 app 不停的消耗你的流量发请求到服务器，这会导致用户流量的大量浪费，体现极其差。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">axios</span>()<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;, <span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP 2.0\"></a>HTTP 2.0</h3><p>为了解决这一问题，终于在 http2.0 协议里面增加了一个新特性——服务器推送。而 Html5 根据这一特性提供了一种在单个 TCP 连接上进行全双工通讯的协议——<a href=\"https://www.runoob.com/html/html5-websocket.html\">WebSocket</a>。</p>\n<h3 id=\"Socketio\"><a href=\"#Socketio\" class=\"headerlink\" title=\"Socketio\"></a>Socketio</h3><h4 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h4><p>如果客户端想要使用 websocket 接受服务器推送的话，Socketio 是一个不错的选择。Socket.io 将 Websocket、轮询机制以及其它的实时通信方式（ajax 等）封装成了通用的接口，并且在服务端也实现了这些实时机制的相应代码。所以，使用 Socket.io 便不需要担心浏览器兼容问题。</p>\n<h4 id=\"namespace-和-room\"><a href=\"#namespace-和-room\" class=\"headerlink\" title=\"namespace 和 room\"></a>namespace 和 room</h4><p>socketio 有两个重要的概念——namespace 和 room。两者关系是 namespace 包含 room。举个例子，你要通知北小区的 4 座的所有用户交管理费，你先找到了北小区（namespace）然后再找到 4 座（room），最后给 4 座里面的业主发送交管理费消息。</p>\n<h2 id=\"Socketio-的安装与使用\"><a href=\"#Socketio-的安装与使用\" class=\"headerlink\" title=\"Socketio 的安装与使用\"></a>Socketio 的安装与使用</h2><h3 id=\"Vue-中使用-Socketio\"><a href=\"#Vue-中使用-Socketio\" class=\"headerlink\" title=\"Vue 中使用 Socketio\"></a>Vue 中使用 Socketio</h3><p>在 Vue 中有两种方式使用 Socketio</p>\n<h4 id=\"直接使用官方包\"><a href=\"#直接使用官方包\" class=\"headerlink\" title=\"直接使用官方包\"></a>直接使用官方包</h4><p>下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install socket.io</span><br></pre></td></tr></table></figure>\n\n<p>引入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io <span class=\"keyword\">from</span> <span class=\"string\">&#x27;socket.io-client&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的namespace和后端设置的namespace是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io.<span class=\"title function_\">connect</span>(<span class=\"string\">`http://<span class=\"subst\">$&#123;域名&#125;</span>/<span class=\"subst\">$&#123;namespace&#125;</span>`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on函数是监听函数，接受两个参数，第一个是订阅名，第二个是接受订阅信息的回调</span></span><br><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;chatMessage&#x27;</span>, <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;response&#x27;</span>, <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;connect&#x27;</span>, <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"comment\">// emit是发送函数，第一个参数是后端的订阅名，第二个是数据，可以是任意类型</span></span><br><span class=\"line\">socket.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;user_input&#x27;</span>, <span class=\"string\">&#x27;wdnmd&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-VueSocketio\"><a href=\"#使用-VueSocketio\" class=\"headerlink\" title=\"使用 VueSocketio\"></a>使用 VueSocketio</h4><p>相较于 socket.io-client，VueSocketio 自带支持在 vuex 中使用，这使得多组件共用消息更加便利。npm 地址：<a href=\"https://www.npmjs.com/package/vue-socket.io\">https://www.npmjs.com/package/vue-socket.io</a> 。</p>\n<p>下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-socket.io</span><br></pre></td></tr></table></figure>\n\n<p>引入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VueSocketio</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-socket.io&#x27;</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">VueSocketio</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">debug</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">connection</span>: <span class=\"string\">`/<span class=\"subst\">$&#123;namespace&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"comment\">/* 推荐使用vuex引入，方便多组件状态共享 */</span></span><br><span class=\"line\">  <span class=\"attr\">vuex</span>: &#123;</span><br><span class=\"line\">    store,</span><br><span class=\"line\">    <span class=\"attr\">actionPrefix</span>: <span class=\"string\">&#x27;SOCKET_&#x27;</span> <span class=\"comment\">// 前缀，为了区分vuex文件中响应函数和普通函数</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>单组件使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在需要监听的vue引入</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">sockets</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">connect</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;socket connected&#x27;</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">received</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">···</span><br></pre></td></tr></table></figure>\n\n<p>vuex 中使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /store/module/room.js</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"comment\">// responseData 为响应数据</span></span><br><span class=\"line\">SOCKET_received (&#123; state, rootState, commit &#125;, responseData) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">SOCKET_join_one (&#123;&#125;, responseData) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flask-中使用-Socketio\"><a href=\"#flask-中使用-Socketio\" class=\"headerlink\" title=\"flask 中使用 Socketio\"></a>flask 中使用 Socketio</h3><p>flask 中使用 socketio 主要用到 Flask-SocketIO 这个包，官网地址：<a href=\"https://flask-socketio.readthedocs.io/en/latest/\">https://flask-socketio.readthedocs.io/en/latest/</a> 。</p>\n<p>下载</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install flask-socketio</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">···</span><br><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_cors <span class=\"keyword\">import</span> CORS <span class=\"comment\"># 跨域</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_socketio <span class=\"keyword\">import</span> SocketIO, emit, join_room, leave_room, close_room, rooms, disconnect</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化socketio</span></span><br><span class=\"line\">socketio = SocketIO(app, cors_allowed_origins=<span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 第一个参数为事件名，第二个为namespace</span></span><br><span class=\"line\"><span class=\"comment\"># 通过监听namespace下的事件做出响应，这里的namespace和前面前端定义的namespace要相同</span></span><br><span class=\"line\"><span class=\"comment\"># message为请求参数</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;test_input&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_input</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"comment\"># do someting</span></span><br><span class=\"line\">    socketio.emit(<span class=\"string\">&#x27;test_received&#x27;</span>, <span class=\"string\">&#x27;收到啦&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在 app.py 中引入</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/app.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> blueprint.socketio <span class=\"keyword\">import</span> app, socketio, db</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    socketio.run(app, host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, port=<span class=\"number\">4999</span>, debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"nginx-配置\"><a href=\"#nginx-配置\" class=\"headerlink\" title=\"nginx 配置\"></a>nginx 配置</h3><p>既然是前后端分离，那当然要使用 nginx 啦~</p>\n<p>配置 chatroom.conf</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">upstream</span> chat_frontend &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">127.0.0.1:8181</span>; <span class=\"comment\"># 前端工程运行的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">upstream</span> chat_backend &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">127.0.0.1:4999</span>; <span class=\"comment\"># 后端工程运行的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span>       <span class=\"number\">80</span>; <span class=\"comment\"># 监听端口</span></span><br><span class=\"line\">    <span class=\"attribute\">server_name</span>  www.chatroom.com; <span class=\"comment\">#域名</span></span><br><span class=\"line\">        <span class=\"section\">location</span><span class=\"regexp\"> ^~</span> /api &#123; <span class=\"comment\"># 普通接口路由</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Server <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://chat_backend;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"section\">location</span> /socket.io &#123; <span class=\"comment\"># socketio的路由</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_http_version</span> <span class=\"number\">1</span>.<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_buffering</span> <span class=\"literal\">off</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Upgrade <span class=\"variable\">$http_upgrade</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Connection <span class=\"string\">&quot;Upgrade&quot;</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://chat_backend;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123; <span class=\"comment\"># 前端路由</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Server <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://chat_frontend;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置 host</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">···</span><br><span class=\"line\">127.0.0.1 www.chatroom.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h3><p>前面把 flask 和 vue 都配置好了，那么先测试一下。</p>\n<p>整个流程非常简单，流程图如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe93449800d38~tplv-t2oaga2asx-image.image\"></p>\n<h4 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h4><p>获取用户输入后，向目标事件发送数据。这里我自己实现了一个简陋的 rich-text，如果不追求效果直接用 input 标签就完事了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /src/components/chat-room/message-box/message-box.vue</span></span><br><span class=\"line\">···</span><br><span class=\"line\">sendMessage (message) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个参数为事件名，第二个参数为要发送的数据</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;test_input&#x27;</span>, message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 vuex 中监听 received 事件获取服务器返回消息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /src/store/module/room.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    SOCKET_test_received (&#123; state, rootState, commit &#125;, responseData) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(responseData)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flask\"><a href=\"#flask\" class=\"headerlink\" title=\"flask\"></a>flask</h4><p>后端这边就非常简单了，增加一个消息回调函数就好了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask_socketio <span class=\"keyword\">import</span> SocketIO, emit</span><br><span class=\"line\">socketio = SocketIO(app, cors_allowed_origins=<span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;test_input&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_input</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"comment\"># do someting</span></span><br><span class=\"line\">    socketio.emit(<span class=\"string\">&#x27;test_received&#x27;</span>, <span class=\"string\">&#x27;收到啦&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 或者</span></span><br><span class=\"line\">    <span class=\"comment\"># emit(&#x27;test_received&#x27;, &#x27;收到啦&#x27;, namespace=&#x27;/chatroom&#x27;)</span></span><br></pre></td></tr></table></figure>\n\n<p>要注意的是，这个 emit 没有指定某一个 room，所以会广播给在这个 namespace 下的所有人。</p>\n<p>打开谷歌浏览器，效果如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/29/172fe94c8b5e4c45~tplv-t2oaga2asx-image.image\"></p>\n<h2 id=\"实现聊天室小-demo\"><a href=\"#实现聊天室小-demo\" class=\"headerlink\" title=\"实现聊天室小 demo\"></a>实现聊天室小 demo</h2><h3 id=\"构思\"><a href=\"#构思\" class=\"headerlink\" title=\"构思\"></a>构思</h3><p>一个简单的聊天室肯定会涉及到用户，房间和消息记录。</p>\n<h3 id=\"实现登录页面\"><a href=\"#实现登录页面\" class=\"headerlink\" title=\"实现登录页面\"></a>实现登录页面</h3><p>首先解决一下用户，最核心的是登录。先建一个用户表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `<span class=\"keyword\">user</span>`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>`  (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `username` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `password` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `avatar_image` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `room_id_set` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci COMMENT <span class=\"string\">&#x27;每个用户所参加的房间&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_user_username`(`username`) <span class=\"keyword\">USING</span> BTREE</span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> InnoDB AUTO_INCREMENT <span class=\"operator\">=</span> <span class=\"number\">5</span> <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> <span class=\"operator\">=</span> utf8mb4 <span class=\"keyword\">COLLATE</span> <span class=\"operator\">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class=\"operator\">=</span> <span class=\"keyword\">Dynamic</span>;</span><br></pre></td></tr></table></figure>\n\n<p>封装一下登录接口，使用 vuex 保存登录状态。因为关闭页面后 vuex 会清掉 token 使用 cookie 来保存（axios 的封装就不说了，不是重点）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/libs/requestApi.js</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">baseLogin</span> (config) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>: config.<span class=\"property\">url</span>,</span><br><span class=\"line\">    <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: config.<span class=\"property\">data</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> service.<span class=\"title function_\">request</span>(request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/libs/request.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">login</span> (config) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">baseLogin</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(response.<span class=\"property\">data</span>.<span class=\"property\">data</span>)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存 token</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/libs/utility/token.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Cookies</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;js-cookie&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">TOKEN_KEY</span> = <span class=\"string\">&#x27;token&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">setToken</span> = (<span class=\"params\">token</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Cookies</span>.<span class=\"title function_\">set</span>(<span class=\"variable constant_\">TOKEN_KEY</span>, token, &#123; <span class=\"attr\">expires</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">getToken</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = <span class=\"title class_\">Cookies</span>.<span class=\"title function_\">get</span>(<span class=\"variable constant_\">TOKEN_KEY</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (token !== <span class=\"string\">&#x27;null&#x27;</span>) <span class=\"keyword\">return</span> token</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写 vuex 的 user 模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/store/module/user.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getToken, setToken &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../../libs/utility/token&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; login, getUserInfo, logout &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/libs/request&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">token</span>: <span class=\"title function_\">getToken</span>(),</span><br><span class=\"line\">    <span class=\"attr\">userName</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">userId</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">avatarImage</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    getToken (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">token</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getUserName (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">userName</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getUserId (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">userId</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getAvatarImage (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.<span class=\"property\">avatarImage</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">    setToken (state, token) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">token</span> = token</span><br><span class=\"line\">      <span class=\"title function_\">setToken</span>(token)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setUserName (state, name) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">userName</span> = name</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setUserId (state, userId) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">userId</span> = userId</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setAvatarImage (state, avatarImage) &#123;</span><br><span class=\"line\">      state.<span class=\"property\">avatarImage</span> = avatarImage</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    handleLogin (&#123; commit &#125;, config) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">login</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setToken&#x27;</span>, responseData.<span class=\"property\">token</span>)</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(responseData)</span><br><span class=\"line\">        &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    loadUserInfo (&#123; commit &#125;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">getUserInfo</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setToken&#x27;</span>, <span class=\"title function_\">getToken</span>())</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUserName&#x27;</span>, responseData.<span class=\"property\">userInfo</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUserId&#x27;</span>, responseData.<span class=\"property\">userInfo</span>.<span class=\"property\">userId</span>)</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setAvatarImage&#x27;</span>, responseData.<span class=\"property\">userInfo</span>.<span class=\"property\">avatar_image</span>)</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(responseData)</span><br><span class=\"line\">        &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setToken&#x27;</span>, <span class=\"literal\">null</span>)</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 login 页面中使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/views/login/login.vue</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>([</span><br><span class=\"line\">      <span class=\"string\">&#x27;handleLogin&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;loadUserInfo&#x27;</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    checkCapslock (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; key &#125; = e</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">capsTooltip</span> = key &amp;&amp; key.<span class=\"property\">length</span> === <span class=\"number\">1</span> &amp;&amp; (key &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; key &lt;= <span class=\"string\">&#x27;Z&#x27;</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 登录，成功后跳转</span></span><br><span class=\"line\">    onLogin () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">$refs</span>.<span class=\"property\">loginForm</span>.<span class=\"title function_\">validate</span>(<span class=\"function\"><span class=\"params\">valid</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (valid) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">show</span>()</span><br><span class=\"line\">          <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&#x27;/login&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">loginForm</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleLogin</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$router</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">name</span>: <span class=\"string\">&#x27;ChatRoom&#x27;</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 注册，成功后回调登录</span></span><br><span class=\"line\">    onRegister () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">$refs</span>.<span class=\"property\">loginForm</span>.<span class=\"title function_\">validate</span>(<span class=\"function\"><span class=\"params\">valid</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (valid) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">show</span>()</span><br><span class=\"line\">          <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&#x27;/register&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">loginForm</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleLogin</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">onLogin</span>()</span><br><span class=\"line\">          &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">$Loading</span>.<span class=\"title function_\">hide</span>()</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端方面，可以看看/backend/blueprint/user.py。ui 方面就不说了，不是重点。</p>\n<h3 id=\"实现房间的创建，展示和加入功能\"><a href=\"#实现房间的创建，展示和加入功能\" class=\"headerlink\" title=\"实现房间的创建，展示和加入功能\"></a>实现房间的创建，展示和加入功能</h3><p>对于房间来说，肯定要有创建和加入这两个功能的，下面先说说创建。</p>\n<p>先建个表吧</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `room`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `room`  (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `name` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `owner` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;房间创建人&#x27;</span>,</span><br><span class=\"line\">  `user_set` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci,</span><br><span class=\"line\">  `description` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `update_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `avatar_image` <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `room_hash_id` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_avatar_image`(`avatar_image`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_create_time`(`create_time`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_name`(`name`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_owner`(`owner`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_update_time`(`update_time`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> `room_ibfk_1` <span class=\"keyword\">FOREIGN</span> KEY (`owner`) <span class=\"keyword\">REFERENCES</span> `<span class=\"keyword\">user</span>` (`id`) <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> RESTRICT <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> RESTRICT</span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> InnoDB AUTO_INCREMENT <span class=\"operator\">=</span> <span class=\"number\">38</span> <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> <span class=\"operator\">=</span> utf8mb4 <span class=\"keyword\">COLLATE</span> <span class=\"operator\">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class=\"operator\">=</span> <span class=\"keyword\">Dynamic</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建房间\"><a href=\"#创建房间\" class=\"headerlink\" title=\"创建房间\"></a>创建房间</h4><p>首先先明确创建房间需要什么数据，我的想法是需要房间头像，房间名和房间描述。</p>\n<p>前端主要是获取了房间头像、房间名和房间描述后发送请求到后端。这里的 upLoadFile 是自己模仿 element 来写的组件，有兴趣可以在 /fronted/src/components/base/up-load-file/up-load-file.vue 查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// /fronted/src/components/chat-room/room-list/room-list.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">    &lt;el-dialog title=&quot;创建房间&quot; :visible.sync=&quot;createRoomDialog&quot;&gt;</span><br><span class=\"line\">      &lt;el-form :model=&quot;createRoom&quot; :rules=&quot;createRules&quot; ref=&quot;createRoomForm&quot;&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间名&quot; prop=&quot;hashId&quot;&gt;</span><br><span class=\"line\">          &lt;el-input v-model=&quot;createRoom.name&quot; autocomplete=&quot;off&quot; :maxlength=&#x27;32&#x27; :minlength=&#x27;32&#x27;&gt;&lt;/el-input&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间描述&quot; prop=&quot;description&quot;&gt;</span><br><span class=\"line\">          &lt;el-input v-model=&quot;createRoom.description&quot; autocomplete=&quot;off&quot; :maxlength=&#x27;32&#x27; :minlength=&#x27;32&#x27;&gt;&lt;/el-input&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间头像&quot; prop=&quot;avatarImage&quot;&gt;</span><br><span class=\"line\">          &lt;upLoadFile :maxImageNum=&quot;1&quot; @on-change=&quot;getFilePath&quot;/&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">      &lt;/el-form&gt;</span><br><span class=\"line\">      &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">        &lt;el-button @click=&quot;createRoomDialog = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class=\"line\">        &lt;el-button type=&quot;primary&quot; @click=&quot;handleCreateRoom&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/el-dialog&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; post &#125; from &#x27;@/libs/request&#x27;</span><br><span class=\"line\">import upLoadFile from &#x27;@/components/base/up-load-file&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;RoomList&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    roomList: &#123;</span><br><span class=\"line\">      default: () =&gt; [],</span><br><span class=\"line\">      type: Array</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    upLoadFile</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ···</span><br><span class=\"line\">      createRoom: &#123;</span><br><span class=\"line\">        name: &#x27;&#x27;,</span><br><span class=\"line\">        description: &#x27;&#x27;,</span><br><span class=\"line\">        avatarImage: &#x27;&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  method: &#123;</span><br><span class=\"line\">    getFilePath (imageList) &#123;</span><br><span class=\"line\">      this.createRoom.avatarImage = imageList[0].base64Path</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleCreateRoom () &#123;</span><br><span class=\"line\">      this.$refs.createRoomForm.validate(valid =&gt; &#123;</span><br><span class=\"line\">        if (valid) &#123;</span><br><span class=\"line\">          this.$Loading.show()</span><br><span class=\"line\">          const config = &#123;</span><br><span class=\"line\">            url: &#x27;/room/create&#x27;,</span><br><span class=\"line\">            data: this.createRoom</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          post(config).then((responseData) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            this.createRoom.name = &#x27;&#x27;</span><br><span class=\"line\">            this.createRoomDialog = false</span><br><span class=\"line\">            this.createRoom = &#123;</span><br><span class=\"line\">              name: &#x27;&#x27;,</span><br><span class=\"line\">              description: &#x27;&#x27;,</span><br><span class=\"line\">              avatarImage: &#x27;&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            this.$message(&#123;</span><br><span class=\"line\">              message: &#x27;创建成功&#x27;,</span><br><span class=\"line\">              type: &#x27;success&#x27;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.$emit(&#x27;create-room-success&#x27;, responseData.room)</span><br><span class=\"line\">          &#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            this.createRoomDialog = false</span><br><span class=\"line\">            console.log(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>后端这边就简单了，直接插入数据库。插入时候使用 base64 来生成房间码，之后加入房间要用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/room.py</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"meta\">@room_bp.route(<span class=\"params\"><span class=\"string\">&#x27;/api/room/create&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@verify_token</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">room_create</span>(<span class=\"params\">tokenData</span>):</span><br><span class=\"line\">    values = request.get_json()</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=tokenData[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user:</span><br><span class=\"line\">        room = Room(name=values[<span class=\"string\">&#x27;name&#x27;</span>],</span><br><span class=\"line\">                    description=values[<span class=\"string\">&#x27;description&#x27;</span>],</span><br><span class=\"line\">                    user_set=<span class=\"built_in\">str</span>(tokenData[<span class=\"string\">&#x27;userId&#x27;</span>]),</span><br><span class=\"line\">                    owner=user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                    avatar_image=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        db.session.add(room)</span><br><span class=\"line\">        db.session.flush()</span><br><span class=\"line\">        room.room_hash_id = hashlib.md5(<span class=\"string\">f&#x27;<span class=\"subst\">&#123;room.<span class=\"built_in\">id</span>&#125;</span><span class=\"subst\">&#123;time.time()&#125;</span>&#x27;</span>.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class=\"line\">        room.user_set = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;room.user_set&#125;</span>,<span class=\"subst\">&#123;user.<span class=\"built_in\">id</span>&#125;</span>&#x27;</span> <span class=\"keyword\">if</span> room.user_set <span class=\"keyword\">else</span> user.<span class=\"built_in\">id</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> values[<span class=\"string\">&#x27;avatarImage&#x27;</span>]:</span><br><span class=\"line\">            avatartImageList = values[<span class=\"string\">&#x27;avatarImage&#x27;</span>].split(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">            suffix = avatartImageList[<span class=\"number\">0</span>].split(<span class=\"string\">&#x27;/&#x27;</span>)[<span class=\"number\">1</span>].split(<span class=\"string\">&#x27;;&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">            filename = <span class=\"string\">f&#x27;room_avatar/<span class=\"subst\">&#123;room.room_hash_id&#125;</span>.<span class=\"subst\">&#123;suffix&#125;</span>&#x27;</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(filename)</span><br><span class=\"line\">            <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&#x27;media/<span class=\"subst\">&#123;filename&#125;</span>&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">                f.write(base64.b64decode(avatartImageList[<span class=\"number\">1</span>]))</span><br><span class=\"line\">            room.avatar_image = filename</span><br><span class=\"line\">        user.room_id_set = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;user.room_id_set&#125;</span>,<span class=\"subst\">&#123;room.<span class=\"built_in\">id</span>&#125;</span>&#x27;</span> <span class=\"keyword\">if</span> user.room_id_set <span class=\"keyword\">else</span> room.<span class=\"built_in\">id</span></span><br><span class=\"line\">        db.session.commit()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;data&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;room&#x27;</span>: JSONHelper.model_to_json(room)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;成功&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;data&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;失败失败&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">500</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"展示房间\"><a href=\"#展示房间\" class=\"headerlink\" title=\"展示房间\"></a>展示房间</h4><p>这个其实就是拉一个房间列表。要注意的是前端获取到房间列表后，要调用 join_all 这个事件监听这些房间的消息。</p>\n<p>后端</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@room_bp.route(<span class=\"params\"><span class=\"string\">&#x27;/api/room/list&#x27;</span>, methods=[<span class=\"string\">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@verify_token</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">room_list</span>(<span class=\"params\">tokenData</span>):</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=tokenData[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user:</span><br><span class=\"line\">        roomlist = Room.query.<span class=\"built_in\">filter</span>(Room.<span class=\"built_in\">id</span>.in_(user.room_id_set.split(<span class=\"string\">&#x27;,&#x27;</span>))).<span class=\"built_in\">all</span>() <span class=\"keyword\">if</span> user.room_id_set <span class=\"keyword\">else</span> []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;data&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;roomList&#x27;</span>: JSONHelper.to_json_list(roomlist)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;成功&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;data&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;失败失败&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;status&#x27;</span>: <span class=\"number\">500</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>前端这边先在 room 模块里编写加载房间列表函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/store/module/room.js</span></span><br><span class=\"line\">···</span><br><span class=\"line\">loadRoomList (&#123; commit &#125;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&#x27;/room/list&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(config).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">responseData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setRoomList&#x27;</span>, responseData.<span class=\"property\">roomList</span>)</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(responseData.<span class=\"property\">roomList</span>)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 chat-room 页面调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/views/chat-room/chat-room.vue</span></span><br><span class=\"line\">mounted () &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">loadRoomList</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">roomList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">      <span class=\"attr\">roomList</span>: roomList.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">room</span> =&gt;</span> room.<span class=\"property\">id</span>),</span><br><span class=\"line\">      <span class=\"attr\">userId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;join_all&#x27;</span>, request)</span><br><span class=\"line\">  &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端响应 join_all 事件，调用 join_room 加入用户所在的所有房间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;join_all&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">join_chats</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;加入多个聊天室</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=message[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user <span class=\"keyword\">and</span> <span class=\"built_in\">len</span>(message[<span class=\"string\">&#x27;roomList&#x27;</span>]) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> roomId <span class=\"keyword\">in</span> message[<span class=\"string\">&#x27;roomList&#x27;</span>]:</span><br><span class=\"line\">            join_room(roomId)</span><br><span class=\"line\">            emit(<span class=\"string\">&#x27;received&#x27;</span>, &#123; <span class=\"comment\"># 发送加入消息</span></span><br><span class=\"line\">                <span class=\"string\">&#x27;user&#x27;</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">&#x27;id&#x27;</span>: user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;name&#x27;</span>: user.username,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;avatarImage&#x27;</span>: user.avatar_image,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"string\">&#x27;roomId&#x27;</span>: roomId,</span><br><span class=\"line\">                <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;join&#x27;</span></span><br><span class=\"line\">            &#125;, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>, room=roomId)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"加入房间\"><a href=\"#加入房间\" class=\"headerlink\" title=\"加入房间\"></a>加入房间</h4><p>获取对应的房间码后，输入加入就 OK 了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// /fronted/src/components/chat-room/room-list/room-list.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">    &lt;el-dialog title=&quot;加入房间&quot; :visible.sync=&quot;joinRoomDialog&quot;&gt;</span><br><span class=\"line\">      &lt;el-form :model=&quot;joinRoom&quot; :rules=&quot;joinRules&quot; ref=&quot;joinRoomForm&quot;&gt;</span><br><span class=\"line\">        &lt;el-form-item label=&quot;房间号&quot; prop=&quot;hashId&quot;&gt;</span><br><span class=\"line\">          &lt;el-input v-model=&quot;joinRoom.hashId&quot; autocomplete=&quot;off&quot; :maxlength=&#x27;32&#x27; :minlength=&#x27;32&#x27;&gt;&lt;/el-input&gt;</span><br><span class=\"line\">        &lt;/el-form-item&gt;</span><br><span class=\"line\">      &lt;/el-form&gt;</span><br><span class=\"line\">      &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class=\"line\">        &lt;el-button @click=&quot;joinRoomDialog = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class=\"line\">        &lt;el-button type=&quot;primary&quot; @click=&quot;handleJoinRoom&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/el-dialog&gt;</span><br><span class=\"line\">···</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; post &#125; from &#x27;@/libs/request&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;RoomList&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    roomList: &#123;</span><br><span class=\"line\">      default: () =&gt; [],</span><br><span class=\"line\">      type: Array</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ···</span><br><span class=\"line\">      joinRoom: &#123;</span><br><span class=\"line\">        hashId: &#x27;&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  method: &#123;</span><br><span class=\"line\">    handleJoinRoom () &#123;</span><br><span class=\"line\">      this.$refs.joinRoomForm.validate(valid =&gt; &#123;</span><br><span class=\"line\">        if (valid) &#123;</span><br><span class=\"line\">          this.$Loading.show()</span><br><span class=\"line\">          const config = &#123;</span><br><span class=\"line\">            url: &#x27;/room/join&#x27;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">              roomIdHash: this.joinRoom.hashId</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          post(config).then((responseData) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            this.joinRoomDialog = false</span><br><span class=\"line\">            this.$message(&#123;</span><br><span class=\"line\">              message: &#x27;加入成功&#x27;,</span><br><span class=\"line\">              type: &#x27;success&#x27;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.$emit(&#x27;create-room-success&#x27;, responseData.room)</span><br><span class=\"line\">          &#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">            this.$Loading.hide()</span><br><span class=\"line\">            console.log(err)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>加入成功后，和创建一样，调用 join_one_chat 事件来加入房间。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/views/chat-room/chat-room.vue</span></span><br><span class=\"line\">handleCreateJoinRoom (room) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> roomList = <span class=\"variable language_\">this</span>.<span class=\"property\">roomList</span></span><br><span class=\"line\">  roomList.<span class=\"title function_\">push</span>(room)</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$store</span>.<span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setRoomList&#x27;</span>, roomList)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">    <span class=\"attr\">roomId</span>: room.<span class=\"property\">id</span>,</span><br><span class=\"line\">    <span class=\"attr\">userId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;join_one_chat&#x27;</span>, request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端响应回调。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;join_one_chat&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">join_one_chat</span>(<span class=\"params\">join</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;加入聊天室</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    room = Room.query.filter_by(<span class=\"built_in\">id</span>=join[<span class=\"string\">&#x27;roomId&#x27;</span>]).first()</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=join[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(join)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> room <span class=\"keyword\">and</span> user:</span><br><span class=\"line\">        join_room(room.<span class=\"built_in\">id</span>)</span><br><span class=\"line\">        emit(<span class=\"string\">&#x27;received&#x27;</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;user&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;id&#x27;</span>: user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;name&#x27;</span>: user.username,</span><br><span class=\"line\">                <span class=\"string\">&#x27;avatarImage&#x27;</span>: user.avatar_image,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;roomId&#x27;</span>: room.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;join&#x27;</span></span><br><span class=\"line\">        &#125;, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>, room=room)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息记录的发送与保存\"><a href=\"#消息记录的发送与保存\" class=\"headerlink\" title=\"消息记录的发送与保存\"></a>消息记录的发送与保存</h3><p>先建个表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> NAMES utf8mb4;</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"operator\">-</span><span class=\"keyword\">Table</span> structure <span class=\"keyword\">for</span> room_record</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `room_record`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `room_record`  (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `content` longtext <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8mb4 <span class=\"keyword\">COLLATE</span> utf8mb4_0900_ai_ci,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">0</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `room_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `user_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_record_create_time`(`create_time`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  INDEX `ix_room_record_room_id`(`room_id`) <span class=\"keyword\">USING</span> BTREE,</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> `room_record_ibfk_1` <span class=\"keyword\">FOREIGN</span> KEY (`room_id`) <span class=\"keyword\">REFERENCES</span> `room` (`id`) <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> RESTRICT <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> RESTRICT</span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> InnoDB AUTO_INCREMENT <span class=\"operator\">=</span> <span class=\"number\">12</span> <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> <span class=\"operator\">=</span> utf8mb4 <span class=\"keyword\">COLLATE</span> <span class=\"operator\">=</span> utf8mb4_0900_ai_ci ROW_FORMAT <span class=\"operator\">=</span> <span class=\"keyword\">Dynamic</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>用户选择了对应房间，在对应房间中发送消息就 OK 了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/components/chat-room/message-box/message-box.vue</span></span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters, mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> util <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/libs/utility/util.js&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserMessage</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../user-message/index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">JoinMessage</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../join-message/index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RichText</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@/components/base/rich-text/index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;MessageBox&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123;</span><br><span class=\"line\">    <span class=\"title class_\">UserMessage</span>,</span><br><span class=\"line\">    <span class=\"title class_\">JoinMessage</span>,</span><br><span class=\"line\">    <span class=\"title class_\">RichText</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">mapGetters</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">selectedRoom</span>: <span class=\"string\">&#x27;getSelectedRoom&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">userId</span>: <span class=\"string\">&#x27;getUserId&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;getUserName&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">messageList</span>: <span class=\"string\">&#x27;getMessageList&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">isUpdate</span>: <span class=\"string\">&#x27;getUpdate&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">avatarImage</span>: <span class=\"string\">&#x27;getAvatarImage&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    selectedRoom () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setMessageContentScroll</span>()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isUpdate () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">isUpdate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.$forceUpdate()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">updateComplete</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">setMessageContentScroll</span>()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">mapActions</span>([</span><br><span class=\"line\">      <span class=\"string\">&#x27;updateComplete&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;userInput&#x27;</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    setMessageContentScroll () &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> messageContent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;messageContent&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageContent) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (messageContent.<span class=\"property\">scrollHeight</span> &gt; messageContent.<span class=\"property\">clientHeight</span>) &#123;</span><br><span class=\"line\">            messageContent.<span class=\"property\">scrollTop</span> = messageContent.<span class=\"property\">scrollHeight</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    sendMessage (message) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> messageId = <span class=\"title class_\">Number</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>())</span><br><span class=\"line\">      <span class=\"keyword\">const</span> messageContext = &#123;</span><br><span class=\"line\">        <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">id</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span>,</span><br><span class=\"line\">          <span class=\"attr\">avatarImage</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">avatarImage</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">roomId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">selectedRoom</span>.<span class=\"property\">id</span>,</span><br><span class=\"line\">        <span class=\"attr\">id</span>: messageId,</span><br><span class=\"line\">        message,</span><br><span class=\"line\">        <span class=\"attr\">loading</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;input&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = &#123;</span><br><span class=\"line\">        <span class=\"attr\">userId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">userId</span>,</span><br><span class=\"line\">        <span class=\"attr\">roomId</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">selectedRoom</span>.<span class=\"property\">id</span>,</span><br><span class=\"line\">        <span class=\"attr\">id</span>: messageId,</span><br><span class=\"line\">        message,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;input&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">userInput</span>(messageContext)</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">$socket</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">&#x27;user_send_message&#x27;</span>, request)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后端。接收到请求后，完成插入数据库处理并通过 received 事件返回给前端</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /backend/blueprint/socketio.py</span></span><br><span class=\"line\"><span class=\"meta\">@socketio.on(<span class=\"params\"><span class=\"string\">&#x27;user_send_message&#x27;</span>, namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">user_input</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;获取用户输入</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    userId = message[<span class=\"string\">&#x27;userId&#x27;</span>]</span><br><span class=\"line\">    user = User.query.filter_by(<span class=\"built_in\">id</span>=message[<span class=\"string\">&#x27;userId&#x27;</span>]).first()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user:</span><br><span class=\"line\">        response = &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;user&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;id&#x27;</span>: user.<span class=\"built_in\">id</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;name&#x27;</span>: user.username,</span><br><span class=\"line\">                <span class=\"string\">&#x27;avatarImage&#x27;</span>: user.avatar_image,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&#x27;message&#x27;</span>: message[<span class=\"string\">&#x27;message&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;roomId&#x27;</span>: message[<span class=\"string\">&#x27;roomId&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;id&#x27;</span>: message[<span class=\"string\">&#x27;id&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;type&#x27;</span>: message[<span class=\"string\">&#x27;type&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;time&#x27;</span>: datetime.utcnow().isoformat(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        roomRecord = RoomRecord(content=message[<span class=\"string\">&#x27;message&#x27;</span>], user_id=user.<span class=\"built_in\">id</span>, room_id=message[<span class=\"string\">&#x27;roomId&#x27;</span>])</span><br><span class=\"line\">        db.session.add(roomRecord)</span><br><span class=\"line\">        db.session.commit()</span><br><span class=\"line\">        socketio.emit(<span class=\"string\">&#x27;received&#x27;</span>, response,</span><br><span class=\"line\">                        namespace=<span class=\"string\">&#x27;/chatroom&#x27;</span>,</span><br><span class=\"line\">                        room=message[<span class=\"string\">&#x27;roomId&#x27;</span>])</span><br></pre></td></tr></table></figure>\n\n<p>前端 vuex 的 room 模块接收</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /fronted/src/store/module/room.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">action</span>: &#123;</span><br><span class=\"line\">    updateComplete (&#123; commit &#125;) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUpdate&#x27;</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    SOCKET_received (&#123; state, rootState, commit &#125;, responseData) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> messageList = state.<span class=\"property\">messageList</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> user = rootState.<span class=\"property\">user</span></span><br><span class=\"line\">      responseData.<span class=\"property\">time</span> = <span class=\"title function_\">normalizeTimeDetail</span>(responseData.<span class=\"property\">time</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (user.<span class=\"property\">userId</span> === responseData.<span class=\"property\">user</span>.<span class=\"property\">id</span> &amp;&amp; responseData.<span class=\"property\">type</span> !== <span class=\"string\">&#x27;join&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = messageList[responseData.<span class=\"property\">roomId</span>].<span class=\"property\">length</span> <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">user</span>.<span class=\"property\">id</span> === user.<span class=\"property\">userId</span> &amp;&amp; responseData.<span class=\"property\">id</span> === messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">id</span>) &#123;</span><br><span class=\"line\">            messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">loading</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">            messageList[responseData.<span class=\"property\">roomId</span>][i].<span class=\"property\">time</span> = responseData.<span class=\"property\">time</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!state.<span class=\"property\">update</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUpdate&#x27;</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!messageList[responseData.<span class=\"property\">roomId</span>]) &#123;</span><br><span class=\"line\">          messageList[responseData.<span class=\"property\">roomId</span>] = []</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        messageList[responseData.<span class=\"property\">roomId</span>].<span class=\"title function_\">push</span>(responseData)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!state.<span class=\"property\">update</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setUpdate&#x27;</span>, state.<span class=\"property\">selectedRoom</span> ? responseData.<span class=\"property\">roomId</span> === state.<span class=\"property\">selectedRoom</span>.<span class=\"property\">id</span> : <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">commit</span>(<span class=\"string\">&#x27;setMessageList&#x27;</span>, messageList)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说到这里其实也说完了重点的地方了，有兴趣可以看看源码。第一次写文章，有不足的地方请大佬们多多指点。</p>\n<h2 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接\"></a>参考连接</h2><ul>\n<li>[1] <a href=\"https://www.runoob.com/html/html5-websocket.html\">https://www.runoob.com/html/html5-websocket.html</a></li>\n<li>[2] <a href=\"https://www.npmjs.com/package/vue-socket.io\">https://www.npmjs.com/package/vue-socket.io</a></li>\n<li>[3] <a href=\"https://flask-socketio.readthedocs.io/en/latest/\">https://flask-socketio.readthedocs.io/en/latest/</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}